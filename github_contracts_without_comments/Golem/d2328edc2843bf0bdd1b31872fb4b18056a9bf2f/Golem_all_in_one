pragma solidity ^0.4.4;

import ;


contract migrationagent {
    function migratefrom(address _from, uint256 _value);
}


contract golemnetworktoken {
    string public constant name = ;
    string public constant symbol = ;
    uint8 public constant decimals = 18;  

    uint256 public constant tokencreationrate = 1000;

    
    uint256 public constant tokencreationcap = 820000 ether * tokencreationrate;
    uint256 public constant tokencreationmin = 150000 ether * tokencreationrate;

    uint256 public fundingstartblock;
    uint256 public fundingendblock;

    
    bool public funding = true;

    
    address public golemfactory;

    
    address public migrationmaster;

    gntallocation lockedallocation;

    
    uint256 totaltokens;

    mapping (address => uint256) balances;

    address public migrationagent;
    uint256 public totalmigrated;

    event transfer(address indexed _from, address indexed _to, uint256 _value);
    event migrate(address indexed _from, address indexed _to, uint256 _value);
    event refund(address indexed _from, uint256 _value);

    function golemnetworktoken(address _golemfactory,
                               address _migrationmaster,
                               uint256 _fundingstartblock,
                               uint256 _fundingendblock) {

        if (_golemfactory == 0) throw;
        if (_migrationmaster == 0) throw;
        if (_fundingstartblock <= block.number) throw;
        if (_fundingendblock   <= _fundingstartblock) throw;

        lockedallocation = new gntallocation(_golemfactory);
        migrationmaster = _migrationmaster;
        golemfactory = _golemfactory;
        fundingstartblock = _fundingstartblock;
        fundingendblock = _fundingendblock;
    }

    
    
    
    
    
    
    
    function transfer(address _to, uint256 _value) returns (bool) {
        
        if (funding) throw;

        var senderbalance = balances[msg.sender];
        if (senderbalance >= _value && _value > 0) {
            senderbalance = _value;
            balances[msg.sender] = senderbalance;
            balances[_to] += _value;
            transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }

    function totalsupply() external constant returns (uint256) {
        return totaltokens;
    }

    function balanceof(address _owner) external constant returns (uint256) {
        return balances[_owner];
    }

    

    
    
    
    function migrate(uint256 _value) external {
        
        if (funding) throw;
        if (migrationagent == 0) throw;

        
        if (_value == 0) throw;
        if (_value > balances[msg.sender]) throw;

        balances[msg.sender] = _value;
        totaltokens = _value;
        totalmigrated += _value;
        migrationagent(migrationagent).migratefrom(msg.sender, _value);
        migrate(msg.sender, migrationagent, _value);
    }

    
	
    
    
    
    function setmigrationagent(address _agent) external {
        
        if (funding) throw;
        if (migrationagent != 0) throw;
        if (msg.sender != migrationmaster) throw;
        migrationagent = _agent;
    }

    function setmigrationmaster(address _master) external {
        if (msg.sender != migrationmaster) throw;
        if (_master == 0) throw;
        migrationmaster = _master;
    }

    

    
    
    
    function create() payable external {
        
        
        
        if (!funding) throw;
        if (block.number < fundingstartblock) throw;
        if (block.number > fundingendblock) throw;

        
        if (msg.value == 0) throw;
        if (msg.value > (tokencreationcap  totaltokens) / tokencreationrate)
            throw;

        var numtokens = msg.value * tokencreationrate;
        totaltokens += numtokens;

        
        balances[msg.sender] += numtokens;

        
        transfer(0, msg.sender, numtokens);
    }

    
    
    
    
    
    
    function finalize() external {
        
        if (!funding) throw;
        if ((block.number <= fundingendblock ||
             totaltokens < tokencreationmin) &&
            totaltokens < tokencreationcap) throw;

        
        funding = false;

        
        
        
        
        uint256 percentoftotal = 18;
        uint256 additionaltokens =
            totaltokens * percentoftotal / (100  percentoftotal);
        totaltokens += additionaltokens;
        balances[lockedallocation] += additionaltokens;
        transfer(0, lockedallocation, additionaltokens);

        
        if (!golemfactory.send(this.balance)) throw;
    }

    
    
    
    function refund() external {
        
        if (!funding) throw;
        if (block.number <= fundingendblock) throw;
        if (totaltokens >= tokencreationmin) throw;

        var gntvalue = balances[msg.sender];
        if (gntvalue == 0) throw;
        balances[msg.sender] = 0;
        totaltokens = gntvalue;

        var ethvalue = gntvalue / tokencreationrate;
        refund(msg.sender, ethvalue);
        if (!msg.sender.send(ethvalue)) throw;
    }
}

pragma solidity ^0.4.4;

import * as source from ;

contract gnttargettoken {

    address migrationagent;

    
    uint256 totaltokens;
    mapping (address => uint256) balances;

    
    event transfer(address indexed _from, address indexed _to, uint256 _value);

    function gnttargettoken(address _migrationagent) {
        migrationagent = _migrationagent;
        
    }

    
    function createtoken(address _target, uint256 _amount) {
        if (msg.sender != migrationagent) throw;

        balances[_target] += _amount;
        totaltokens += _amount;

        transfer(migrationagent, _target, _amount);
    }

    function finalizemigration() {
        if (msg.sender != migrationagent) throw;

        migrationagent = 0;
    }

    
    function transfer(address _to, uint256 _value) returns (bool success) {
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] = _value;
            balances[_to] += _value;
            transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }

    function totalsupply() constant returns (uint256) {
        return totaltokens;
    }

    function balanceof(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
}


contract migrationagent {

    address owner;
    address gntsourcetoken;
    address gnttargettoken;

    uint256 tokensupply;

    function migrationagent(address _gntsourcetoken) {
        owner = msg.sender;
        gntsourcetoken = _gntsourcetoken;

        if (source.golemnetworktoken(gntsourcetoken).funding()) throw;

        tokensupply = source.golemnetworktoken(gntsourcetoken).totalsupply();
    }

    function safetyinvariantcheck(uint256 _value) private {
        if (gnttargettoken == 0) throw;
        if (source.golemnetworktoken(gntsourcetoken).totalsupply() + gnttargettoken(gnttargettoken).totalsupply() != tokensupply  _value) throw;
    }

    function settargettoken(address _gnttargettoken) {
        if (msg.sender != owner) throw;
        if (gnttargettoken != 0) throw; 

        gnttargettoken = _gnttargettoken;
    }

    
    function migratefrom(address _from, uint256 _value) {
        if (msg.sender != gntsourcetoken) throw;
        if (gnttargettoken == 0) throw;

        
        safetyinvariantcheck(_value);

        gnttargettoken(gnttargettoken).createtoken(_from, _value);

        
        safetyinvariantcheck(0);
    }

    function finalizemigration() {
        if (msg.sender != owner) throw;

        safetyinvariantcheck(0);

        
        

        gnttargettoken(gnttargettoken).finalizemigration();

        gntsourcetoken = 0;
        gnttargettoken = 0;

        tokensupply = 0;
    }

}

pragma solidity ^0.4.4;











contract multiowned {

    

    
    struct pendingstate {
        uint yetneeded;
        uint ownersdone;
        uint index;
    }

    

    
    
    event confirmation(address owner, bytes32 operation);
    event revoke(address owner, bytes32 operation);
    
    event ownerchanged(address oldowner, address newowner);
    event owneradded(address newowner);
    event ownerremoved(address oldowner);
    
    event requirementchanged(uint newrequirement);

    

    
    modifier onlyowner {
        if (isowner(msg.sender))
            _;
    }
    
    
    
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmandcheck(_operation))
            _;
    }

    

    
    
    function multiowned(address[] _owners, uint _required) {
        m_numowners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerindex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerindex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }
    
    
    function revoke(bytes32 _operation) external {
        uint ownerindex = m_ownerindex[uint(msg.sender)];
        
        if (ownerindex == 0) return;
        uint ownerindexbit = 2**ownerindex;
        var pending = m_pending[_operation];
        if (pending.ownersdone & ownerindexbit > 0) {
            pending.yetneeded++;
            pending.ownersdone = ownerindexbit;
            revoke(msg.sender, _operation);
        }
    }
    
    
    function changeowner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {
        if (isowner(_to)) return;
        uint ownerindex = m_ownerindex[uint(_from)];
        if (ownerindex == 0) return;

        clearpending();
        m_owners[ownerindex] = uint(_to);
        m_ownerindex[uint(_from)] = 0;
        m_ownerindex[uint(_to)] = ownerindex;
        ownerchanged(_from, _to);
    }
    
    function addowner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {
        if (isowner(_owner)) return;

        clearpending();
        if (m_numowners >= c_maxowners)
            reorganizeowners();
        if (m_numowners >= c_maxowners)
            return;
        m_numowners++;
        m_owners[m_numowners] = uint(_owner);
        m_ownerindex[uint(_owner)] = m_numowners;
        owneradded(_owner);
    }
    
    function removeowner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {
        uint ownerindex = m_ownerindex[uint(_owner)];
        if (ownerindex == 0) return;
        if (m_required > m_numowners  1) return;

        m_owners[ownerindex] = 0;
        m_ownerindex[uint(_owner)] = 0;
        clearpending();
        reorganizeowners(); 
        ownerremoved(_owner);
    }
    
    function changerequirement(uint _newrequired) onlymanyowners(sha3(msg.data, block.number)) external {
        if (_newrequired > m_numowners) return;
        m_required = _newrequired;
        clearpending();
        requirementchanged(_newrequired);
    }
    
    function isowner(address _addr) returns (bool) {
        return m_ownerindex[uint(_addr)] > 0;
    }
    
    function hasconfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerindex = m_ownerindex[uint(_owner)];

        
        if (ownerindex == 0) return false;

        
        uint ownerindexbit = 2**ownerindex;
        if (pending.ownersdone & ownerindexbit == 0) {
            return false;
        } else {
            return true;
        }
    }
    
    

    function confirmandcheck(bytes32 _operation) internal returns (bool) {
        
        uint ownerindex = m_ownerindex[uint(msg.sender)];
        
        if (ownerindex == 0) return;

        var pending = m_pending[_operation];
        
        if (pending.yetneeded == 0) {
            
            pending.yetneeded = m_required;
            
            pending.ownersdone = 0;
            pending.index = m_pendingindex.length++;
            m_pendingindex[pending.index] = _operation;
        }
        
        uint ownerindexbit = 2**ownerindex;
        
        if (pending.ownersdone & ownerindexbit == 0) {
            confirmation(msg.sender, _operation);
            
            if (pending.yetneeded <= 1) {
                
                delete m_pendingindex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                
                pending.yetneeded;
                pending.ownersdone |= ownerindexbit;
            }
        }
    }

    function reorganizeowners() private returns (bool) {
        uint free = 1;
        while (free < m_numowners)
        {
            while (free < m_numowners && m_owners[free] != 0) free++;
            while (m_numowners > 1 && m_owners[m_numowners] == 0) m_numowners;
            if (free < m_numowners && m_owners[m_numowners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numowners];
                m_ownerindex[m_owners[free]] = free;
                m_owners[m_numowners] = 0;
            }
        }
    }
    
    function clearpending() internal {
        uint length = m_pendingindex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingindex[i] != 0)
                delete m_pending[m_pendingindex[i]];
        delete m_pendingindex;
    }
        
    

    
    uint public m_required;
    
    uint public m_numowners;
    
    
    uint[256] m_owners;
    uint constant c_maxowners = 250;
    
    mapping(uint => uint) m_ownerindex;
    
    mapping(bytes32 => pendingstate) m_pending;
    bytes32[] m_pendingindex;
}




contract daylimit is multiowned {

    

    
    modifier limiteddaily(uint _value) {
        if (underlimit(_value))
            _;
    }

    

    
    function daylimit(uint _limit) {
        m_dailylimit = _limit;
        m_lastday = today();
    }
    
    function setdailylimit(uint _newlimit) onlymanyowners(sha3(msg.data, block.number)) external {
        m_dailylimit = _newlimit;
    }
    
    function resetspenttoday() onlymanyowners(sha3(msg.data, block.number)) external {
        m_spenttoday = 0;
    }
    
    
    
    
    
    function underlimit(uint _value) internal onlyowner returns (bool) {
        
        if (today() > m_lastday) {
            m_spenttoday = 0;
            m_lastday = today();
        }
        
        if (m_spenttoday + _value >= m_spenttoday && m_spenttoday + _value <= m_dailylimit) {
            m_spenttoday += _value;
            return true;
        }
        return false;
    }
    
    function today() private constant returns (uint) { return now / 1 days; }

    

    uint public m_dailylimit;
    uint public m_spenttoday;
    uint public m_lastday;
}


contract multisig {

    

    
    
    event deposit(address from, uint value);
    
    event singletransact(address owner, uint value, address to, bytes data);
    
    event multitransact(address owner, bytes32 operation, uint value, address to, bytes data);
    
    event confirmationneeded(bytes32 operation, address initiator, uint value, address to, bytes data);
    
    
    
    
    function changeowner(address _from, address _to) external;
    function execute(address _to, uint _value, bytes _data) external returns (bytes32);
    function confirm(bytes32 _h) returns (bool);
}




contract wallet is multisig, multiowned, daylimit {

    uint public version = 2;

    

    
    struct transaction {
        address to;
        uint value;
        bytes data;
    }

    

    
    
    function wallet(address[] _owners, uint _required, uint _daylimit)
            multiowned(_owners, _required) daylimit(_daylimit) {
    }
    
    
    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {
        suicide(_to);
    }
    
    
    function() payable {
        
        if (msg.value > 0)
            deposit(msg.sender, msg.value);
    }
    
    
    
    
    
    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {
        
        if (underlimit(_value)) {
            
            
            _to.call.value(_value)(_data);
            return 0;
        }
        
        _r = sha3(msg.data, block.number);
        if (!confirm(_r) && m_txs[_r].to == 0) {
            m_txs[_r].to = _to;
            m_txs[_r].value = _value;
            m_txs[_r].data = _data;
            confirmationneeded(_r, msg.sender, _value, _to, _data);
        }
    }
    
    
    
    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {
        if (m_txs[_h].to != 0) {
            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);
            multitransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);
            delete m_txs[_h];
            return true;
        }
    }
    
    
    
    function clearpending() internal {
        uint length = m_pendingindex.length;
        for (uint i = 0; i < length; ++i)
            delete m_txs[m_pendingindex[i]];
        super.clearpending();
    }

    

    
    mapping (bytes32 => transaction) m_txs;
}

pragma solidity ^0.4.4;

import ;

contract timelockedgntproxyaccount {

    address public owner;

    uint256 public availableafter;
    golemnetworktoken public gnt;

    

    modifier owneronly {
        if (msg.sender != owner) throw;
        _;
    }

    modifier notlocked {
    	if (now < availableafter) throw;
    	_;
    }

    

    function timelockedgntproxyaccount(uint256 _availableafter) {
        owner = msg.sender;
        availableafter = _availableafter;
    }

    function setgntcontract(address _gnt) owneronly external {
        gnt = golemnetworktoken(_gnt);
    }

    

    function transfer(address _to, uint256 _value) notlocked owneronly returns (bool success) {
        return gnt.transfer(_to, _value);
    }

    

    function migrate(uint256 _value) owneronly external {
        gnt.migrate(_value);
    }

    

    function() payable {
        throw;
    }
}


contract timelockedgolemfactoryproxyaccount is timelockedgntproxyaccount {

    

    function timelockedgolemfactoryproxyaccount(uint256 _availableafter) timelockedgntproxyaccount(_availableafter) {
    }

    

    modifier gntonly {
        if (msg.sender != address(gnt)) throw;
        _;
    }

    

    function setmigrationmaster(address _migrationmaster) owneronly external {
        gnt.setmigrationmaster(_migrationmaster);
    }
    

    function setmigrationagent(address _agent) owneronly external {
        gnt.setmigrationagent(_agent);
    }

    

    function() gntonly payable {
    }

    

    function withdraw() owneronly {
        if (!owner.send(this.balance)) throw;
    }
}

pragma solidity ^0.4.0;




contract multisigwallet {

    event confirmation(address sender, bytes32 transactionhash);
    event revocation(address sender, bytes32 transactionhash);
    event submission(bytes32 transactionhash);
    event execution(bytes32 transactionhash);
    event deposit(address sender, uint value);
    event owneraddition(address owner);
    event ownerremoval(address owner);
    event requiredupdate(uint required);

    mapping (bytes32 => transaction) public transactions;
    mapping (bytes32 => mapping (address => bool)) public confirmations;
    mapping (address => bool) public isowner;
    address[] owners;
    bytes32[] transactionlist;
    uint public required;

    struct transaction {
        address destination;
        uint value;
        bytes data;
        uint nonce;
        bool executed;
    }

    modifier onlywallet() {
        if (msg.sender != address(this))
            throw;
        _;
    }

    modifier signaturesfromowners(bytes32 transactionhash, uint8[] v, bytes32[] rs) {
        for (uint i=0; i<v.length; i++)
            if (!isowner[ecrecover(transactionhash, v[i], rs[i], rs[v.length + i])])
                throw;
        _;
    }

    modifier ownerdoesnotexist(address owner) {
        if (isowner[owner])
            throw;
        _;
    }

    modifier ownerexists(address owner) {
        if (!isowner[owner])
            throw;
        _;
    }

    modifier confirmed(bytes32 transactionhash, address owner) {
        if (!confirmations[transactionhash][owner])
            throw;
        _;
    }

    modifier notconfirmed(bytes32 transactionhash, address owner) {
        if (confirmations[transactionhash][owner])
            throw;
        _;
    }

    modifier notexecuted(bytes32 transactionhash) {
        if (transactions[transactionhash].executed)
            throw;
        _;
    }

    modifier notnull(address destination) {
        if (destination == 0)
            throw;
        _;
    }

    modifier validrequired(uint _ownercount, uint _required) {
        if (   _required > _ownercount
            || _required == 0
            || _ownercount == 0)
            throw;
        _;
    }

    function addowner(address owner)
        external
        onlywallet
        ownerdoesnotexist(owner)
    {
        isowner[owner] = true;
        owners.push(owner);
        owneraddition(owner);
    }

    function removeowner(address owner)
        external
        onlywallet
        ownerexists(owner)
    {
        isowner[owner] = false;
        for (uint i=0; i<owners.length  1; i++)
            if (owners[i] == owner) {
                owners[i] = owners[owners.length  1];
                break;
            }
        owners.length = 1;
        if (required > owners.length)
            updaterequired(owners.length);
        ownerremoval(owner);
    }

    function updaterequired(uint _required)
        public
        onlywallet
        validrequired(owners.length, _required)
    {
        required = _required;
        requiredupdate(_required);
    }

    function addtransaction(address destination, uint value, bytes data, uint nonce)
        private
        notnull(destination)
        returns (bytes32 transactionhash)
    {
        transactionhash = sha3(destination, value, data, nonce);
        if (transactions[transactionhash].destination == 0) {
            transactions[transactionhash] = transaction({
                destination: destination,
                value: value,
                data: data,
                nonce: nonce,
                executed: false
            });
            transactionlist.push(transactionhash);
            submission(transactionhash);
        }
    }

    function submittransaction(address destination, uint value, bytes data, uint nonce)
        external
        returns (bytes32 transactionhash)
    {
        transactionhash = addtransaction(destination, value, data, nonce);
        confirmtransaction(transactionhash);
    }

    function submittransactionwithsignatures(address destination, uint value, bytes data, uint nonce, uint8[] v, bytes32[] rs)
        external
        returns (bytes32 transactionhash)
    {
        transactionhash = addtransaction(destination, value, data, nonce);
        confirmtransactionwithsignatures(transactionhash, v, rs);
    }

    function addconfirmation(bytes32 transactionhash, address owner)
        private
        notconfirmed(transactionhash, owner)
    {
        confirmations[transactionhash][owner] = true;
        confirmation(owner, transactionhash);
    }

    function confirmtransaction(bytes32 transactionhash)
        public
        ownerexists(msg.sender)
    {
        addconfirmation(transactionhash, msg.sender);
        executetransaction(transactionhash);
    }

    function confirmtransactionwithsignatures(bytes32 transactionhash, uint8[] v, bytes32[] rs)
        public
        signaturesfromowners(transactionhash, v, rs)
    {
        for (uint i=0; i<v.length; i++)
            addconfirmation(transactionhash, ecrecover(transactionhash, v[i], rs[i], rs[i + v.length]));
        executetransaction(transactionhash);
    }

    function executetransaction(bytes32 transactionhash)
        public
        notexecuted(transactionhash)
    {
        if (isconfirmed(transactionhash)) {
            transaction tx = transactions[transactionhash];
            tx.executed = true;
            if (!tx.destination.call.value(tx.value)(tx.data))
                throw;
            execution(transactionhash);
        }
    }

    function revokeconfirmation(bytes32 transactionhash)
        external
        ownerexists(msg.sender)
        confirmed(transactionhash, msg.sender)
        notexecuted(transactionhash)
    {
        confirmations[transactionhash][msg.sender] = false;
        revocation(msg.sender, transactionhash);
    }

    function multisigwallet(address[] _owners, uint _required)
        validrequired(_owners.length, _required)
    {
        for (uint i=0; i<_owners.length; i++)
            isowner[_owners[i]] = true;
        owners = _owners;
        required = _required;
    }

    function()
        payable
    {
        if (msg.value > 0)
            deposit(msg.sender, msg.value);
    }

    function isconfirmed(bytes32 transactionhash)
        public
        constant
        returns (bool)
    {
        uint count = 0;
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionhash][owners[i]])
                count += 1;
            if (count == required)
                return true;
    }

    function confirmationcount(bytes32 transactionhash)
        external
        constant
        returns (uint count)
    {
        for (uint i=0; i<owners.length; i++)
            if (confirmations[transactionhash][owners[i]])
                count += 1;
    }

    function filtertransactions(bool ispending)
        private
        returns (bytes32[] _transactionlist)
    {
        bytes32[] memory _transactionlisttemp = new bytes32[](transactionlist.length);
        uint count = 0;
        for (uint i=0; i<transactionlist.length; i++)
            if (   ispending && !transactions[transactionlist[i]].executed
                || !ispending && transactions[transactionlist[i]].executed)
            {
                _transactionlisttemp[count] = transactionlist[i];
                count += 1;
            }
        _transactionlist = new bytes32[](count);
        for (i=0; i<count; i++)
            if (_transactionlisttemp[i] > 0)
                _transactionlist[i] = _transactionlisttemp[i];
    }

    function getpendingtransactions()
        external
        constant
        returns (bytes32[] _transactionlist)
    {
        return filtertransactions(true);
    }

    function getexecutedtransactions()
        external
        constant
        returns (bytes32[] _transactionlist)
    {
        return filtertransactions(false);
    }
}

pragma solidity ^0.4.4;

import * as source from ;

contract badwallet {
    uint16 extra_work = 0; 
    uint16 public out_i;
    address wallet;

    function badwallet() {
    }

    function get_out_i() returns (uint16 a) {
        return out_i;
    }

    function set_extra_work(uint16 _extra_work) {
        extra_work = _extra_work;
    }

    function get_extra_work() returns (uint16 a) {
        return extra_work;
    }

    function deploy_contract(address _golemfactory, uint256 _fundingstartblock,
                             uint256 _fundingendblock)
        returns (address a) {

        wallet = new source.golemnetworktoken(_golemfactory, _golemfactory,
                                              _fundingstartblock,
                                              _fundingendblock);
        return wallet;
    }

    function finalize(address _crowdfundingcontract) {
        source.golemnetworktoken(_crowdfundingcontract).finalize();
    }

    
    function() payable {
        for (uint16 i = 1; i <= extra_work; i++) {
            out_i = i;
        }
    }
}

pragma solidity ^0.4.4;

import ;



contract gntallocation {
    
    
    
    
    uint256 constant totalallocations = 30000;

    
    mapping (address => uint256) allocations;

    golemnetworktoken gnt;
    uint256 unlockedat;

    uint256 tokenscreated = 0;

    function gntallocation(address _golemfactory) internal {
        gnt = golemnetworktoken(msg.sender);
        unlockedat = now + 6 * 30 days;

        
        allocations[_golemfactory] = 20000; 

        
        allocations[0x9d3f257827b17161a098d380822fa2614ff540c8] = 2500; 
        allocations[0xd7406e50b73972fa4aa533a881af68b623ba3f66] =  730; 
        allocations[0xd15356d05a7990de7ec94304b0fd538e550c09c0] =  730;
        allocations[0x3971d17b62b825b151760e2451f818bfb64489a7] =  730;
        allocations[0x95e337d09f1bc67681b1cab7ed1125ea2bae5ca8] =  730;
        allocations[0x0025c58db686b8cece05cb8c50c1858b63aa396e] =  730;
        allocations[0xb127fc62de6ca30aac9d551591daeddebb2efd7a] =  630; 
        allocations[0x21af2e2c240a71e9fb84e90d71c2b2adde0d0e81] =  630;
        allocations[0x682aa1c3b3e102acb9c97b861d595f9fbff0f1b8] =  630;
        allocations[0x6edd429c77803606cbd6bb501cc701a6cad6be01] =  630;
        allocations[0x5e455624372fe11b39464e93d41d1f6578c3d9f6] =  310; 
        allocations[0xb7c7ead515ca275d53e30b39d8ebedb3f19da244] =  138; 
        allocations[0xd513b1c3fe31f3fe0b1e42aa8f55e903f19f1730] =  135; 
        allocations[0x70cac7f8e404eefce6526823452e428b5ab09b00] =  100; 
        allocations[0xe0d5861e7be0fac6c85ecde6e8bf76b046a96149] =  100;
        allocations[0x17488694d2fee4377ec718836bb9d4910e81d9cf] =  100;
        allocations[0xb481372086dec3ca2fccd3eb2f462c9c893ef3c5] =  100;
        allocations[0xfb6d91e69cd7990651f26a3aa9f8d5a89159fc92] =   70; 
        allocations[0xe2abdae2980a1447f445cb962f9c0bef1b63ee13] =   70;
        allocations[0x729a5c0232712caaf365fdd03c39cb361bd41b1c] =   70;
        allocations[0x12fbd8fef4903f62e30dd79ac7f439f573e02697] =   70;
        allocations[0x657013005e5cfaf76f75d03b465ce085d402469a] =   42; 
        allocations[0xd0af9f75ea618163944585bf56aca98204d0ab66] =   25; 
    }

    
    
    function unlock() external {
        if (now < unlockedat) throw;

        
        if (tokenscreated == 0)
            tokenscreated = gnt.balanceof(this);

        var allocation = allocations[msg.sender];
        allocations[msg.sender] = 0;
        var totransfer = tokenscreated * allocation / totalallocations;

        
        if (!gnt.transfer(msg.sender, totransfer)) throw;
    }
}

