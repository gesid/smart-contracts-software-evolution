pragma solidity ^0.4.18;

import ;

import ;

import ;

import ;

contract storage is proxystorage, ownablestorage, assetregistrystorage, landstorage {
}

pragma solidity ^0.4.18;

contract migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function migrations() public {
    owner = msg.sender;
  }

  function setcompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    migrations upgraded = migrations(new_address);
    upgraded.setcompleted(last_completed_migration);
  }
}

pragma solidity ^0.4.18;

contract proxystorage {

  
  address public currentcontract;
  address public proxyowner;
  address newproxyowner;
}

pragma solidity ^0.4.18;

import ;

contract ownable is storage {

  event ownerupdate(address _prevowner, address _newowner);

  function bytestoaddress (bytes b) pure public returns (address) {
    uint result = 0;
    for (uint i = b.length1; i+1 > 0; i) {
      uint c = uint(b[i]);
      uint to_inc = c * ( 16 ** ((b.length  i1) * 2));
      result += to_inc;
    }
    return address(result);
  }

  modifier onlyowner {
    assert(msg.sender == owner);
    _;
  }

  function transferownership(address _newowner) public onlyowner {
    require(_newowner != owner);
    owner = _newowner;
  }
}

pragma solidity ^0.4.18;

contract iapplication {
  function initialize(bytes data) public;
}

pragma solidity ^0.4.18;

import ;
import ;

contract landproxy is storage, proxy {
}

pragma solidity ^0.4.18;

contract delegateproxy {
  
  function delegatedfwd(address _dst, bytes _calldata) internal {
    require(iscontract(_dst));
    assembly {
      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)
      let size := returndatasize

      let ptr := mload(0x40)
      returndatacopy(ptr, 0, size)

      
      
      switch result case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }

  function iscontract(address _target) constant internal returns (bool) {
    uint256 size;
    assembly { size := extcodesize(_target) }
    return size > 0;
  }
}

pragma solidity ^0.4.18;

contract ownablestorage {

  address public owner;

  function ownablestorage() internal {
    owner = msg.sender;
  }

}

pragma solidity ^0.4.18;

import ;
import ;
import ;
import ;

contract proxy is storage, delegateproxy, ownable {

  event upgrade(address indexed newcontract, bytes initializedwith);
  event ownerupdate(address _prevowner, address _newowner);

  function proxy() public {
    proxyowner = msg.sender;
    owner = msg.sender;
  }

  
  
  modifier onlyproxyowner() {
    require(msg.sender == proxyowner);
    _;
  }

  function acceptownership() public {
    require(msg.sender == newproxyowner);
    ownerupdate(proxyowner, newproxyowner);
    proxyowner = newproxyowner;
    newproxyowner = 0x0;
  }

  function transferownership(address _newowner) public onlyproxyowner {
    require(_newowner != newproxyowner);
    newproxyowner = _newowner;
  }

  
  
  function upgrade(iapplication newcontract, bytes data) public onlyproxyowner {
    currentcontract = newcontract;
    iapplication(this).initialize(data);

    upgrade(newcontract, data);
  }

  
  
  function () payable public {
    require(currentcontract != 0); 
    delegatedfwd(currentcontract, msg.data);
  }
}

pragma solidity ^0.4.18;

contract landstorage {

  mapping (address => uint) latestping;

  uint256 constant clearlow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;
  uint256 constant clearhigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;
  uint256 constant factor = 0x100000000000000000000000000000000;

  mapping (address => bool) authorizeddeploy;

  mapping (uint256 => address) _updateauthorized;
}

pragma solidity ^0.4.18;

import ;

import ;

import ;

import ;

import ;

contract landregistry is storage,
  ownable, fullassetregistry,
  ilandregistry
{

  function initialize(bytes) public {
    _name = ;
    _symbol = ;
    _description = ;
  }

  modifier onlyproxyowner() {
    require(msg.sender == proxyowner);
    _;
  }

  
  
  modifier onlyownerof(uint256 assetid) {
    require(msg.sender == ownerof(assetid));
    _;
  }

  modifier onlyupdateauthorized(uint256 tokenid) {
    require(msg.sender == ownerof(tokenid) || isupdateauthorized(msg.sender, tokenid));
    _;
  }

  function isupdateauthorized(address operator, uint256 assetid) public view returns (bool) {
    return operator == ownerof(assetid) || _updateauthorized[assetid] == operator;
  }

  function authorizedeploy(address beneficiary) public onlyproxyowner {
    authorizeddeploy[beneficiary] = true;
  }
  function forbiddeploy(address beneficiary) public onlyproxyowner {
    authorizeddeploy[beneficiary] = false;
  }

  function assignnewparcel(int x, int y, address beneficiary) public onlyproxyowner {
    _generate(encodetokenid(x, y), beneficiary);
  }

  function assignmultipleparcels(int[] x, int[] y, address beneficiary) public onlyproxyowner {
    for (uint i = 0; i < x.length; i++) {
      _generate(encodetokenid(x[i], y[i]), beneficiary);
    }
  }

  function destroy(uint256 assetid) onlyproxyowner public {
    _destroy(assetid);
  }

  
  
  function ping() public {
    latestping[msg.sender] = now;
  }

  function setlatesttonow(address user) public onlyproxyowner {
    latestping[user] = now;
  }

  function clearland(int[] x, int[] y) public {
    require(x.length == y.length);
    for (uint i = 0; i < x.length; i++) {
      uint landid = encodetokenid(x[i], y[i]);
      address holder = ownerof(landid);
      if (latestping[holder] < now  1 years) {
        _destroy(landid);
      }
    }
  }

  
  
  function encodetokenid(int x, int y) view public returns (uint) {
    return ((uint(x) * factor) & clearlow) | (uint(y) & clearhigh);
  }

  function decodetokenid(uint value) view public returns (int, int) {
    uint x = (value & clearlow) >> 128;
    uint y = (value & clearhigh);
    return (expandnegative128bitcast(x), expandnegative128bitcast(y));
  }

  function expandnegative128bitcast(uint value) pure internal returns (int) {
    if (value & (1<<127) != 0) {
      return int(value | clearlow);
    }
    return int(value);
  }

  function exists(int x, int y) view public returns (bool) {
    return exists(encodetokenid(x, y));
  }

  function ownerofland(int x, int y) view public returns (address) {
    return ownerof(encodetokenid(x, y));
  }

  function owneroflandmany(int[] x, int[] y) view public returns (address[]) {
    require(x.length > 0);
    require(x.length == y.length);

    address[] memory addrs = new address[](x.length);
    for (uint i = 0; i < x.length; i++) {
      addrs[i] = ownerofland(x[i], y[i]);
    }

    return addrs;
  }

  function landof(address owner) public view returns (int[], int[]) {
    int[] memory x = new int[](_assetsof[owner].length);
    int[] memory y = new int[](_assetsof[owner].length);

    int assetx;
    int assety;
    uint length = _assetsof[owner].length;
    for (uint i = 0; i < length; i++) {
      (assetx, assety) = decodetokenid(_assetsof[owner][i]);
      x[i] = assetx;
      y[i] = assety;
    }

    return (x, y);
  }

  function landdata(int x, int y) view public returns (string) {
    return tokenmetadata(encodetokenid(x, y));
  }

  
  
  function transferland(int x, int y, address to) public {
    uint256 tokenid = encodetokenid(x, y);
    safetransferfrom(ownerof(tokenid), to, tokenid);
  }

  function transfermanyland(int[] x, int[] y, address to) public {
    require(x.length > 0);
    require(x.length == y.length);

    for (uint i = 0; i < x.length; i++) {
      uint256 tokenid = encodetokenid(x[i], y[i]);
      safetransferfrom(ownerof(tokenid), to, tokenid);
    }
  }

  function allowupdateoperator(uint256 assetid, address operator) public onlyownerof(assetid) {
    _updateauthorized[assetid] = operator;
  }

  
  
  function updatelanddata(int x, int y, string data) public onlyupdateauthorized (encodetokenid(x, y)) {
    return _update(encodetokenid(x, y), data);
  }

  function updatemanylanddata(int[] x, int[] y, string data) public {
    require(x.length > 0);
    require(x.length == y.length);
    for (uint i = 0; i < x.length; i++) {
      updatelanddata(x[i], y[i], data);
    }
  }
}

pragma solidity ^0.4.18;

interface ilandregistry {

  
  function assignnewparcel(int x, int y, address beneficiary) public;
  function assignmultipleparcels(int[] x, int[] y, address beneficiary) public;

  
  function ping() public;
  function clearland(int[] x, int[] y) public;

  
  function encodetokenid(int x, int y) view public returns (uint256);
  function decodetokenid(uint value) view public returns (int, int);
  function exists(int x, int y) view public returns (bool);
  function ownerofland(int x, int y) view public returns (address);
  function owneroflandmany(int[] x, int[] y) view public returns (address[]);
  function landof(address owner) view public returns (int[], int[]);
  function landdata(int x, int y) view public returns (string);

  
  function transferland(int x, int y, address to) public;
  function transfermanyland(int[] x, int[] y, address to) public;

  
  function updatelanddata(int x, int y, string data) public;
  function updatemanylanddata(int[] x, int[] y, string data) public;
}

pragma solidity ^0.4.18;

import ;

contract returnvestingregistry is ownable {

  mapping (address => address) public returnaddress;

  function record(address from, address to) onlyowner public {
    require(from != 0);

    returnaddress[from] = to;
  }
}

pragma solidity ^0.4.18;

import ;

contract landregistrytest is landregistry {
  function existsproxy(int x, int y) view public returns (bool) {
    return exists(encodetokenid(x, y));
  }

  function isdeploymentauthorized(address beneficiary) view public returns (bool) {
    return authorizeddeploy[beneficiary];
  }
}
pragma solidity 0.4.19;



contract landstorage {

  mapping (address => uint) latestping;

  uint256 constant clearlow = 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000;
  uint256 constant clearhigh = 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;
  uint256 constant factor = 0x100000000000000000000000000000000;

  mapping (address => bool) authorizeddeploy;

}



contract ownablestorage {

  address public owner;

  function ownablestorage() internal {
    owner = msg.sender;
  }

}



contract proxystorage {

  
  address public currentcontract;
  address public proxyowner;
  address newproxyowner;
}



contract assetregistrystorage {

  string internal _name;
  string internal _symbol;
  string internal _description;

  
  uint256 internal _count;

  
  mapping(address => uint256[]) internal _assetsof;

  
  mapping(uint256 => address) internal _holderof;

  
  mapping(uint256 => uint256) internal _indexofasset;

  
  mapping(uint256 => string) internal _assetdata;

  
  mapping(address => mapping(address => bool)) internal _operators;

  
  bool internal _reentrancy;

  
  uint256 internal _reentrancycount;

  
  mapping(uint256 => address) internal _approval;
}



contract storage is proxystorage, ownablestorage, assetregistrystorage, landstorage {
}



contract iapplication {
  function initialize(bytes data) public;
}



contract ownable is storage {

  event ownerupdate(address _prevowner, address _newowner);

  function bytestoaddress (bytes b) pure public returns (address) {
    uint result = 0;
    for (uint i = b.length1; i+1 > 0; i) {
      uint c = uint(b[i]);
      uint to_inc = c * ( 16 ** ((b.length  i1) * 2));
      result += to_inc;
    }
    return address(result);
  }

  modifier onlyowner {
    assert(msg.sender == owner);
    _;
  }

  function initialize(bytes data) public {
    owner = bytestoaddress(data);
  }

  function transferownership(address _newowner) public onlyowner {
    require(_newowner != owner);
    owner = _newowner;
  }
}



interface ilandregistry {

  
  function assignnewparcel(int x, int y, address beneficiary) public;
  function assignmultipleparcels(int[] x, int[] y, address beneficiary) public;

  
  function ping() public;
  function clearland(int[] x, int[] y) public;

  
  function encodetokenid(int x, int y) view public returns (uint256);
  function decodetokenid(uint value) view public returns (int, int);
  function exists(int x, int y) view public returns (bool);
  function ownerofland(int x, int y) view public returns (address);
  function owneroflandmany(int[] x, int[] y) view public returns (address[]);
  function landof(address owner) view public returns (int[], int[]);
  function landdata(int x, int y) view public returns (string);

  
  function transferland(int x, int y, address to) public;
  function transfermanyland(int[] x, int[] y, address to) public;

  
  function updatelanddata(int x, int y, string data) public;
  function updatemanylanddata(int[] x, int[] y, string data) public;
}



interface iassetholder {
  function onassetreceived(
    
    uint256 _assetid,
    address _previousholder,
    address _currentholder,
    bytes   _userdata,
    address _operator,
    bytes   _operatordata
  ) public;
}



interface iassetregistry {

  
  function name() public view returns (string);
  function symbol() public view returns (string);
  function description() public view returns (string);
  function totalsupply() public view returns (uint256);
  function decimals() public view returns (uint256);

  function iserc821() public view returns (bool);

  
  function exists(uint256 assetid) public view returns (bool);

  function holderof(uint256 assetid) public view returns (address);
  function ownerof(uint256 assetid) public view returns (address);

  function safeholderof(uint256 assetid) public view returns (address);
  function safeownerof(uint256 assetid) public view returns (address);

  function assetdata(uint256 assetid) public view returns (string);
  function safeassetdata(uint256 assetid) public view returns (string);

  
  function assetcount(address holder) public view returns (uint256);
  function balanceof(address holder) public view returns (uint256);

  function assetbyindex(address holder, uint256 index) public view returns (uint256);
  function assetsof(address holder) external view returns (uint256[]);

  
  function transfer(address to, uint256 assetid) public;
  function transfer(address to, uint256 assetid, bytes userdata) public;
  function transfer(address to, uint256 assetid, bytes userdata, bytes operatordata) public;

  
  function authorizeoperator(address operator, bool authorized) public;
  function approve(address operator, uint256 assetid) public;

  
  function isoperatorauthorizedby(address operator, address assetholder)
    public view returns (bool);

  function approvedfor(uint256 assetid)
    public view returns (address);

  function isapprovedfor(address operator, uint256 assetid)
    public view returns (bool);

  
  event transfer(
    address indexed from,
    address indexed to,
    uint256 indexed assetid,
    address operator,
    bytes userdata,
    bytes operatordata
  );
  event update(
    uint256 indexed assetid,
    address indexed holder,
    address indexed operator,
    string data
  );
  event authorizeoperator(
    address indexed operator,
    address indexed holder,
    bool authorized
  );
  event approve(
    address indexed owner,
    address indexed operator,
    uint256 indexed assetid
  );
}



contract eip820implementerinterface {
    
    
    
    
    
    function canimplementinterfaceforaddress(address addr, bytes32 interfacehash) view public returns(bool);
}

contract eip820registry {

    mapping (address => mapping(bytes32 => address)) interfaces;
    mapping (address => address) managers;

    modifier canmanage(address addr) {
        require(getmanager(addr) == msg.sender);
        _;
    }

    
    
    function interfacehash(string interfacename) public pure returns(bytes32) {
        return keccak256(interfacename);
    }

    
    function getmanager(address addr) public view returns(address) {
        
        if (managers[addr] == 0) {
            return addr;
        } else {
            return managers[addr];
        }
    }

    
    
    
    
    
    function setmanager(address addr, address newmanager) public canmanage(addr) {
        managers[addr] = newmanager == addr ? 0 : newmanager;
        managerchanged(addr, newmanager);
    }

    
    
    
    
    
    
    function getinterfaceimplementer(address addr, bytes32 ihash) public constant returns (address) {
        return interfaces[addr][ihash];
    }

    
    
    
    
    
    function setinterfaceimplementer(address addr, bytes32 ihash, address implementer) public canmanage(addr)  {
        if ((implementer != 0) && (implementer!=msg.sender)) {
            require(eip820implementerinterface(implementer).canimplementinterfaceforaddress(addr, ihash));
        }
        interfaces[addr][ihash] = implementer;
        interfaceimplementerset(addr, ihash, implementer);
    }

    event interfaceimplementerset(address indexed addr, bytes32 indexed interfacehash, address indexed implementer);
    event managerchanged(address indexed addr, address indexed newmanager);
}



contract eip820implementer {
    eip820registry eip820registry = eip820registry(0x9aa513f1294c8f1b254ba1188991b4cc2efe1d3b);

    function setinterfaceimplementation(string ifacelabel, address impl) internal {
        bytes32 ifacehash = keccak256(ifacelabel);
        eip820registry.setinterfaceimplementer(this, ifacehash, impl);
    }

    function interfaceaddr(address addr, string ifacelabel) internal constant returns(address) {
        bytes32 ifacehash = keccak256(ifacelabel);
        return eip820registry.getinterfaceimplementer(addr, ifacehash);
    }

    function delegatemanagement(address newmanager) internal {
        eip820registry.setmanager(this, newmanager);
    }

}




library safemath {

  
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    
    uint256 c = a / b;
    
    return c;
  }

  
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a  b;
  }

  
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}



contract standardassetregistry is assetregistrystorage, iassetregistry, eip820implementer {
  using safemath for uint256;

  
  
  function name() public view returns (string) {
    return _name;
  }

  function symbol() public view returns (string) {
    return _symbol;
  }

  function description() public view returns (string) {
    return _description;
  }

  function totalsupply() public view returns (uint256) {
    return _count;
  }

  function decimals() public view returns (uint256) {
    return 0;
  }

  function iserc821() public view returns (bool) {
    return true;
  }

  
  
  function exists(uint256 assetid) public view returns (bool) {
    return _holderof[assetid] != 0;
  }

  function holderof(uint256 assetid) public view returns (address) {
    return _holderof[assetid];
  }

  function ownerof(uint256 assetid) public view returns (address) {
    
    
    return holderof(assetid);
  }

  function safeholderof(uint256 assetid) public view returns (address) {
    address holder = _holderof[assetid];
    require(holder != 0);
    return holder;
  }

  function safeownerof(uint256 assetid) public view returns (address) {
    return safeholderof(assetid);
  }

  function assetdata(uint256 assetid) public view returns (string) {
    return _assetdata[assetid];
  }

  function safeassetdata(uint256 assetid) public view returns (string) {
    require(_holderof[assetid] != 0);
    return _assetdata[assetid];
  }

  
  
  function assetcount(address holder) public view returns (uint256) {
    return _assetsof[holder].length;
  }

  function balanceof(address holder) public view returns (uint256) {
    return assetcount(holder);
  }

  function assetbyindex(address holder, uint256 index) public view returns (uint256) {
    require(index < _assetsof[holder].length);
    require(index < (1<<127));
    return _assetsof[holder][index];
  }

  function assetsof(address holder) external view returns (uint256[]) {
    return _assetsof[holder];
  }

  
  
  function isoperatorauthorizedby(address operator, address assetholder)
    public view returns (bool)
  {
    return _operators[assetholder][operator];
  }

  function approvedfor(uint256 assetid) public view returns (address) {
    return _approval[assetid];
  }

  function isapprovedfor(address operator, uint256 assetid)
    public view returns (bool)
  {
    require(operator != 0);
    if (operator == holderof(assetid)) {
      return true;
    }
    return _approval[assetid] == operator;
  }

  
  
  function authorizeoperator(address operator, bool authorized) public {
    if (authorized) {
      require(!isoperatorauthorizedby(operator, msg.sender));
      _addauthorization(operator, msg.sender);
    } else {
      require(isoperatorauthorizedby(operator, msg.sender));
      _clearauthorization(operator, msg.sender);
    }
    authorizeoperator(operator, msg.sender, authorized);
  }

  function approve(address operator, uint256 assetid) public {
    address holder = holderof(assetid);
    require(operator != holder);
    if (approvedfor(assetid) != operator) {
      _approval[assetid] = operator;
      approve(holder, operator, assetid);
    }
  }

  function _addauthorization(address operator, address holder) private {
    _operators[holder][operator] = true;
  }

  function _clearauthorization(address operator, address holder) private {
    _operators[holder][operator] = false;
  }

  
  
  function _addassetto(address to, uint256 assetid) internal {
    _holderof[assetid] = to;

    uint256 length = assetcount(to);

    _assetsof[to].push(assetid);

    _indexofasset[assetid] = length;

    _count = _count.add(1);
  }

  function _addassetto(address to, uint256 assetid, string data) internal {
    _addassetto(to, assetid);

    _assetdata[assetid] = data;
  }

  function _removeassetfrom(address from, uint256 assetid) internal {
    uint256 assetindex = _indexofasset[assetid];
    uint256 lastassetindex = assetcount(from).sub(1);
    uint256 lastassetid = _assetsof[from][lastassetindex];

    _holderof[assetid] = 0;

    
    _assetsof[from][assetindex] = lastassetid;

    
    _assetsof[from][lastassetindex] = 0;
    _assetsof[from].length;

    
    if (_assetsof[from].length == 0) {
      delete _assetsof[from];
    }

    
    _indexofasset[assetid] = 0;
    _indexofasset[lastassetid] = assetindex;

    _count = _count.sub(1);
  }

  function _clearapproval(address holder, uint256 assetid) internal {
    if (holderof(assetid) == holder && _approval[assetid] != 0) {
      _approval[assetid] = 0;
      approve(holder, 0, assetid);
    }
  }

  function _removeassetdata(uint256 assetid) internal {
    _assetdata[assetid] = ;
  }

  
  
  function _generate(uint256 assetid, address beneficiary, string data) internal {
    require(_holderof[assetid] == 0);

    _addassetto(beneficiary, assetid, data);

    transfer(0, beneficiary, assetid, msg.sender, bytes(data), );
  }

  function _destroy(uint256 assetid) internal {
    address holder = _holderof[assetid];
    require(holder != 0);

    _removeassetfrom(holder, assetid);
    _removeassetdata(assetid);

    transfer(holder, 0, assetid, msg.sender, , );
  }

  
  
  modifier onlyholder(uint256 assetid) {
    require(_holderof[assetid] == msg.sender);
    _;
  }

  modifier onlyoperatororholder(uint256 assetid) {
    require(
      _holderof[assetid] == msg.sender
      || isoperatorauthorizedby(msg.sender, _holderof[assetid])
      || isapprovedfor(msg.sender, assetid)
    );
    _;
  }

  modifier isdestinatarydefined(address destinatary) {
    require(destinatary != 0);
    _;
  }

  modifier destinataryisnotholder(uint256 assetid, address to) {
    require(_holderof[assetid] != to);
    _;
  }

  function transfer(address to, uint256 assetid) public {
    return _dotransfer(to, assetid, , 0, );
  }

  function transfer(address to, uint256 assetid, bytes userdata) public {
    return _dotransfer(to, assetid, userdata, 0, );
  }

  function transfer(address to, uint256 assetid, bytes userdata, bytes operatordata) public {
    return _dotransfer(to, assetid, userdata, msg.sender, operatordata);
  }

  function _dotransfer(
    address to, uint256 assetid, bytes userdata, address operator, bytes operatordata
  )
    isdestinatarydefined(to)
    destinataryisnotholder(assetid, to)
    onlyoperatororholder(assetid)
    internal
  {
    return _dosend(to, assetid, userdata, operator, operatordata);
  }


  function _dosend(
    address to, uint256 assetid, bytes userdata, address operator, bytes operatordata
  )
    internal
  {
    address holder = _holderof[assetid];
    _removeassetfrom(holder, assetid);
    _clearapproval(holder, assetid);
    _addassetto(to, assetid);

    if (_iscontract(to)) {
      require(!_reentrancy);
      _reentrancy = true;

      address recipient = interfaceaddr(to, );
      require(recipient != 0);

      iassetholder(recipient).onassetreceived(assetid, holder, to, userdata, operator, operatordata);

      _reentrancy = false;
    }

    transfer(holder, to, assetid, operator, userdata, operatordata);
  }

  
  
  function _update(uint256 assetid, string data) internal {
    require(exists(assetid));
    _assetdata[assetid] = data;
    update(assetid, _holderof[assetid], msg.sender, data);
  }

  
  
  function _iscontract(address addr) internal view returns (bool) {
    uint size;
    assembly { size := extcodesize(addr) }
    return size > 0;
  }
}



contract landregistry is storage,
  ownable, standardassetregistry,
  ilandregistry
{

  function initialize(bytes data) public {
    _name = ;
    _symbol = ;
    _description = ;
    proxyowner = 0x55ed2910cc807e4596024266ebdf7b1753405a11;
  }

  modifier onlyprivateowner {
    require(msg.sender == proxyowner);
    _
  }

  modifier onlyauthorizeddeploy {
    require(authorizeddeploy[msg.sender]);
    _
  }

  function authorizedeploy(address beneficiary) public onlyprivateowner {
    authorizeddeploy[beneficiary] = true;
  }
  function forbiddeploy(address beneficiary) public onlyprivateowner {
    authorizeddeploy[beneficiary] = false;
  }

  function assignnewparcel(int x, int y, address beneficiary) public onlyauthorizeddeploy {
    _generate(encodetokenid(x, y), beneficiary, );
  }

  function assignmultipleparcels(int[] x, int[] y, address beneficiary) public onlyauthorizeddeploy {
    for (uint i = 0; i < x.length; i++) {
      _generate(encodetokenid(x[i], y[i]), beneficiary, );
    }
  }

  function destroy(uint256 assetid) onlyprivateowner public {
    _destroy(assetid);
  }

  
  
  function ping() public {
    latestping[msg.sender] = now;
  }

  function setlatesttonow(address user) onlyprivateowner public {
    latestping[user] = now;
  }

  function clearland(int[] x, int[] y) public {
    require(x.length == y.length);
    for (uint i = 0; i < x.length; i++) {
      uint landid = encodetokenid(x[i], y[i]);
      address holder = holderof(landid);
      if (latestping[holder] < now  1 years) {
        _destroy(landid);
      }
    }
  }

  
  
  function encodetokenid(int x, int y) view public returns (uint) {
    return ((uint(x) * factor) & clearlow) | (uint(y) & clearhigh);
  }

  function decodetokenid(uint value) view public returns (int, int) {
    uint x = (value & clearlow) >> 128;
    uint y = (value & clearhigh);
    return (expandnegative128bitcast(x), expandnegative128bitcast(y));
  }

  function expandnegative128bitcast(uint value) pure internal returns (int) {
    if (value & (1<<127) != 0) {
      return int(value | clearlow);
    }
    return int(value);
  }

  function exists(int x, int y) view public returns (bool) {
    return exists(encodetokenid(x, y));
  }

  function ownerofland(int x, int y) view public returns (address) {
    return holderof(encodetokenid(x, y));
  }

  function owneroflandmany(int[] x, int[] y) view public returns (address[]) {
    require(x.length > 0);
    require(x.length == y.length);

    address[] memory addrs = new address[](x.length);
    for (uint i = 0; i < x.length; i++) {
      addrs[i] = ownerofland(x[i], y[i]);
    }

    return addrs;
  }

  function landof(address owner) public view returns (int[], int[]) {
    int[] memory x = new int[](_assetsof[owner].length);
    int[] memory y = new int[](_assetsof[owner].length);

    int assetx;
    int assety;
    uint length = _assetsof[owner].length;
    for (uint i = 0; i < length; i++) {
      (assetx, assety) = decodetokenid(_assetsof[owner][i]);
      x[i] = assetx;
      y[i] = assety;
    }

    return (x, y);
  }

  function landdata(int x, int y) view public returns (string) {
    return assetdata(encodetokenid(x, y));
  }

  
  
  function transferland(int x, int y, address to) public {
    transfer(to, encodetokenid(x, y));
  }

  function transfermanyland(int[] x, int[] y, address to) public {
    require(x.length == y.length);
    for (uint i = 0; i < x.length; i++) {
      transfer(to, encodetokenid(x[i], y[i]));
    }
  }

  
  
  function updatelanddata(int x, int y, string data) public onlyoperatororholder(encodetokenid(x, y)) {
    return _update(encodetokenid(x, y), data);
  }

  function updatemanylanddata(int[] x, int[] y, string data) public {
    require(x.length == y.length);
    for (uint i = 0; i < x.length; i++) {
      updatelanddata(x[i], y[i], data);
    }
  }
}


