pragma solidity 0.4.25;

import ;



contract exchangestate is state {
    struct exchangeentry {
        bytes32 src;
        uint amount;
        bytes32 dest;
        uint amountreceived;
        uint exchangefeerate;
        uint timestamp;
        uint roundidforsrc;
        uint roundidfordest;
    }

    mapping(address => mapping(bytes32 => exchangeentry[])) public exchanges;

    uint public maxentriesinqueue = 12;

    constructor(address _owner, address _associatedcontract) public state(_owner, _associatedcontract) {}

    

    function setmaxentriesinqueue(uint _maxentriesinqueue) external onlyowner {
        maxentriesinqueue = _maxentriesinqueue;
    }

    

    function appendexchangeentry(
        address account,
        bytes32 src,
        uint amount,
        bytes32 dest,
        uint amountreceived,
        uint exchangefeerate,
        uint timestamp,
        uint roundidforsrc,
        uint roundidfordest
    ) external onlyassociatedcontract {
        require(exchanges[account][dest].length < maxentriesinqueue, );

        exchanges[account][dest].push(
            exchangeentry({
                src: src,
                amount: amount,
                dest: dest,
                amountreceived: amountreceived,
                exchangefeerate: exchangefeerate,
                timestamp: timestamp,
                roundidforsrc: roundidforsrc,
                roundidfordest: roundidfordest
            })
        );
    }

    function removeentries(address account, bytes32 currencykey) external onlyassociatedcontract {
        delete exchanges[account][currencykey];
    }

    

    function getlengthofentries(address account, bytes32 currencykey) external view returns (uint) {
        return exchanges[account][currencykey].length;
    }

    function getentryat(
        address account,
        bytes32 currencykey,
        uint index
    )
        external
        view
        returns (
            bytes32 src,
            uint amount,
            bytes32 dest,
            uint amountreceived,
            uint exchangefeerate,
            uint timestamp,
            uint roundidforsrc,
            uint roundidfordest
        )
    {
        exchangeentry storage entry = exchanges[account][currencykey][index];
        return (
            entry.src,
            entry.amount,
            entry.dest,
            entry.amountreceived,
            entry.exchangefeerate,
            entry.timestamp,
            entry.roundidforsrc,
            entry.roundidfordest
        );
    }

    function getmaxtimestamp(address account, bytes32 currencykey) external view returns (uint) {
        exchangeentry[] storage userentries = exchanges[account][currencykey];
        uint timestamp = 0;
        for (uint i = 0; i < userentries.length; i++) {
            if (userentries[i].timestamp > timestamp) {
                timestamp = userentries[i].timestamp;
            }
        }
        return timestamp;
    }
}

pragma solidity 0.4.25;
import ;




contract eternalstorage is state {
    constructor(address _owner, address _associatedcontract) public state(_owner, _associatedcontract) {}

    
    mapping(bytes32 => uint) uintstorage;
    mapping(bytes32 => string) stringstorage;
    mapping(bytes32 => address) addressstorage;
    mapping(bytes32 => bytes) bytesstorage;
    mapping(bytes32 => bytes32) bytes32storage;
    mapping(bytes32 => bool) booleanstorage;
    mapping(bytes32 => int) intstorage;

    
    function getuintvalue(bytes32 record) external view returns (uint) {
        return uintstorage[record];
    }

    function setuintvalue(bytes32 record, uint value) external onlyassociatedcontract {
        uintstorage[record] = value;
    }

    function deleteuintvalue(bytes32 record) external onlyassociatedcontract {
        delete uintstorage[record];
    }

    
    function getstringvalue(bytes32 record) external view returns (string memory) {
        return stringstorage[record];
    }

    function setstringvalue(bytes32 record, string value) external onlyassociatedcontract {
        stringstorage[record] = value;
    }

    function deletestringvalue(bytes32 record) external onlyassociatedcontract {
        delete stringstorage[record];
    }

    
    function getaddressvalue(bytes32 record) external view returns (address) {
        return addressstorage[record];
    }

    function setaddressvalue(bytes32 record, address value) external onlyassociatedcontract {
        addressstorage[record] = value;
    }

    function deleteaddressvalue(bytes32 record) external onlyassociatedcontract {
        delete addressstorage[record];
    }

    
    function getbytesvalue(bytes32 record) external view returns (bytes memory) {
        return bytesstorage[record];
    }

    function setbytesvalue(bytes32 record, bytes value) external onlyassociatedcontract {
        bytesstorage[record] = value;
    }

    function deletebytesvalue(bytes32 record) external onlyassociatedcontract {
        delete bytesstorage[record];
    }

    
    function getbytes32value(bytes32 record) external view returns (bytes32) {
        return bytes32storage[record];
    }

    function setbytes32value(bytes32 record, bytes32 value) external onlyassociatedcontract {
        bytes32storage[record] = value;
    }

    function deletebytes32value(bytes32 record) external onlyassociatedcontract {
        delete bytes32storage[record];
    }

    
    function getbooleanvalue(bytes32 record) external view returns (bool) {
        return booleanstorage[record];
    }

    function setbooleanvalue(bytes32 record, bool value) external onlyassociatedcontract {
        booleanstorage[record] = value;
    }

    function deletebooleanvalue(bytes32 record) external onlyassociatedcontract {
        delete booleanstorage[record];
    }

    
    function getintvalue(bytes32 record) external view returns (int) {
        return intstorage[record];
    }

    function setintvalue(bytes32 record, int value) external onlyassociatedcontract {
        intstorage[record] = value;
    }

    function deleteintvalue(bytes32 record) external onlyassociatedcontract {
        delete intstorage[record];
    }
}

pragma solidity 0.4.25;

import ;
import ;



contract havven is ierc20 {

}



contract limitedsetup {
    uint constructiontime;
    uint setupduration;

    function limitedsetup(uint _setupduration) public {
        constructiontime = now;
        setupduration = _setupduration;
    }

    modifier setupfunction {
        require(now < constructiontime + setupduration);
        _;
    }
}




contract earlysafedecimalmath {
    
    uint8 public constant decimals = 18;

    
    uint public constant unit = 10**uint(decimals);

    
    function addissafe(uint x, uint y) internal pure returns (bool) {
        return x + y >= y;
    }

    
    function safeadd(uint x, uint y) internal pure returns (uint) {
        require(x + y >= y);
        return x + y;
    }

    
    function subissafe(uint x, uint y) internal pure returns (bool) {
        return y <= x;
    }

    
    function safesub(uint x, uint y) internal pure returns (uint) {
        require(y <= x);
        return x  y;
    }

    
    function mulissafe(uint x, uint y) internal pure returns (bool) {
        if (x == 0) {
            return true;
        }
        return (x * y) / x == y;
    }

    
    function safemul(uint x, uint y) internal pure returns (uint) {
        if (x == 0) {
            return 0;
        }
        uint p = x * y;
        require(p / x == y);
        return p;
    }

    
    function safemul_dec(uint x, uint y) internal pure returns (uint) {
        
        
        return safemul(x, y) / unit;
    }

    
    function divissafe(uint x, uint y) internal pure returns (bool) {
        return y != 0;
    }

    
    function safediv(uint x, uint y) internal pure returns (uint) {
        
        
        
        require(y != 0);
        return x / y;
    }

    
    function safediv_dec(uint x, uint y) internal pure returns (uint) {
        
        return safediv(safemul(x, unit), y);
    }

    
    function inttodec(uint i) internal pure returns (uint) {
        return safemul(i, unit);
    }
}


contract havvenescrow is owned, limitedsetup(8 weeks), earlysafedecimalmath {
    
    havven public havven;

    
    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalvestedbalance;

    

    function havvenescrow(address _owner, havven _havven) public owned(_owner) {
        havven = _havven;
    }

    

    function sethavven(havven _havven) external onlyowner {
        havven = _havven;
        emit havvenupdated(_havven);
    }

    

    
    function balanceof(address account) public view returns (uint) {
        return totalvestedaccountbalance[account];
    }

    
    function numvestingentries(address account) public view returns (uint) {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index) public view returns (uint[2]) {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index) public view returns (uint) {
        return vestingschedules[account][index][0];
    }

    
    function getvestingquantity(address account, uint index) public view returns (uint) {
        return vestingschedules[account][index][1];
    }

    
    function getnextvestingindex(address account) public view returns (uint) {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account) external view returns (uint[2]) {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account) external view returns (uint) {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return 0;
        }
        return getvestingtime(account, index);
    }

    
    function getnextvestingquantity(address account) external view returns (uint) {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return 0;
        }
        return getvestingquantity(account, index);
    }

    

    
    function withdrawhavvens(uint quantity) external onlyowner setupfunction {
        havven.transfer(havven, quantity);
    }

    
    function purgeaccount(address account) external onlyowner setupfunction {
        delete vestingschedules[account];
        totalvestedbalance = safesub(totalvestedbalance, totalvestedaccountbalance[account]);
        delete totalvestedaccountbalance[account];
    }

    
    function appendvestingentry(
        address account,
        uint time,
        uint quantity
    ) public onlyowner setupfunction {
        
        require(now < time);
        require(quantity != 0);
        totalvestedbalance = safeadd(totalvestedbalance, quantity);
        require(totalvestedbalance <= havven.balanceof(this));

        if (vestingschedules[account].length == 0) {
            totalvestedaccountbalance[account] = quantity;
        } else {
            
            
            require(getvestingtime(account, numvestingentries(account)  1) < time);
            totalvestedaccountbalance[account] = safeadd(totalvestedaccountbalance[account], quantity);
        }

        vestingschedules[account].push([time, quantity]);
    }

    
    function addvestingschedule(
        address account,
        uint[] times,
        uint[] quantities
    ) external onlyowner setupfunction {
        for (uint i = 0; i < times.length; i++) {
            appendvestingentry(account, times[i], quantities[i]);
        }
    }

    
    function vest() external {
        uint total;
        for (uint i = 0; i < numvestingentries(msg.sender); i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = safeadd(total, qty);
            totalvestedaccountbalance[msg.sender] = safesub(totalvestedaccountbalance[msg.sender], qty);
        }

        if (total != 0) {
            totalvestedbalance = safesub(totalvestedbalance, total);
            havven.transfer(msg.sender, total);
            emit vested(msg.sender, msg.sender, now, total);
        }
    }

    

    event havvenupdated(address newhavven);

    event vested(address beneficiary, address indexed beneficiaryindex, uint time, uint value);
}

pragma solidity 0.4.25;

import ;
import ;
import ;


contract isynthetix is ierc20 {}


contract ifeepool {}



contract rewardescrow is owned {
    using safemath for uint;

    
    isynthetix public synthetix;

    ifeepool public feepool;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalescrowedaccountbalance;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalescrowedbalance;

    uint constant time_index = 0;
    uint constant quantity_index = 1;

    
    uint public constant max_vesting_entries = 52 * 5;

    

    constructor(
        address _owner,
        isynthetix _synthetix,
        ifeepool _feepool
    ) public owned(_owner) {
        synthetix = _synthetix;
        feepool = _feepool;
    }

    

    
    function setsynthetix(isynthetix _synthetix) external onlyowner {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }

    
    function setfeepool(ifeepool _feepool) external onlyowner {
        feepool = _feepool;
        emit feepoolupdated(_feepool);
    }

    

    
    function balanceof(address account) public view returns (uint) {
        return totalescrowedaccountbalance[account];
    }

    
    function numvestingentries(address account) public view returns (uint) {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index) public view returns (uint[2]) {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index) public view returns (uint) {
        return getvestingscheduleentry(account, index)[time_index];
    }

    
    function getvestingquantity(address account, uint index) public view returns (uint) {
        return getvestingscheduleentry(account, index)[quantity_index];
    }

    
    function getnextvestingindex(address account) public view returns (uint) {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account) public view returns (uint[2]) {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account) external view returns (uint) {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account) external view returns (uint) {
        return getnextvestingentry(account)[quantity_index];
    }

    
    function checkaccountschedule(address account) public view returns (uint[520]) {
        uint[520] memory _result;
        uint schedules = numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = getvestingscheduleentry(account, i);
            _result[i * 2] = pair[0];
            _result[i * 2 + 1] = pair[1];
        }
        return _result;
    }

    

    
    function appendvestingentry(address account, uint quantity) public onlyfeepool {
        
        require(quantity != 0, );

        
        totalescrowedbalance = totalescrowedbalance.add(quantity);
        require(
            totalescrowedbalance <= synthetix.balanceof(this),
            
        );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        
        uint time = now + 52 weeks;

        if (schedulelength == 0) {
            totalescrowedaccountbalance[account] = quantity;
        } else {
            
            require(
                getvestingtime(account, schedulelength  1) < time,
                
            );
            totalescrowedaccountbalance[account] = totalescrowedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);

        emit vestingentrycreated(account, now, quantity);
    }

    
    function vest() external {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalescrowedbalance = totalescrowedbalance.sub(total);
            totalescrowedaccountbalance[msg.sender] = totalescrowedaccountbalance[msg.sender].sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].add(total);
            synthetix.transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }

    

    modifier onlyfeepool() {
        bool isfeepool = msg.sender == address(feepool);

        require(isfeepool, );
        _;
    }

    

    event synthetixupdated(address newsynthetix);

    event feepoolupdated(address newfeepool);

    event vested(address indexed beneficiary, uint time, uint value);

    event vestingentrycreated(address indexed beneficiary, uint time, uint value);
}

pragma solidity 0.4.25;

import ;
import ;
import ;
import ;






contract synthetix {
    function effectivevalue(
        bytes4 src,
        uint amont,
        bytes4 dest
    ) external view returns (uint);

    function debtbalanceof(address account, bytes4 currencykey) external view returns (uint);
}


contract synthetixstate is state, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    
    mapping(address => issuancedata) public issuancedata;

    
    uint public totalissuercount;

    
    uint[] public debtledger;

    
    uint public importedxdramount;

    
    
    uint public issuanceratio = safedecimalmath.unit() / 5;
    
    uint constant max_issuance_ratio = safedecimalmath.unit();

    
    
    mapping(address => bytes4) public preferredcurrency;

    
    constructor(address _owner, address _associatedcontract)
        public
        state(_owner, _associatedcontract)
        limitedsetup(1 weeks)
    {}

    

    
    function setcurrentissuancedata(address account, uint initialdebtownership) external onlyassociatedcontract {
        issuancedata[account].initialdebtownership = initialdebtownership;
        issuancedata[account].debtentryindex = debtledger.length;
    }

    
    function clearissuancedata(address account) external onlyassociatedcontract {
        delete issuancedata[account];
    }

    
    function incrementtotalissuercount() external onlyassociatedcontract {
        totalissuercount = totalissuercount.add(1);
    }

    
    function decrementtotalissuercount() external onlyassociatedcontract {
        totalissuercount = totalissuercount.sub(1);
    }

    
    function appenddebtledgervalue(uint value) external onlyassociatedcontract {
        debtledger.push(value);
    }

    
    function setpreferredcurrency(address account, bytes4 currencykey) external onlyassociatedcontract {
        preferredcurrency[account] = currencykey;
    }

    
    function setissuanceratio(uint _issuanceratio) external onlyowner {
        require(_issuanceratio <= max_issuance_ratio, );
        issuanceratio = _issuanceratio;
        emit issuanceratioupdated(_issuanceratio);
    }

    
    function importissuerdata(address[] accounts, uint[] susdamounts) external onlyowner onlyduringsetup {
        require(accounts.length == susdamounts.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            _addtodebtregister(accounts[i], susdamounts[i]);
        }
    }

    
    function _addtodebtregister(address account, uint amount) internal {
        
        
        synthetix synthetix = synthetix(associatedcontract);

        
        uint xdrvalue = synthetix.effectivevalue(, amount, );

        
        uint totaldebtissued = importedxdramount;

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        importedxdramount = newtotaldebtissued;

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        uint existingdebt = synthetix.debtbalanceof(account, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (issuancedata[account].initialdebtownership == 0) {
            totalissuercount = totalissuercount.add(1);
        }

        
        issuancedata[account].initialdebtownership = debtpercentage;
        issuancedata[account].debtentryindex = debtledger.length;

        
        
        if (debtledger.length > 0) {
            debtledger.push(debtledger[debtledger.length  1].multiplydecimalroundprecise(delta));
        } else {
            debtledger.push(safedecimalmath.preciseunit());
        }
    }

    

    
    function debtledgerlength() external view returns (uint) {
        return debtledger.length;
    }

    
    function lastdebtledgerentry() external view returns (uint) {
        return debtledger[debtledger.length  1];
    }

    
    function hasissued(address account) external view returns (bool) {
        return issuancedata[account].initialdebtownership > 0;
    }

    event issuanceratioupdated(uint newratio);
}

pragma solidity 0.4.25;

import ;
import ;
import ;


contract ifeepool {}



contract feepoolstate is selfdestructible, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    

    uint8 public constant fee_period_length = 6;

    address public feepool;

    
    struct issuancedata {
        uint debtpercentage;
        uint debtentryindex;
    }

    
    mapping(address => issuancedata[fee_period_length]) public accountissuanceledger;

    
    constructor(address _owner, ifeepool _feepool) public selfdestructible(_owner) limitedsetup(6 weeks) {
        feepool = _feepool;
    }

    

    
    function setfeepool(ifeepool _feepool) external onlyowner {
        feepool = _feepool;
    }

    

    
    function getaccountsdebtentry(address account, uint index)
        public
        view
        returns (uint debtpercentage, uint debtentryindex)
    {
        require(index < fee_period_length, );

        debtpercentage = accountissuanceledger[account][index].debtpercentage;
        debtentryindex = accountissuanceledger[account][index].debtentryindex;
    }

    
    function applicableissuancedata(address account, uint closingdebtindex) external view returns (uint, uint) {
        issuancedata[fee_period_length] memory issuancedata = accountissuanceledger[account];

        
        
        for (uint i = 0; i < fee_period_length; i++) {
            if (closingdebtindex >= issuancedata[i].debtentryindex) {
                return (issuancedata[i].debtpercentage, issuancedata[i].debtentryindex);
            }
        }
    }

    

    
    function appendaccountissuancerecord(
        address account,
        uint debtratio,
        uint debtentryindex,
        uint currentperiodstartdebtindex
    ) external onlyfeepool {
        
        if (accountissuanceledger[account][0].debtentryindex < currentperiodstartdebtindex) {
            
            issuancedataindexorder(account);
        }

        
        accountissuanceledger[account][0].debtpercentage = debtratio;
        accountissuanceledger[account][0].debtentryindex = debtentryindex;
    }

    
    function issuancedataindexorder(address account) private {
        for (uint i = fee_period_length  2; i < fee_period_length; i) {
            uint next = i + 1;
            accountissuanceledger[account][next].debtpercentage = accountissuanceledger[account][i].debtpercentage;
            accountissuanceledger[account][next].debtentryindex = accountissuanceledger[account][i].debtentryindex;
        }
    }

    
    function importissuerdata(
        address[] accounts,
        uint[] ratios,
        uint periodtoinsert,
        uint feeperiodcloseindex
    ) external onlyowner onlyduringsetup {
        require(accounts.length == ratios.length, );

        for (uint i = 0; i < accounts.length; i++) {
            accountissuanceledger[accounts[i]][periodtoinsert].debtpercentage = ratios[i];
            accountissuanceledger[accounts[i]][periodtoinsert].debtentryindex = feeperiodcloseindex;
            emit issuancedebtratioentry(accounts[i], ratios[i], feeperiodcloseindex);
        }
    }

    

    modifier onlyfeepool {
        require(msg.sender == address(feepool), );
        _;
    }

    
    event issuancedebtratioentry(address indexed account, uint debtratio, uint feeperiodcloseindex);
}

pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;

contract isynthetix {
    uint public totalsupply;
}

contract supplyschedule is owned {
    using safemath for uint;
    using safedecimalmath for uint;
    using math for uint;

    
    uint public lastmintevent;

    
    uint public weekcounter;

    
    uint public minterreward = 200 * safedecimalmath.unit();

    
    
    uint public constant initial_weekly_supply = 1442307692307692307692307;

    
    address public synthetixproxy;

    
    uint public constant max_minter_reward = 200 * safedecimalmath.unit();

    
    uint public constant mint_period_duration = 1 weeks;

    uint public constant inflation_start_date = 1551830400; 
    uint public constant mint_buffer = 1 days;
    uint8 public constant supply_decay_start = 40; 
    uint8 public constant supply_decay_end = 234; 

    
    uint public constant decay_rate = 12500000000000000; 

    
    uint public constant terminal_supply_rate_annual = 25000000000000000; 

    constructor(
        address _owner,
        uint _lastmintevent,
        uint _currentweek)
        owned(_owner)
        public
    {
        lastmintevent = _lastmintevent;
        weekcounter = _currentweek;
    }

    

    
    function mintablesupply()
        external
        view
        returns (uint)
    {
        uint totalamount;

        if (!ismintable()) {
            return totalamount;
        }

        uint remainingweekstomint = weekssincelastissuance();

        uint currentweek = weekcounter;

        
        
        while (remainingweekstomint > 0) {
            currentweek++;

            
            if (currentweek < supply_decay_start) {
                totalamount = totalamount.add(initial_weekly_supply);
                remainingweekstomint;
            }
            
            else if (currentweek <= supply_decay_end) {

                
                uint decaycount = currentweek.sub(supply_decay_start 1);

                totalamount = totalamount.add(tokendecaysupplyforweek(decaycount));
                remainingweekstomint;
            }
            
            
            else {
                uint totalsupply = isynthetix(synthetixproxy).totalsupply();
                uint currenttotalsupply = totalsupply.add(totalamount);

                totalamount = totalamount.add(terminalinflationsupply(currenttotalsupply, remainingweekstomint));
                remainingweekstomint = 0;
            }
        }

        return totalamount;
    }

    
    function tokendecaysupplyforweek(uint counter)
        public
        pure
        returns (uint)
    {
        
        
        uint effectivedecay = (safedecimalmath.unit().sub(decay_rate)).powdecimal(counter);
        uint supplyforweek = initial_weekly_supply.multiplydecimal(effectivedecay);

        return supplyforweek;
    }

    
    function terminalinflationsupply(uint totalsupply, uint numofweeks)
        public
        pure
        returns (uint)
    {
        
        uint effectivecompoundrate = safedecimalmath.unit().add(terminal_supply_rate_annual.div(52)).powdecimal(numofweeks);

        
        return totalsupply.multiplydecimal(effectivecompoundrate.sub(safedecimalmath.unit()));
    }

    
    function weekssincelastissuance()
        public
        view
        returns (uint)
    {
        
        
        uint timediff = lastmintevent > 0 ? now.sub(lastmintevent) : now.sub(inflation_start_date);
        return timediff.div(mint_period_duration);
    }

    
    function ismintable()
        public
        view
        returns (bool)
    {
        if (now  lastmintevent > mint_period_duration)
        {
            return true;
        }
        return false;
    }

    

    
    function recordmintevent(uint supplyminted)
        external
        onlysynthetix
        returns (bool)
    {
        uint numberofweeksissued = weekssincelastissuance();

        
        weekcounter = weekcounter.add(numberofweeksissued);

        
        
        lastmintevent = inflation_start_date.add(weekcounter.mul(mint_period_duration)).add(mint_buffer);

        emit supplyminted(supplyminted, numberofweeksissued, lastmintevent, now);
        return true;
    }

    
    function setminterreward(uint amount)
        external
        onlyowner
    {
        require(amount <= max_minter_reward, );
        minterreward = amount;
        emit minterrewardupdated(minterreward);
    }

    

    
    function setsynthetixproxy(isynthetix _synthetixproxy)
        external
        onlyowner
    {
        require(_synthetixproxy != address(0), );
        synthetixproxy = _synthetixproxy;
        emit synthetixproxyupdated(synthetixproxy);
    }

    

    
    modifier onlysynthetix() {
        require(msg.sender == address(proxy(synthetixproxy).target()), );
        _;
    }

    
    
    event supplyminted(uint supplyminted, uint numberofweeksissued, uint lastmintevent, uint timestamp);

    
    event minterrewardupdated(uint newrewardamount);

    
    event synthetixproxyupdated(address newaddress);
}

pragma solidity 0.4.25;

import ;



library safedecimalmath {
    using safemath for uint;

    
    uint8 public constant decimals = 18;
    uint8 public constant highprecisiondecimals = 27;

    
    uint public constant unit = 10**uint(decimals);

    
    uint public constant precise_unit = 10**uint(highprecisiondecimals);
    uint private constant unit_to_high_precision_conversion_factor = 10**uint(highprecisiondecimals  decimals);

    
    function unit() external pure returns (uint) {
        return unit;
    }

    
    function preciseunit() external pure returns (uint) {
        return precise_unit;
    }

    
    function multiplydecimal(uint x, uint y) internal pure returns (uint) {
        
        return x.mul(y) / unit;
    }

    
    function _multiplydecimalround(
        uint x,
        uint y,
        uint precisionunit
    ) private pure returns (uint) {
        
        uint quotienttimesten = x.mul(y) / (precisionunit / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

    
    function multiplydecimalroundprecise(uint x, uint y) internal pure returns (uint) {
        return _multiplydecimalround(x, y, precise_unit);
    }

    
    function multiplydecimalround(uint x, uint y) internal pure returns (uint) {
        return _multiplydecimalround(x, y, unit);
    }

    
    function dividedecimal(uint x, uint y) internal pure returns (uint) {
        
        return x.mul(unit).div(y);
    }

    
    function _dividedecimalround(
        uint x,
        uint y,
        uint precisionunit
    ) private pure returns (uint) {
        uint resulttimesten = x.mul(precisionunit * 10).div(y);

        if (resulttimesten % 10 >= 5) {
            resulttimesten += 10;
        }

        return resulttimesten / 10;
    }

    
    function dividedecimalround(uint x, uint y) internal pure returns (uint) {
        return _dividedecimalround(x, y, unit);
    }

    
    function dividedecimalroundprecise(uint x, uint y) internal pure returns (uint) {
        return _dividedecimalround(x, y, precise_unit);
    }

    
    function decimaltoprecisedecimal(uint i) internal pure returns (uint) {
        return i.mul(unit_to_high_precision_conversion_factor);
    }

    
    function precisedecimaltodecimal(uint i) internal pure returns (uint) {
        uint quotienttimesten = i / (unit_to_high_precision_conversion_factor / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }
}

pragma solidity 0.4.25;

import ;



contract proxyable is owned {
    
    proxy public proxy;
    proxy public integrationproxy;

    
    address messagesender;

    constructor(address _proxy, address _owner) public owned(_owner) {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setproxy(address _proxy) external onlyowner {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setintegrationproxy(address _integrationproxy) external onlyowner {
        integrationproxy = proxy(_integrationproxy);
    }

    function setmessagesender(address sender) external onlyproxy {
        messagesender = sender;
    }

    modifier onlyproxy {
        require(proxy(msg.sender) == proxy || proxy(msg.sender) == integrationproxy, );
        _;
    }

    modifier optionalproxy {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy) {
            messagesender = msg.sender;
        }
        _;
    }

    modifier optionalproxy_onlyowner {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy) {
            messagesender = msg.sender;
        }
        require(messagesender == owner, );
        _;
    }

    event proxyupdated(address proxyaddress);
}


contract proxy is owned {
    proxyable public target;
    bool public usedelegatecall;

    constructor(address _owner) public owned(_owner) {}

    function settarget(proxyable _target) external onlyowner {
        target = _target;
        emit targetupdated(_target);
    }

    function setusedelegatecall(bool value) external onlyowner {
        usedelegatecall = value;
    }

    function _emit(
        bytes calldata,
        uint numtopics,
        bytes32 topic1,
        bytes32 topic2,
        bytes32 topic3,
        bytes32 topic4
    ) external onlytarget {
        uint size = calldata.length;
        bytes memory _calldata = calldata;

        assembly {
            
            switch numtopics
                case 0 {
                    log0(add(_calldata, 32), size)
                }
                case 1 {
                    log1(add(_calldata, 32), size, topic1)
                }
                case 2 {
                    log2(add(_calldata, 32), size, topic1, topic2)
                }
                case 3 {
                    log3(add(_calldata, 32), size, topic1, topic2, topic3)
                }
                case 4 {
                    log4(add(_calldata, 32), size, topic1, topic2, topic3, topic4)
                }
        }
    }

    function() external payable {
        if (usedelegatecall) {
            assembly {
                
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                
                if iszero(result) {
                    revert(free_ptr, returndatasize)
                }
                return(free_ptr, returndatasize)
            }
        } else {
            
            target.setmessagesender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) {
                    revert(free_ptr, returndatasize)
                }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlytarget {
        require(proxyable(msg.sender) == target, );
        _;
    }

    event targetupdated(proxyable newtarget);
}

pragma solidity 0.4.25;

import ;



contract issuanceeternalstorage is eternalstorage {
    
    constructor(address _owner, address _issuer) public eternalstorage(_owner, _issuer) {}
}

pragma solidity 0.4.25;

import ;
import ;
import ;


contract proxyerc20 is proxy, ierc20 {
    constructor(address _owner) public proxy(_owner) {}

    

    function name() public view returns (string) {
        
        return ierc20(target).name();
    }

    function symbol() public view returns (string) {
        
        return ierc20(target).symbol();
    }

    function decimals() public view returns (uint8) {
        
        return ierc20(target).decimals();
    }

    

    
    function totalsupply() public view returns (uint256) {
        
        return ierc20(target).totalsupply();
    }

    
    function balanceof(address owner) public view returns (uint256) {
        
        return ierc20(target).balanceof(owner);
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        
        return ierc20(target).allowance(owner, spender);
    }

    
    function transfer(address to, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).transfer(to, value);

        
        return true;
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).approve(spender, value);

        
        return true;
    }

    
    function transferfrom(
        address from,
        address to,
        uint256 value
    ) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).transferfrom(from, to, value);

        
        return true;
    }
}

pragma solidity 0.4.25;

import ;


contract tokenstate is state {
    mapping(address => uint) public balanceof;
    mapping(address => mapping(address => uint)) public allowance;

    constructor(address _owner, address _associatedcontract) public state(_owner, _associatedcontract) {}

    function setallowance(
        address tokenowner,
        address spender,
        uint value
    ) external onlyassociatedcontract {
        allowance[tokenowner][spender] = value;
    }

    function setbalanceof(address account, uint value) external onlyassociatedcontract {
        balanceof[account] = value;
    }
}

pragma solidity 0.4.25;

import ;
import ;



contract feepooleternalstorage is eternalstorage, limitedsetup {
    bytes32 constant last_fee_withdrawal = ;

    
    constructor(address _owner, address _feepool) public eternalstorage(_owner, _feepool) limitedsetup(6 weeks) {}

    
    function importfeewithdrawaldata(address[] accounts, uint[] feeperiodids) external onlyowner onlyduringsetup {
        require(accounts.length == feeperiodids.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            this.setuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, accounts[i])), feeperiodids[i]);
        }
    }
}

pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract isynth is ierc20 {
    function burn(address account, uint amount) external;

    function issue(address account, uint amount) external;
}


contract idepot {
    function exchangeetherforsynths() public payable returns (uint);
}


contract ethercollateral is owned, pausable, reentrancyguard, mixinresolver {
    using safemath for uint256;
    using safedecimalmath for uint256;

    

    uint256 constant one_thousand = safedecimalmath.unit() * 1000;
    uint256 constant one_hundred = safedecimalmath.unit() * 100;

    uint256 constant seconds_in_a_year = 31536000; 

    
    address constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    

    
    uint256 public collateralizationratio = safedecimalmath.unit() * 150;

    
    uint256 public interestrate = (5 * safedecimalmath.unit()) / 100;
    uint256 public interestpersecond = interestrate.div(seconds_in_a_year);

    
    uint256 public issuefeerate = (5 * safedecimalmath.unit()) / 1000;

    
    uint256 public issuelimit = safedecimalmath.unit() * 5000;

    
    uint256 public minloansize = safedecimalmath.unit() * 1;

    
    uint256 public accountloanlimit = 50;

    
    bool public loanliquidationopen = false;

    
    uint256 public liquidationdeadline;

    

    
    uint256 public totalissuedsynths;

    
    uint256 public totalloanscreated;

    
    uint256 public totalopenloancount;

    
    struct synthloanstruct {
        
        address account;
        
        uint256 collateralamount;
        
        uint256 loanamount;
        
        uint256 timecreated;
        
        uint256 loanid;
        
        uint256 timeclosed;
    }

    
    mapping(address => synthloanstruct[]) public accountssynthloans;

    
    mapping(address => uint256) public accountopenloancounter;

    
    constructor(address _owner, address _resolver) public owned(_owner) pausable(_owner) mixinresolver(_owner, _resolver) {
        liquidationdeadline = now + 92 days; 
    }

    

    function setcollateralizationratio(uint256 ratio) external onlyowner {
        require(ratio <= one_thousand, );
        require(ratio >= one_hundred, );
        collateralizationratio = ratio;
        emit collateralizationratioupdated(ratio);
    }

    function setinterestrate(uint256 _interestrate) external onlyowner {
        require(_interestrate > seconds_in_a_year, );
        require(_interestrate <= safedecimalmath.unit(), );
        interestrate = _interestrate;
        interestpersecond = _interestrate.div(seconds_in_a_year);
        emit interestrateupdated(interestrate);
    }

    function setissuefeerate(uint256 _issuefeerate) external onlyowner {
        issuefeerate = _issuefeerate;
        emit issuefeerateupdated(issuefeerate);
    }

    function setissuelimit(uint256 _issuelimit) external onlyowner {
        issuelimit = _issuelimit;
        emit issuelimitupdated(issuelimit);
    }

    function setminloansize(uint256 _minloansize) external onlyowner {
        minloansize = _minloansize;
        emit minloansizeupdated(minloansize);
    }

    function setaccountloanlimit(uint256 _loanlimit) external onlyowner {
        uint256 hard_cap = 1000;
        require(_loanlimit < hard_cap, );
        accountloanlimit = _loanlimit;
        emit accountloanlimitupdated(accountloanlimit);
    }

    function setloanliquidationopen(bool _loanliquidationopen) external onlyowner {
        require(now > liquidationdeadline, );
        loanliquidationopen = _loanliquidationopen;
        emit loanliquidationopenupdated(loanliquidationopen);
    }

    

    function getcontractinfo()
        external
        view
        returns (
            uint256 _collateralizationratio,
            uint256 _issuanceratio,
            uint256 _interestrate,
            uint256 _interestpersecond,
            uint256 _issuefeerate,
            uint256 _issuelimit,
            uint256 _minloansize,
            uint256 _totalissuedsynths,
            uint256 _totalloanscreated,
            uint256 _totalopenloancount,
            uint256 _ethbalance,
            uint256 _liquidationdeadline,
            bool _loanliquidationopen
        )
    {
        _collateralizationratio = collateralizationratio;
        _issuanceratio = issuanceratio();
        _interestrate = interestrate;
        _interestpersecond = interestpersecond;
        _issuefeerate = issuefeerate;
        _issuelimit = issuelimit;
        _minloansize = minloansize;
        _totalissuedsynths = totalissuedsynths;
        _totalloanscreated = totalloanscreated;
        _totalopenloancount = totalopenloancount;
        _ethbalance = address(this).balance;
        _liquidationdeadline = liquidationdeadline;
        _loanliquidationopen = loanliquidationopen;
    }

    
    
    
    function issuanceratio() public view returns (uint256) {
        
        
        return one_hundred.dividedecimalround(collateralizationratio);
    }

    function loanamountfromcollateral(uint256 collateralamount) public view returns (uint256) {
        return collateralamount.multiplydecimal(issuanceratio());
    }

    function collateralamountforloan(uint256 loanamount) external view returns (uint256) {
        return loanamount.multiplydecimal(collateralizationratio.dividedecimalround(one_hundred));
    }

    function currentinterestonloan(address _account, uint256 _loanid) external view returns (uint256) {
        
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        uint256 loanlifespan = _loanlifespan(synthloan);
        return accruedinterestonloan(synthloan.loanamount, loanlifespan);
    }

    function accruedinterestonloan(uint256 _loanamount, uint256 _seconds) public view returns (uint256 interestamount) {
        
        
        interestamount = _loanamount.multiplydecimalround(interestpersecond.mul(_seconds));
    }

    function calculatemintingfee(address _account, uint256 _loanid) external view returns (uint256) {
        
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        return _calculatemintingfee(synthloan);
    }

    function openloanidsbyaccount(address _account) external view returns (uint256[]) {
        uint256[] _openloanids;
        uint256 _counter = 0;

        synthloanstruct[] memory synthloans = accountssynthloans[_account];

        for (uint256 i = 0; i < synthloans.length; i++) {
            if (synthloans[i].timeclosed == 0) {
                _openloanids[_counter] = synthloans[i].loanid;
                _counter++;
            }
        }
        
        uint256[] memory _result = new uint256[](_counter);

        
        for (uint256 j = 0; j < _counter; j++) {
            _result[j] = _openloanids[j];
        }
        
        return _result;
    }

    function getloan(address _account, uint256 _loanid)
        external
        view
        returns (
            address account,
            uint256 collateralamount,
            uint256 loanamount,
            uint256 timecreated,
            uint256 loanid,
            uint256 timeclosed,
            uint256 interest,
            uint256 totalfees
        )
    {
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        account = synthloan.account;
        collateralamount = synthloan.collateralamount;
        loanamount = synthloan.loanamount;
        timecreated = synthloan.timecreated;
        loanid = synthloan.loanid;
        timeclosed = synthloan.timeclosed;
        interest = accruedinterestonloan(synthloan.loanamount, _loanlifespan(synthloan));
        totalfees = interest.add(_calculatemintingfee(synthloan));
    }

    function loanlifespan(address _account, uint256 _loanid) external view returns (uint256 loanlifespan) {
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        loanlifespan = _loanlifespan(synthloan);
    }

    

    function openloan() external payable notpaused nonreentrant returns (uint256 loanid) {
        
        require(msg.value >= minloansize, );

        
        require(loanliquidationopen == false, );

        
        require(accountssynthloans[msg.sender].length < accountloanlimit, );

        
        uint256 loanamount = loanamountfromcollateral(msg.value);

        
        require(totalissuedsynths.add(loanamount) < issuelimit, );

        
        loanid = _incrementtotalloanscounter();

        
        synthloanstruct memory synthloan = synthloanstruct({
            account: msg.sender,
            collateralamount: msg.value,
            loanamount: loanamount,
            timecreated: now,
            loanid: loanid,
            timeclosed: 0
        });

        
        accountssynthloans[msg.sender].push(synthloan);

        
        totalissuedsynths = totalissuedsynths.add(loanamount);

        
        synthseth().issue(msg.sender, loanamount);

        
        emit loancreated(msg.sender, loanid, loanamount);
    }

    function closeloan(uint256 loanid) external nonreentrant {
        _closeloan(msg.sender, loanid);
    }

    
    function liquidateunclosedloan(address _loancreatorsaddress, uint256 _loanid) external nonreentrant {
        require(loanliquidationopen, );
        
        _closeloan(_loancreatorsaddress, _loanid);
        
        emit loanliquidated(_loancreatorsaddress, _loanid, msg.sender);
    }

    

    function _closeloan(address account, uint256 loanid) private {
        
        synthloanstruct memory synthloan = _getloanfromstorage(account, loanid);

        require(synthloan.loanid > 0, );
        require(synthloan.timeclosed == 0, );
        require(
            synthseth().balanceof(msg.sender) >= synthloan.loanamount,
            
        );

        
        _recordloanclosure(synthloan);

        
        totalissuedsynths = totalissuedsynths.sub(synthloan.loanamount);

        
        uint256 interestamount = accruedinterestonloan(synthloan.loanamount, _loanlifespan(synthloan));
        uint256 mintingfee = _calculatemintingfee(synthloan);
        uint256 totalfees = interestamount.add(mintingfee);

        
        synthseth().burn(account, synthloan.loanamount);

        
        require(synthsusd().balanceof(depot()) >= totalfees, );
        depot().exchangeetherforsynths.value(totalfees)();

        
        synthsusd().transfer(fee_address, synthsusd().balanceof(this));

        
        address(msg.sender).transfer(synthloan.collateralamount.sub(totalfees));

        
        emit loanclosed(account, loanid, totalfees);
    }

    function _getloanfromstorage(address account, uint256 loanid) private view returns (synthloanstruct) {
        synthloanstruct[] memory synthloans = accountssynthloans[account];
        for (uint256 i = 0; i < synthloans.length; i++) {
            if (synthloans[i].loanid == loanid) {
                return synthloans[i];
            }
        }
    }

    function _recordloanclosure(synthloanstruct synthloan) private {
        
        synthloanstruct[] storage synthloans = accountssynthloans[synthloan.account];
        for (uint256 i = 0; i < synthloans.length; i++) {
            if (synthloans[i].loanid == synthloan.loanid) {
                
                synthloans[i].timeclosed = now;
            }
        }

        
        totalopenloancount = totalopenloancount.sub(1);
    }

    function _incrementtotalloanscounter() private returns (uint256) {
        
        totalopenloancount = totalopenloancount.add(1);
        
        totalloanscreated = totalloanscreated.add(1);
        
        return totalloanscreated;
    }

    function _calculatemintingfee(synthloanstruct synthloan) private view returns (uint256 mintingfee) {
        mintingfee = synthloan.loanamount.multiplydecimalround(issuefeerate);
    }

    function _loanlifespan(synthloanstruct synthloan) private view returns (uint256 loanlifespan) {
        
        bool loanclosed = synthloan.timeclosed > 0;
        
        loanlifespan = loanclosed ? synthloan.timeclosed.sub(synthloan.timecreated) : now.sub(synthloan.timecreated);
    }

    

    function synthseth() internal view returns (isynth) {
        return isynth(resolver.requireandgetaddress(, ));
    }

    function synthsusd() internal view returns (isynth) {
        return isynth(resolver.requireandgetaddress(, ));
    }

    function depot() internal view returns (idepot) {
        return idepot(resolver.requireandgetaddress(, ));
    }

    

    event collateralizationratioupdated(uint256 ratio);
    event interestrateupdated(uint256 interestrate);
    event issuefeerateupdated(uint256 issuefeerate);
    event issuelimitupdated(uint256 issuelimit);
    event minloansizeupdated(uint256 minloansize);
    event accountloanlimitupdated(uint256 loanlimit);
    event loanliquidationopenupdated(bool loanliquidationopen);
    event loancreated(address indexed account, uint256 loanid, uint256 amount);
    event loanclosed(address indexed account, uint256 loanid, uint256 feespaid);
    event loanliquidated(address indexed account, uint256 loanid, address liquidator);
}

pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract isynth is ierc20 {}


contract iexchangerates {
    function rateforcurrency(bytes32 currencykey) external view returns (uint);

    function rateisstale(bytes32 currencykey) external view returns (bool);
}


contract depot is selfdestructible, pausable, reentrancyguard, mixinresolver {
    using safemath for uint;
    using safedecimalmath for uint;

    bytes32 constant snx = ;
    bytes32 constant eth = ;

    

    
    
    
    address public fundswallet;

    
    struct synthdeposit {
        
        address user;
        
        uint amount;
    }

    
    mapping(uint => synthdeposit) public deposits;
    
    uint public depositstartindex;
    
    uint public depositendindex;

    
    uint public totalsellabledeposits;

    
    uint public minimumdepositamount = 50 * safedecimalmath.unit();

    
    uint public maxethpurchase = 500 * safedecimalmath.unit();

    
    
    
    mapping(address => uint) public smalldeposits;

    

    constructor(
        
        address _owner,
        
        address _fundswallet,
        
        address _resolver
    )
        public
        
        selfdestructible(_owner)
        pausable(_owner)
        mixinresolver(_owner, _resolver)
    {
        fundswallet = _fundswallet;
    }

    

    function setmaxethpurchase(uint _maxethpurchase) external onlyowner {
        maxethpurchase = _maxethpurchase;
        emit maxethpurchaseupdated(maxethpurchase);
    }

    
    function setfundswallet(address _fundswallet) external onlyowner {
        fundswallet = _fundswallet;
        emit fundswalletupdated(fundswallet);
    }

    
    function setminimumdepositamount(uint _amount) external onlyowner {
        
        require(_amount > safedecimalmath.unit(), );
        minimumdepositamount = _amount;
        emit minimumdepositamountupdated(minimumdepositamount);
    }

    

    
    function() external payable {
        exchangeetherforsynths();
    }

    
    function exchangeetherforsynths()
        public
        payable
        nonreentrant
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        require(msg.value <= maxethpurchase, );
        uint ethtosend;

        
        
        uint requestedtopurchase = msg.value.multiplydecimal(exchangerates().rateforcurrency(eth));
        uint remainingtofulfill = requestedtopurchase;

        
        for (uint i = depositstartindex; remainingtofulfill > 0 && i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            
            
            if (deposit.user == address(0)) {
                depositstartindex = depositstartindex.add(1);
            } else {
                
                
                if (deposit.amount > remainingtofulfill) {
                    
                    
                    
                    uint newamount = deposit.amount.sub(remainingtofulfill);
                    deposits[i] = synthdeposit({user: deposit.user, amount: newamount});

                    totalsellabledeposits = totalsellabledeposits.sub(remainingtofulfill);

                    
                    
                    
                    
                    
                    ethtosend = remainingtofulfill.dividedecimal(exchangerates().rateforcurrency(eth));

                    
                    
                    
                    
                    if (!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, remainingtofulfill, i);
                    }

                    
                    
                    
                    
                    synthsusd().transfer(msg.sender, remainingtofulfill);

                    
                    remainingtofulfill = 0;
                } else if (deposit.amount <= remainingtofulfill) {
                    
                    
                    
                    delete deposits[i];
                    
                    depositstartindex = depositstartindex.add(1);
                    
                    totalsellabledeposits = totalsellabledeposits.sub(deposit.amount);

                    
                    
                    
                    
                    
                    ethtosend = deposit.amount.dividedecimal(exchangerates().rateforcurrency(eth));

                    
                    
                    
                    
                    if (!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, deposit.amount, i);
                    }

                    
                    
                    
                    
                    synthsusd().transfer(msg.sender, deposit.amount);

                    
                    
                    remainingtofulfill = remainingtofulfill.sub(deposit.amount);
                }
            }
        }

        
        
        if (remainingtofulfill > 0) {
            msg.sender.transfer(remainingtofulfill.dividedecimal(exchangerates().rateforcurrency(eth)));
        }

        
        uint fulfilled = requestedtopurchase.sub(remainingtofulfill);

        if (fulfilled > 0) {
            
            emit exchange(, msg.value, , fulfilled);
        }

        return fulfilled;
    }

    
    function exchangeetherforsynthsatrate(uint guaranteedrate)
        public
        payable
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        require(guaranteedrate == exchangerates().rateforcurrency(eth), );

        return exchangeetherforsynths();
    }

    
    function exchangeetherforsnx()
        public
        payable
        ratenotstale(snx)
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        
        uint synthetixtosend = synthetixreceivedforether(msg.value);

        
        fundswallet.transfer(msg.value);

        
        synthetix().transfer(msg.sender, synthetixtosend);

        emit exchange(, msg.value, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangeetherforsnxatrate(uint guaranteedetherrate, uint guaranteedsynthetixrate)
        public
        payable
        ratenotstale(snx)
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        require(guaranteedetherrate == exchangerates().rateforcurrency(eth), );
        require(
            guaranteedsynthetixrate == exchangerates().rateforcurrency(snx),
            
        );

        return exchangeetherforsnx();
    }

    
    function exchangesynthsforsnx(uint synthamount)
        public
        ratenotstale(snx)
        notpaused
        returns (
            uint 
        )
    {
        
        uint synthetixtosend = synthetixreceivedforsynths(synthamount);

        
        
        
        synthsusd().transferfrom(msg.sender, fundswallet, synthamount);

        
        synthetix().transfer(msg.sender, synthetixtosend);

        emit exchange(, synthamount, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangesynthsforsnxatrate(uint synthamount, uint guaranteedrate)
        public
        ratenotstale(snx)
        notpaused
        returns (
            uint 
        )
    {
        require(guaranteedrate == exchangerates().rateforcurrency(snx), );

        return exchangesynthsforsnx(synthamount);
    }

    
    function withdrawsynthetix(uint amount) external onlyowner {
        synthetix().transfer(owner, amount);

        
        
        
        
    }

    
    function withdrawmydepositedsynths() external {
        uint synthstosend = 0;

        for (uint i = depositstartindex; i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            if (deposit.user == msg.sender) {
                
                
                synthstosend = synthstosend.add(deposit.amount);
                delete deposits[i];
                
                emit synthdepositremoved(deposit.user, deposit.amount, i);
            }
        }

        
        totalsellabledeposits = totalsellabledeposits.sub(synthstosend);

        
        
        synthstosend = synthstosend.add(smalldeposits[msg.sender]);
        smalldeposits[msg.sender] = 0;

        
        require(synthstosend > 0, );

        
        synthsusd().transfer(msg.sender, synthstosend);

        emit synthwithdrawal(msg.sender, synthstosend);
    }

    
    function depositsynths(uint amount) external {
        
        synthsusd().transferfrom(msg.sender, this, amount);

        
        
        if (amount < minimumdepositamount) {
            
            
            smalldeposits[msg.sender] = smalldeposits[msg.sender].add(amount);

            emit synthdepositnotaccepted(msg.sender, amount, minimumdepositamount);
        } else {
            
            deposits[depositendindex] = synthdeposit({user: msg.sender, amount: amount});
            emit synthdeposit(msg.sender, amount, depositendindex);

            
            depositendindex = depositendindex.add(1);

            
            totalsellabledeposits = totalsellabledeposits.add(amount);
        }
    }

    

    
    function synthetixreceivedforsynths(uint amount) public view returns (uint) {
        
        return amount.dividedecimal(exchangerates().rateforcurrency(snx));
    }

    
    function synthetixreceivedforether(uint amount) public view returns (uint) {
        
        uint valuesentinsynths = amount.multiplydecimal(exchangerates().rateforcurrency(eth));

        
        return synthetixreceivedforsynths(valuesentinsynths);
    }

    
    function synthsreceivedforether(uint amount) public view returns (uint) {
        
        return amount.multiplydecimal(exchangerates().rateforcurrency(eth));
    }

    

    function synthsusd() internal view returns (isynth) {
        return isynth(resolver.requireandgetaddress(, ));
    }

    function synthetix() internal view returns (ierc20) {
        return ierc20(resolver.requireandgetaddress(, ));
    }

    function exchangerates() internal view returns (iexchangerates) {
        return iexchangerates(resolver.requireandgetaddress(, ));
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!exchangerates().rateisstale(currencykey), );
        _;
    }

    

    event maxethpurchaseupdated(uint amount);
    event fundswalletupdated(address newfundswallet);
    event exchange(string fromcurrency, uint fromamount, string tocurrency, uint toamount);
    event synthwithdrawal(address user, uint amount);
    event synthdeposit(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositremoved(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositnotaccepted(address user, uint amount, uint minimum);
    event minimumdepositamountupdated(uint amount);
    event nonpayablecontract(address indexed receiver, uint amount);
    event cleareddeposit(
        address indexed fromaddress,
        address indexed toaddress,
        uint fromethamount,
        uint toamount,
        uint indexed depositindex
    );
}

pragma solidity 0.4.25;

import ;
import ;
import ;


interface ifeepool {
    function setrewardstodistribute(uint amount) external;
}



contract rewardsdistribution is owned {
    using safemath for uint;
    using safedecimalmath for uint;

    
    address public authority;

    
    address public synthetixproxy;

    
    address public rewardescrow;

    
    address public feepoolproxy;

    
    struct distributiondata {
        address destination;
        uint amount;
    }

    
    distributiondata[] public distributions;

    
    constructor(
        address _owner,
        address _authority,
        address _synthetixproxy,
        address _rewardescrow,
        address _feepoolproxy
    ) public owned(_owner) {
        authority = _authority;
        synthetixproxy = _synthetixproxy;
        rewardescrow = _rewardescrow;
        feepoolproxy = _feepoolproxy;
    }

    

    function setsynthetixproxy(address _synthetixproxy) external onlyowner {
        synthetixproxy = _synthetixproxy;
    }

    function setrewardescrow(address _rewardescrow) external onlyowner {
        rewardescrow = _rewardescrow;
    }

    function setfeepoolproxy(address _feepoolproxy) external onlyowner {
        feepoolproxy = _feepoolproxy;
    }

    
    function setauthority(address _authority) external onlyowner {
        authority = _authority;
    }

    

    
    function addrewarddistribution(address destination, uint amount) external onlyowner returns (bool) {
        require(destination != address(0), );
        require(amount != 0, );

        distributiondata memory rewardsdistribution = distributiondata(destination, amount);
        distributions.push(rewardsdistribution);

        emit rewarddistributionadded(distributions.length  1, destination, amount);
        return true;
    }

    
    function removerewarddistribution(uint index) external onlyowner {
        require(index <= distributions.length  1, );

        
        for (uint i = index; i < distributions.length  1; i++) {
            distributions[i] = distributions[i + 1];
        }
        distributions.length;

        
        
        
        
    }

    
    function editrewarddistribution(
        uint index,
        address destination,
        uint amount
    ) external onlyowner returns (bool) {
        require(index <= distributions.length  1, );

        distributions[index].destination = destination;
        distributions[index].amount = amount;

        return true;
    }

    
    function distributerewards(uint amount) external returns (bool) {
        require(msg.sender == authority, );
        require(rewardescrow != address(0), );
        require(synthetixproxy != address(0), );
        require(feepoolproxy != address(0), );
        require(amount > 0, );
        require(
            ierc20(synthetixproxy).balanceof(this) >= amount,
            
        );

        uint remainder = amount;

        
        for (uint i = 0; i < distributions.length; i++) {
            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {
                remainder = remainder.sub(distributions[i].amount);

                
                ierc20(synthetixproxy).transfer(distributions[i].destination, distributions[i].amount);

                
                bytes memory payload = abi.encodewithsignature(, distributions[i].amount);
                distributions[i].destination.call(payload);
                
            }
        }

        
        ierc20(synthetixproxy).transfer(rewardescrow, remainder);

        
        ifeepool(feepoolproxy).setrewardstodistribute(remainder);

        emit rewardsdistributed(amount);
        return true;
    }

    

    
    function distributionslength() external view returns (uint) {
        return distributions.length;
    }

    

    event rewarddistributionadded(uint index, address destination, uint amount);
    event rewardsdistributed(uint amount);
}

pragma solidity 0.4.25;

import ;


contract state is owned {
    address public associatedcontract;

    constructor(address _owner, address _associatedcontract) public owned(_owner) {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    function setassociatedcontract(address _associatedcontract) external onlyowner {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    modifier onlyassociatedcontract {
        require(msg.sender == associatedcontract, );
        _;
    }

    event associatedcontractupdated(address associatedcontract);
}



pragma solidity ^0.4.24;



library safemath {
    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0); 
        uint256 c = a / b;
        

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a  b;

        return c;
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}

pragma solidity 0.4.25;

import ;



library math {
    using safemath for uint;
    using safedecimalmath for uint;

    
    function powdecimal(uint x, uint n) internal pure returns (uint) {
        

        uint result = safedecimalmath.unit();
        while (n > 0) {
            if (n % 2 != 0) {
                result = result.multiplydecimal(x);
            }
            x = x.multiplydecimal(x);
            n /= 2;
        }
        return result;
    }
}

pragma solidity 0.4.25;

import ;



contract selfdestructible is owned {
    uint public initiationtime;
    bool public selfdestructinitiated;
    address public selfdestructbeneficiary;
    uint public constant selfdestruct_delay = 4 weeks;

    
    constructor(address _owner) public owned(_owner) {
        require(_owner != address(0), );
        selfdestructbeneficiary = _owner;
        emit selfdestructbeneficiaryupdated(_owner);
    }

    
    function setselfdestructbeneficiary(address _beneficiary) external onlyowner {
        require(_beneficiary != address(0), );
        selfdestructbeneficiary = _beneficiary;
        emit selfdestructbeneficiaryupdated(_beneficiary);
    }

    
    function initiateselfdestruct() external onlyowner {
        initiationtime = now;
        selfdestructinitiated = true;
        emit selfdestructinitiated(selfdestruct_delay);
    }

    
    function terminateselfdestruct() external onlyowner {
        initiationtime = 0;
        selfdestructinitiated = false;
        emit selfdestructterminated();
    }

    
    function selfdestruct() external onlyowner {
        require(selfdestructinitiated, );
        require(initiationtime + selfdestruct_delay < now, );
        address beneficiary = selfdestructbeneficiary;
        emit selfdestructed(beneficiary);
        selfdestruct(beneficiary);
    }

    event selfdestructterminated();
    event selfdestructed(address beneficiary);
    event selfdestructinitiated(uint selfdestructdelay);
    event selfdestructbeneficiaryupdated(address newbeneficiary);
}

pragma solidity 0.4.25;

import ;
import ;


contract mixinresolver is owned {
    addressresolver public resolver;

    constructor(address _owner, address _resolver) public owned(_owner) {
        resolver = addressresolver(_resolver);
    }

    

    function setresolver(addressresolver _resolver) public onlyowner {
        resolver = _resolver;
    }
}

pragma solidity 0.4.25;

import ;



contract pausable is owned {
    uint public lastpausetime;
    bool public paused;

    
    constructor(address _owner) public owned(_owner) {
        
    }

    
    function setpaused(bool _paused) external onlyowner {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;

        
        if (paused) {
            lastpausetime = now;
        }

        
        emit pausechanged(paused);
    }

    event pausechanged(bool ispaused);

    modifier notpaused {
        require(!paused, );
        _;
    }
}

pragma solidity 0.4.25;



contract limitedsetup {
    uint setupexpirytime;

    
    constructor(uint setupduration) public {
        setupexpirytime = now + setupduration;
    }

    modifier onlyduringsetup {
        require(now < setupexpirytime, );
        _;
    }
}

pragma solidity 0.4.25;

import ;



contract addressresolver is owned {
    mapping(bytes32 => address) public repository;

    constructor(address _owner) public owned(_owner) {}

    

    function importaddresses(bytes32[] names, address[] destinations) public onlyowner {
        require(names.length == destinations.length, );

        for (uint i = 0; i < names.length; i++) {
            repository[names[i]] = destinations[i];
        }
    }

    

    function getaddress(bytes32 name) public view returns (address) {
        return repository[name];
    }

    function requireandgetaddress(bytes32 name, string reason) public view returns (address) {
        address _foundaddress = repository[name];
        require(_foundaddress != address(0), reason);
        return _foundaddress;
    }
}



pragma solidity ^0.4.24;



contract reentrancyguard {
    
    uint256 private _guardcounter;

    constructor() internal {
        
        
        _guardcounter = 1;
    }

    
    modifier nonreentrant() {
        _guardcounter += 1;
        uint256 localcounter = _guardcounter;
        _;
        require(localcounter == _guardcounter);
    }
}

pragma solidity 0.4.25;


contract ierc20 {
    function totalsupply() public view returns (uint);

    function balanceof(address owner) public view returns (uint);

    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);

    function approve(address spender, uint value) public returns (bool);

    function transferfrom(
        address from,
        address to,
        uint value
    ) public returns (bool);

    
    function name() public view returns (string);

    function symbol() public view returns (string);

    function decimals() public view returns (uint8);

    event transfer(address indexed from, address indexed to, uint value);

    event approval(address indexed owner, address indexed spender, uint value);
}

pragma solidity 0.4.25;


contract owned {
    address public owner;
    address public nominatedowner;

    constructor(address _owner) public {
        require(_owner != address(0), );
        owner = _owner;
        emit ownerchanged(address(0), _owner);
    }

    function nominatenewowner(address _owner) external onlyowner {
        nominatedowner = _owner;
        emit ownernominated(_owner);
    }

    function acceptownership() external {
        require(msg.sender == nominatedowner, );
        emit ownerchanged(owner, nominatedowner);
        owner = nominatedowner;
        nominatedowner = address(0);
    }

    modifier onlyowner {
        require(msg.sender == owner, );
        _;
    }

    event ownernominated(address newowner);
    event ownerchanged(address oldowner, address newowner);
}

pragma solidity ^0.5.16;


import ;



contract state is owned {
    
    
    address public associatedcontract;

    constructor(address _associatedcontract) internal {
        
        require(owner != address(0), );

        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    
    function setassociatedcontract(address _associatedcontract) external onlyowner {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    modifier onlyassociatedcontract {
        require(msg.sender == associatedcontract, );
        _;
    }

    

    event associatedcontractupdated(address associatedcontract);
}

pragma solidity ^0.5.16;


import ;
import ;
import ;



contract exchangestate is owned, state, iexchangestate {
    struct exchangeentry {
        bytes32 src;
        uint amount;
        bytes32 dest;
        uint amountreceived;
        uint exchangefeerate;
        uint timestamp;
        uint roundidforsrc;
        uint roundidfordest;
    }

    mapping(address => mapping(bytes32 => exchangeentry[])) public exchanges;

    uint public maxentriesinqueue = 12;

    constructor(address _owner, address _associatedcontract) public owned(_owner) state(_associatedcontract) {}

    

    function setmaxentriesinqueue(uint _maxentriesinqueue) external onlyowner {
        maxentriesinqueue = _maxentriesinqueue;
    }

    

    function appendexchangeentry(
        address account,
        bytes32 src,
        uint amount,
        bytes32 dest,
        uint amountreceived,
        uint exchangefeerate,
        uint timestamp,
        uint roundidforsrc,
        uint roundidfordest
    ) external onlyassociatedcontract {
        require(exchanges[account][dest].length < maxentriesinqueue, );

        exchanges[account][dest].push(
            exchangeentry({
                src: src,
                amount: amount,
                dest: dest,
                amountreceived: amountreceived,
                exchangefeerate: exchangefeerate,
                timestamp: timestamp,
                roundidforsrc: roundidforsrc,
                roundidfordest: roundidfordest
            })
        );
    }

    function removeentries(address account, bytes32 currencykey) external onlyassociatedcontract {
        delete exchanges[account][currencykey];
    }

    

    function getlengthofentries(address account, bytes32 currencykey) external view returns (uint) {
        return exchanges[account][currencykey].length;
    }

    function getentryat(
        address account,
        bytes32 currencykey,
        uint index
    )
        external
        view
        returns (
            bytes32 src,
            uint amount,
            bytes32 dest,
            uint amountreceived,
            uint exchangefeerate,
            uint timestamp,
            uint roundidforsrc,
            uint roundidfordest
        )
    {
        exchangeentry storage entry = exchanges[account][currencykey][index];
        return (
            entry.src,
            entry.amount,
            entry.dest,
            entry.amountreceived,
            entry.exchangefeerate,
            entry.timestamp,
            entry.roundidforsrc,
            entry.roundidfordest
        );
    }

    function getmaxtimestamp(address account, bytes32 currencykey) external view returns (uint) {
        exchangeentry[] storage userentries = exchanges[account][currencykey];
        uint timestamp = 0;
        for (uint i = 0; i < userentries.length; i++) {
            if (userentries[i].timestamp > timestamp) {
                timestamp = userentries[i].timestamp;
            }
        }
        return timestamp;
    }
}

pragma solidity ^0.5.16;


import ;
import ;




contract eternalstorage is owned, state {
    constructor(address _owner, address _associatedcontract) public owned(_owner) state(_associatedcontract) {}

    
    mapping(bytes32 => uint) internal uintstorage;
    mapping(bytes32 => string) internal stringstorage;
    mapping(bytes32 => address) internal addressstorage;
    mapping(bytes32 => bytes) internal bytesstorage;
    mapping(bytes32 => bytes32) internal bytes32storage;
    mapping(bytes32 => bool) internal booleanstorage;
    mapping(bytes32 => int) internal intstorage;

    
    function getuintvalue(bytes32 record) external view returns (uint) {
        return uintstorage[record];
    }

    function setuintvalue(bytes32 record, uint value) external onlyassociatedcontract {
        uintstorage[record] = value;
    }

    function deleteuintvalue(bytes32 record) external onlyassociatedcontract {
        delete uintstorage[record];
    }

    
    function getstringvalue(bytes32 record) external view returns (string memory) {
        return stringstorage[record];
    }

    function setstringvalue(bytes32 record, string calldata value) external onlyassociatedcontract {
        stringstorage[record] = value;
    }

    function deletestringvalue(bytes32 record) external onlyassociatedcontract {
        delete stringstorage[record];
    }

    
    function getaddressvalue(bytes32 record) external view returns (address) {
        return addressstorage[record];
    }

    function setaddressvalue(bytes32 record, address value) external onlyassociatedcontract {
        addressstorage[record] = value;
    }

    function deleteaddressvalue(bytes32 record) external onlyassociatedcontract {
        delete addressstorage[record];
    }

    
    function getbytesvalue(bytes32 record) external view returns (bytes memory) {
        return bytesstorage[record];
    }

    function setbytesvalue(bytes32 record, bytes calldata value) external onlyassociatedcontract {
        bytesstorage[record] = value;
    }

    function deletebytesvalue(bytes32 record) external onlyassociatedcontract {
        delete bytesstorage[record];
    }

    
    function getbytes32value(bytes32 record) external view returns (bytes32) {
        return bytes32storage[record];
    }

    function setbytes32value(bytes32 record, bytes32 value) external onlyassociatedcontract {
        bytes32storage[record] = value;
    }

    function deletebytes32value(bytes32 record) external onlyassociatedcontract {
        delete bytes32storage[record];
    }

    
    function getbooleanvalue(bytes32 record) external view returns (bool) {
        return booleanstorage[record];
    }

    function setbooleanvalue(bytes32 record, bool value) external onlyassociatedcontract {
        booleanstorage[record] = value;
    }

    function deletebooleanvalue(bytes32 record) external onlyassociatedcontract {
        delete booleanstorage[record];
    }

    
    function getintvalue(bytes32 record) external view returns (int) {
        return intstorage[record];
    }

    function setintvalue(bytes32 record, int value) external onlyassociatedcontract {
        intstorage[record] = value;
    }

    function deleteintvalue(bytes32 record) external onlyassociatedcontract {
        delete intstorage[record];
    }
}

pragma solidity ^0.5.16;


import ;
import ;


import ;



contract delegateapprovals is owned, idelegateapprovals {
    bytes32 public constant burn_for_address = ;
    bytes32 public constant issue_for_address = ;
    bytes32 public constant claim_for_address = ;
    bytes32 public constant exchange_for_address = ;
    bytes32 public constant approve_all = ;

    bytes32[5] private _delegatablefunctions = [
        approve_all,
        burn_for_address,
        issue_for_address,
        claim_for_address,
        exchange_for_address
    ];

    
    eternalstorage public eternalstorage;

    constructor(address _owner, eternalstorage _eternalstorage) public owned(_owner) {
        eternalstorage = _eternalstorage;
    }

    

    

    
    function _getkey(
        bytes32 _action,
        address _authoriser,
        address _delegate
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodepacked(_action, _authoriser, _delegate));
    }

    
    function canburnfor(address authoriser, address delegate) external view returns (bool) {
        return _checkapproval(burn_for_address, authoriser, delegate);
    }

    function canissuefor(address authoriser, address delegate) external view returns (bool) {
        return _checkapproval(issue_for_address, authoriser, delegate);
    }

    function canclaimfor(address authoriser, address delegate) external view returns (bool) {
        return _checkapproval(claim_for_address, authoriser, delegate);
    }

    function canexchangefor(address authoriser, address delegate) external view returns (bool) {
        return _checkapproval(exchange_for_address, authoriser, delegate);
    }

    function approvedall(address authoriser, address delegate) public view returns (bool) {
        return eternalstorage.getbooleanvalue(_getkey(approve_all, authoriser, delegate));
    }

    
    
    
    function _checkapproval(
        bytes32 action,
        address authoriser,
        address delegate
    ) internal view returns (bool) {
        if (approvedall(authoriser, delegate)) return true;

        return eternalstorage.getbooleanvalue(_getkey(action, authoriser, delegate));
    }

    

    
    function approvealldelegatepowers(address delegate) external {
        _setapproval(approve_all, msg.sender, delegate);
    }

    
    function removealldelegatepowers(address delegate) external {
        for (uint i = 0; i < _delegatablefunctions.length; i++) {
            _withdrawapproval(_delegatablefunctions[i], msg.sender, delegate);
        }
    }

    
    function approveburnonbehalf(address delegate) external {
        _setapproval(burn_for_address, msg.sender, delegate);
    }

    function removeburnonbehalf(address delegate) external {
        _withdrawapproval(burn_for_address, msg.sender, delegate);
    }

    
    function approveissueonbehalf(address delegate) external {
        _setapproval(issue_for_address, msg.sender, delegate);
    }

    function removeissueonbehalf(address delegate) external {
        _withdrawapproval(issue_for_address, msg.sender, delegate);
    }

    
    function approveclaimonbehalf(address delegate) external {
        _setapproval(claim_for_address, msg.sender, delegate);
    }

    function removeclaimonbehalf(address delegate) external {
        _withdrawapproval(claim_for_address, msg.sender, delegate);
    }

    
    function approveexchangeonbehalf(address delegate) external {
        _setapproval(exchange_for_address, msg.sender, delegate);
    }

    function removeexchangeonbehalf(address delegate) external {
        _withdrawapproval(exchange_for_address, msg.sender, delegate);
    }

    function _setapproval(
        bytes32 action,
        address authoriser,
        address delegate
    ) internal {
        require(delegate != address(0), );
        eternalstorage.setbooleanvalue(_getkey(action, authoriser, delegate), true);
        emit approval(authoriser, delegate, action);
    }

    function _withdrawapproval(
        bytes32 action,
        address authoriser,
        address delegate
    ) internal {
        
        if (eternalstorage.getbooleanvalue(_getkey(action, authoriser, delegate))) {
            eternalstorage.deletebooleanvalue(_getkey(action, authoriser, delegate));
            emit withdrawapproval(authoriser, delegate, action);
        }
    }

    function seteternalstorage(eternalstorage _eternalstorage) external onlyowner {
        require(address(_eternalstorage) != address(0), );
        eternalstorage = _eternalstorage;
        emit eternalstorageupdated(address(eternalstorage));
    }

    
    event approval(address indexed authoriser, address delegate, bytes32 action);
    event withdrawapproval(address indexed authoriser, address delegate, bytes32 action);
    event eternalstorageupdated(address neweternalstorage);
}

pragma solidity ^0.5.16;


import ;


import ;


import ;



contract purgeablesynth is synth {
    using safedecimalmath for uint;

    
    uint public maxsupplytopurgeinusd = 100000 * safedecimalmath.unit(); 

    bytes32 private constant contract_exrates = ;

    

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        string memory _tokenname,
        string memory _tokensymbol,
        address payable _owner,
        bytes32 _currencykey,
        uint _totalsupply,
        address _resolver
    ) public synth(_proxy, _tokenstate, _tokenname, _tokensymbol, _owner, _currencykey, _totalsupply, _resolver) {
        appendtoaddresscache(contract_exrates);
    }

    

    function exchangerates() internal view returns (iexchangerates) {
        return iexchangerates(requireandgetaddress(contract_exrates, ));
    }

    

    
    function purge(address[] calldata addresses) external optionalproxy_onlyowner {
        iexchangerates exrates = exchangerates();

        uint maxsupplytopurge = exrates.effectivevalue(, maxsupplytopurgeinusd, currencykey);

        
        require(
            totalsupply <= maxsupplytopurge || exrates.rateisfrozen(currencykey),
            
        );

        for (uint i = 0; i < addresses.length; i++) {
            address holder = addresses[i];

            uint amountheld = tokenstate.balanceof(holder);

            if (amountheld > 0) {
                exchanger().exchange(holder, currencykey, amountheld, , holder);
                emitpurged(holder, amountheld);
            }
        }
    }

    
    event purged(address indexed account, uint value);
    bytes32 private constant purged_sig = keccak256();

    function emitpurged(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, purged_sig, addresstobytes32(account), 0, 0);
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;
import ;
import ;


import ;
import ;
import ;
import ;
import ;


contract synth is owned, ierc20, externstatetoken, mixinresolver, isynth {
    

    
    bytes32 public currencykey;

    uint8 public constant decimals = 18;

    
    address public constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    

    bytes32 private constant contract_systemstatus = ;
    bytes32 private constant contract_synthetix = ;
    bytes32 private constant contract_exchanger = ;
    bytes32 private constant contract_issuer = ;
    bytes32 private constant contract_feepool = ;

    bytes32[24] internal addressestocache = [
        contract_systemstatus,
        contract_synthetix,
        contract_exchanger,
        contract_issuer,
        contract_feepool
    ];

    

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        string memory _tokenname,
        string memory _tokensymbol,
        address _owner,
        bytes32 _currencykey,
        uint _totalsupply,
        address _resolver
    )
        public
        externstatetoken(_proxy, _tokenstate, _tokenname, _tokensymbol, _totalsupply, decimals, _owner)
        mixinresolver(_resolver, addressestocache)
    {
        require(_proxy != address(0), );
        require(_owner != address(0), );

        currencykey = _currencykey;
    }

    

    function transfer(address to, uint value) public optionalproxy returns (bool) {
        _ensurecantransfer(messagesender, value);

        
        if (to == fee_address) {
            return _transfertofeeaddress(to, value);
        }

        
        if (to == address(0)) {
            return _internalburn(messagesender, value);
        }

        return super._internaltransfer(messagesender, to, value);
    }

    function transferandsettle(address to, uint value) public optionalproxy returns (bool) {
        systemstatus().requiresynthactive(currencykey);

        (, , uint numentriessettled) = exchanger().settle(messagesender, currencykey);

        
        uint balanceafter = value;

        if (numentriessettled > 0) {
            balanceafter = tokenstate.balanceof(messagesender);
        }

        
        value = value > balanceafter ? balanceafter : value;

        return super._internaltransfer(messagesender, to, value);
    }

    function transferfrom(
        address from,
        address to,
        uint value
    ) public optionalproxy returns (bool) {
        _ensurecantransfer(from, value);

        return _internaltransferfrom(from, to, value);
    }

    function transferfromandsettle(
        address from,
        address to,
        uint value
    ) public optionalproxy returns (bool) {
        systemstatus().requiresynthactive(currencykey);

        (, , uint numentriessettled) = exchanger().settle(from, currencykey);

        
        uint balanceafter = value;

        if (numentriessettled > 0) {
            balanceafter = tokenstate.balanceof(from);
        }

        
        value = value >= balanceafter ? balanceafter : value;

        return _internaltransferfrom(from, to, value);
    }

    
    function _transfertofeeaddress(address to, uint value) internal returns (bool) {
        uint amountinusd;

        
        if (currencykey == ) {
            amountinusd = value;
            super._internaltransfer(messagesender, to, value);
        } else {
            
            amountinusd = exchanger().exchange(messagesender, currencykey, value, , fee_address);
        }

        
        feepool().recordfeepaid(amountinusd);

        return true;
    }

    
    
    function issue(address account, uint amount) external onlyinternalcontracts {
        _internalissue(account, amount);
    }

    
    
    function burn(address account, uint amount) external onlyinternalcontracts {
        _internalburn(account, amount);
    }

    function _internalissue(address account, uint amount) internal {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).add(amount));
        totalsupply = totalsupply.add(amount);
        emittransfer(address(0), account, amount);
        emitissued(account, amount);
    }

    function _internalburn(address account, uint amount) internal returns (bool) {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).sub(amount));
        totalsupply = totalsupply.sub(amount);
        emittransfer(account, address(0), amount);
        emitburned(account, amount);

        return true;
    }

    
    function settotalsupply(uint amount) external optionalproxy_onlyowner {
        totalsupply = amount;
    }

    
    function systemstatus() internal view returns (isystemstatus) {
        return isystemstatus(requireandgetaddress(contract_systemstatus, ));
    }

    function synthetix() internal view returns (isynthetix) {
        return isynthetix(requireandgetaddress(contract_synthetix, ));
    }

    function feepool() internal view returns (ifeepool) {
        return ifeepool(requireandgetaddress(contract_feepool, ));
    }

    function exchanger() internal view returns (iexchanger) {
        return iexchanger(requireandgetaddress(contract_exchanger, ));
    }

    function issuer() internal view returns (iissuer) {
        return iissuer(requireandgetaddress(contract_issuer, ));
    }

    function _ensurecantransfer(address from, uint value) internal view {
        require(exchanger().maxsecsleftinwaitingperiod(from, currencykey) == 0, );
        require(transferablesynths(from) >= value, );
        systemstatus().requiresynthactive(currencykey);
    }

    function transferablesynths(address account) public view returns (uint) {
        (uint reclaimamount, , ) = exchanger().settlementowing(account, currencykey);

        
        

        uint balance = tokenstate.balanceof(account);

        if (reclaimamount > balance) {
            return 0;
        } else {
            return balance.sub(reclaimamount);
        }
    }

    

    function _internaltransferfrom(
        address from,
        address to,
        uint value
    ) internal returns (bool) {
        
        if (tokenstate.allowance(from, messagesender) != uint(1)) {
            
            
            tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));
        }

        return super._internaltransfer(from, to, value);
    }

    

    modifier onlyinternalcontracts() {
        bool issynthetix = msg.sender == address(synthetix());
        bool isfeepool = msg.sender == address(feepool());
        bool isexchanger = msg.sender == address(exchanger());
        bool isissuer = msg.sender == address(issuer());

        require(
            issynthetix || isfeepool || isexchanger || isissuer,
            
        );
        _;
    }

    
    event issued(address indexed account, uint value);
    bytes32 private constant issued_sig = keccak256();

    function emitissued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, issued_sig, addresstobytes32(account), 0, 0);
    }

    event burned(address indexed account, uint value);
    bytes32 private constant burned_sig = keccak256();

    function emitburned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, burned_sig, addresstobytes32(account), 0, 0);
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;


import ;
import ;
import ;
import ;
import ;
import ;
import ;



interface isynthetixinternal {
    function emitsynthexchange(
        address account,
        bytes32 fromcurrencykey,
        uint fromamount,
        bytes32 tocurrencykey,
        uint toamount,
        address toaddress
    ) external;

    function emitexchangereclaim(
        address account,
        bytes32 currencykey,
        uint amount
    ) external;

    function emitexchangerebate(
        address account,
        bytes32 currencykey,
        uint amount
    ) external;
}



contract exchanger is owned, mixinresolver, iexchanger {
    using safemath for uint;
    using safedecimalmath for uint;

    bytes32 private constant susd = ;

    uint public waitingperiodsecs;

    

    bytes32 private constant contract_systemstatus = ;
    bytes32 private constant contract_exchangestate = ;
    bytes32 private constant contract_exrates = ;
    bytes32 private constant contract_synthetix = ;
    bytes32 private constant contract_feepool = ;
    bytes32 private constant contract_delegateapprovals = ;

    bytes32[24] private addressestocache = [
        contract_systemstatus,
        contract_exchangestate,
        contract_exrates,
        contract_synthetix,
        contract_feepool,
        contract_delegateapprovals
    ];

    constructor(address _owner, address _resolver) public owned(_owner) mixinresolver(_resolver, addressestocache) {
        waitingperiodsecs = 3 minutes;
    }

    

    function systemstatus() internal view returns (isystemstatus) {
        return isystemstatus(requireandgetaddress(contract_systemstatus, ));
    }

    function exchangestate() internal view returns (iexchangestate) {
        return iexchangestate(requireandgetaddress(contract_exchangestate, ));
    }

    function exchangerates() internal view returns (iexchangerates) {
        return iexchangerates(requireandgetaddress(contract_exrates, ));
    }

    function synthetix() internal view returns (isynthetix) {
        return isynthetix(requireandgetaddress(contract_synthetix, ));
    }

    function feepool() internal view returns (ifeepool) {
        return ifeepool(requireandgetaddress(contract_feepool, ));
    }

    function delegateapprovals() internal view returns (idelegateapprovals) {
        return idelegateapprovals(requireandgetaddress(contract_delegateapprovals, ));
    }

    function maxsecsleftinwaitingperiod(address account, bytes32 currencykey) public view returns (uint) {
        return secsleftinwaitingperiodforexchange(exchangestate().getmaxtimestamp(account, currencykey));
    }

    
    function feerateforexchange(
        bytes32, 
        bytes32 
    ) public view returns (uint) {
        
        uint exchangefeerate = feepool().exchangefeerate();

        return exchangefeerate;
    }

    function settlementowing(address account, bytes32 currencykey)
        public
        view
        returns (
            uint reclaimamount,
            uint rebateamount,
            uint numentries
        )
    {
        
        numentries = exchangestate().getlengthofentries(account, currencykey);

        
        for (uint i = 0; i < numentries; i++) {
            
            (bytes32 src, uint amount, bytes32 dest, uint amountreceived, , , , ) = exchangestate().getentryat(
                account,
                currencykey,
                i
            );

            
            (uint srcroundidatperiodend, uint destroundidatperiodend) = getroundidsatperiodend(account, currencykey, i);

            
            uint destinationamount = exchangerates().effectivevalueatround(
                src,
                amount,
                dest,
                srcroundidatperiodend,
                destroundidatperiodend
            );

            
            (uint amountshouldhavereceived, ) = calculateexchangeamountminusfees(src, dest, destinationamount);

            if (amountreceived > amountshouldhavereceived) {
                
                reclaimamount = reclaimamount.add(amountreceived.sub(amountshouldhavereceived));
            } else if (amountshouldhavereceived > amountreceived) {
                
                rebateamount = rebateamount.add(amountshouldhavereceived.sub(amountreceived));
            }
        }

        return (reclaimamount, rebateamount, numentries);
    }

    

    function setwaitingperiodsecs(uint _waitingperiodsecs) external onlyowner {
        waitingperiodsecs = _waitingperiodsecs;
    }

    function calculateamountaftersettlement(
        address from,
        bytes32 currencykey,
        uint amount,
        uint refunded
    ) public view returns (uint amountaftersettlement) {
        amountaftersettlement = amount;

        
        uint balanceofsourceaftersettlement = ierc20(address(synthetix().synths(currencykey))).balanceof(from);

        
        if (amountaftersettlement > balanceofsourceaftersettlement) {
            
            amountaftersettlement = balanceofsourceaftersettlement;
        }

        if (refunded > 0) {
            amountaftersettlement = amountaftersettlement.add(refunded);
        }
    }

    
    function exchange(
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        address destinationaddress
    ) external onlysynthetixorsynth returns (uint amountreceived) {
        amountreceived = _exchange(from, sourcecurrencykey, sourceamount, destinationcurrencykey, destinationaddress);
    }

    function exchangeonbehalf(
        address exchangeforaddress,
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external onlysynthetixorsynth returns (uint amountreceived) {
        require(delegateapprovals().canexchangefor(exchangeforaddress, from), );
        amountreceived = _exchange(
            exchangeforaddress,
            sourcecurrencykey,
            sourceamount,
            destinationcurrencykey,
            exchangeforaddress
        );
    }

    function _exchange(
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        address destinationaddress
    )
        internal
        returns (
            
            uint amountreceived
        )
    {
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        (, uint refunded, uint numentriessettled) = _internalsettle(from, sourcecurrencykey);

        uint sourceamountaftersettlement = sourceamount;

        
        if (numentriessettled > 0) {
            
            sourceamountaftersettlement = calculateamountaftersettlement(from, sourcecurrencykey, sourceamount, refunded);

            
            
            if (sourceamountaftersettlement == 0) {
                return 0;
            }
        }

        
        

        
        synthetix().synths(sourcecurrencykey).burn(from, sourceamountaftersettlement);

        uint destinationamount = exchangerates().effectivevalue(
            sourcecurrencykey,
            sourceamountaftersettlement,
            destinationcurrencykey
        );

        uint fee;

        (amountreceived, fee) = calculateexchangeamountminusfees(
            sourcecurrencykey,
            destinationcurrencykey,
            destinationamount
        );

        
        synthetix().synths(destinationcurrencykey).issue(destinationaddress, amountreceived);

        
        if (fee > 0) {
            remitfee(exchangerates(), synthetix(), fee, destinationcurrencykey);
        }

        

        
        isynthetixinternal(address(synthetix())).emitsynthexchange(
            from,
            sourcecurrencykey,
            sourceamountaftersettlement,
            destinationcurrencykey,
            amountreceived,
            destinationaddress
        );

        
        appendexchange(
            destinationaddress,
            sourcecurrencykey,
            sourceamountaftersettlement,
            destinationcurrencykey,
            amountreceived
        );
    }

    function settle(address from, bytes32 currencykey)
        external
        returns (
            uint reclaimed,
            uint refunded,
            uint numentriessettled
        )
    {
        

        systemstatus().requireexchangeactive();

        systemstatus().requiresynthactive(currencykey);

        return _internalsettle(from, currencykey);
    }

    

    function remitfee(
        iexchangerates _exrates,
        isynthetix _synthetix,
        uint fee,
        bytes32 currencykey
    ) internal {
        
        uint usdfeeamount = _exrates.effectivevalue(currencykey, fee, susd);
        _synthetix.synths(susd).issue(feepool().fee_address(), usdfeeamount);
        
        feepool().recordfeepaid(usdfeeamount);
    }

    function _internalsettle(address from, bytes32 currencykey)
        internal
        returns (
            uint reclaimed,
            uint refunded,
            uint numentriessettled
        )
    {
        require(maxsecsleftinwaitingperiod(from, currencykey) == 0, );

        (uint reclaimamount, uint rebateamount, uint entries) = settlementowing(from, currencykey);

        if (reclaimamount > rebateamount) {
            reclaimed = reclaimamount.sub(rebateamount);
            reclaim(from, currencykey, reclaimed);
        } else if (rebateamount > reclaimamount) {
            refunded = rebateamount.sub(reclaimamount);
            refund(from, currencykey, refunded);
        }

        numentriessettled = entries;

        
        exchangestate().removeentries(from, currencykey);
    }

    function reclaim(
        address from,
        bytes32 currencykey,
        uint amount
    ) internal {
        
        synthetix().synths(currencykey).burn(from, amount);
        isynthetixinternal(address(synthetix())).emitexchangereclaim(from, currencykey, amount);
    }

    function refund(
        address from,
        bytes32 currencykey,
        uint amount
    ) internal {
        
        synthetix().synths(currencykey).issue(from, amount);
        isynthetixinternal(address(synthetix())).emitexchangerebate(from, currencykey, amount);
    }

    function secsleftinwaitingperiodforexchange(uint timestamp) internal view returns (uint) {
        if (timestamp == 0 || now >= timestamp.add(waitingperiodsecs)) {
            return 0;
        }

        return timestamp.add(waitingperiodsecs).sub(now);
    }

    function calculateexchangeamountminusfees(
        bytes32 sourcecurrencykey,
        bytes32 destinationcurrencykey,
        uint destinationamount
    ) internal view returns (uint amountreceived, uint fee) {
        
        amountreceived = destinationamount;

        
        uint exchangefeerate = feerateforexchange(sourcecurrencykey, destinationcurrencykey);

        amountreceived = destinationamount.multiplydecimal(safedecimalmath.unit().sub(exchangefeerate));

        fee = destinationamount.sub(amountreceived);
    }

    function appendexchange(
        address account,
        bytes32 src,
        uint amount,
        bytes32 dest,
        uint amountreceived
    ) internal {
        iexchangerates exrates = exchangerates();
        uint roundidforsrc = exrates.getcurrentroundid(src);
        uint roundidfordest = exrates.getcurrentroundid(dest);
        uint exchangefeerate = feepool().exchangefeerate();
        exchangestate().appendexchangeentry(
            account,
            src,
            amount,
            dest,
            amountreceived,
            exchangefeerate,
            now,
            roundidforsrc,
            roundidfordest
        );
    }

    function getroundidsatperiodend(
        address account,
        bytes32 currencykey,
        uint index
    ) internal view returns (uint srcroundidatperiodend, uint destroundidatperiodend) {
        (bytes32 src, , bytes32 dest, , , uint timestamp, uint roundidforsrc, uint roundidfordest) = exchangestate()
            .getentryat(account, currencykey, index);

        iexchangerates exrates = exchangerates();
        srcroundidatperiodend = exrates.getlastroundidbeforeelapsedsecs(src, roundidforsrc, timestamp, waitingperiodsecs);
        destroundidatperiodend = exrates.getlastroundidbeforeelapsedsecs(dest, roundidfordest, timestamp, waitingperiodsecs);
    }

    

    modifier onlysynthetixorsynth() {
        isynthetix _synthetix = synthetix();
        require(
            msg.sender == address(_synthetix) || _synthetix.synthsbyaddress(msg.sender) != bytes32(0),
            
        );
        _;
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;


import ;



contract externstatetoken is owned, selfdestructible, proxyable {
    using safemath for uint;
    using safedecimalmath for uint;

    

    
    tokenstate public tokenstate;

    
    string public name;
    string public symbol;
    uint public totalsupply;
    uint8 public decimals;

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        string memory _name,
        string memory _symbol,
        uint _totalsupply,
        uint8 _decimals,
        address _owner
    ) public owned(_owner) selfdestructible() proxyable(_proxy) {
        tokenstate = _tokenstate;

        name = _name;
        symbol = _symbol;
        totalsupply = _totalsupply;
        decimals = _decimals;
    }

    

    
    function allowance(address owner, address spender) public view returns (uint) {
        return tokenstate.allowance(owner, spender);
    }

    
    function balanceof(address account) external view returns (uint) {
        return tokenstate.balanceof(account);
    }

    

    
    function settokenstate(tokenstate _tokenstate) external optionalproxy_onlyowner {
        tokenstate = _tokenstate;
        emittokenstateupdated(address(_tokenstate));
    }

    function _internaltransfer(
        address from,
        address to,
        uint value
    ) internal returns (bool) {
        
        require(to != address(0) && to != address(this) && to != address(proxy), );

        
        tokenstate.setbalanceof(from, tokenstate.balanceof(from).sub(value));
        tokenstate.setbalanceof(to, tokenstate.balanceof(to).add(value));

        
        emittransfer(from, to, value);

        return true;
    }

    
    function _transferbyproxy(
        address from,
        address to,
        uint value
    ) internal returns (bool) {
        return _internaltransfer(from, to, value);
    }

    
    function _transferfrombyproxy(
        address sender,
        address from,
        address to,
        uint value
    ) internal returns (bool) {
        
        tokenstate.setallowance(from, sender, tokenstate.allowance(from, sender).sub(value));
        return _internaltransfer(from, to, value);
    }

    
    function approve(address spender, uint value) public optionalproxy returns (bool) {
        address sender = messagesender;

        tokenstate.setallowance(sender, spender, value);
        emitapproval(sender, spender, value);
        return true;
    }

    
    function addresstobytes32(address input) internal pure returns (bytes32) {
        return bytes32(uint256(uint160(input)));
    }

    event transfer(address indexed from, address indexed to, uint value);
    bytes32 internal constant transfer_sig = keccak256();

    function emittransfer(
        address from,
        address to,
        uint value
    ) internal {
        proxy._emit(abi.encode(value), 3, transfer_sig, addresstobytes32(from), addresstobytes32(to), 0);
    }

    event approval(address indexed owner, address indexed spender, uint value);
    bytes32 internal constant approval_sig = keccak256();

    function emitapproval(
        address owner,
        address spender,
        uint value
    ) internal {
        proxy._emit(abi.encode(value), 3, approval_sig, addresstobytes32(owner), addresstobytes32(spender), 0);
    }

    event tokenstateupdated(address newtokenstate);
    bytes32 internal constant tokenstateupdated_sig = keccak256();

    function emittokenstateupdated(address newtokenstate) internal {
        proxy._emit(abi.encode(newtokenstate), 1, tokenstateupdated_sig, 0, 0, 0);
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;


import ;
import ;



contract synthetixescrow is owned, limitedsetup(8 weeks), ihasbalance {
    using safemath for uint;

    
    isynthetix public synthetix;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalvestedbalance;

    uint public constant time_index = 0;
    uint public constant quantity_index = 1;

    
    uint public constant max_vesting_entries = 20;

    

    constructor(address _owner, isynthetix _synthetix) public owned(_owner) {
        synthetix = _synthetix;
    }

    

    function setsynthetix(isynthetix _synthetix) external onlyowner {
        synthetix = _synthetix;
        emit synthetixupdated(address(_synthetix));
    }

    

    
    function balanceof(address account) public view returns (uint) {
        return totalvestedaccountbalance[account];
    }

    
    function numvestingentries(address account) public view returns (uint) {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index) public view returns (uint[2] memory) {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index) public view returns (uint) {
        return getvestingscheduleentry(account, index)[time_index];
    }

    
    function getvestingquantity(address account, uint index) public view returns (uint) {
        return getvestingscheduleentry(account, index)[quantity_index];
    }

    
    function getnextvestingindex(address account) public view returns (uint) {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account) public view returns (uint[2] memory) {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account) external view returns (uint) {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account) external view returns (uint) {
        return getnextvestingentry(account)[quantity_index];
    }

    

    
    function withdrawsynthetix(uint quantity) external onlyowner onlyduringsetup {
        ierc20(address(synthetix)).transfer(address(synthetix), quantity);
    }

    
    function purgeaccount(address account) external onlyowner onlyduringsetup {
        delete vestingschedules[account];
        totalvestedbalance = totalvestedbalance.sub(totalvestedaccountbalance[account]);
        delete totalvestedaccountbalance[account];
    }

    
    function appendvestingentry(
        address account,
        uint time,
        uint quantity
    ) public onlyowner onlyduringsetup {
        
        require(now < time, );
        require(quantity != 0, );

        
        totalvestedbalance = totalvestedbalance.add(quantity);
        require(
            totalvestedbalance <= ierc20(address(synthetix)).balanceof(address(this)),
            
        );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        if (schedulelength == 0) {
            totalvestedaccountbalance[account] = quantity;
        } else {
            
            require(
                getvestingtime(account, numvestingentries(account)  1) < time,
                
            );
            totalvestedaccountbalance[account] = totalvestedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);
    }

    
    function addvestingschedule(
        address account,
        uint[] calldata times,
        uint[] calldata quantities
    ) external onlyowner onlyduringsetup {
        for (uint i = 0; i < times.length; i++) {
            appendvestingentry(account, times[i], quantities[i]);
        }
    }

    
    function vest() external {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalvestedbalance = totalvestedbalance.sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].sub(total);
            ierc20(address(synthetix)).transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }

    

    event synthetixupdated(address newsynthetix);

    event vested(address indexed beneficiary, uint time, uint value);
}

pragma solidity ^0.5.16;


import ;
import ;


import ;


import ;
import ;
import ;



contract rewardescrow is owned, irewardescrow {
    using safemath for uint;

    
    isynthetix public synthetix;

    ifeepool public feepool;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalescrowedaccountbalance;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalescrowedbalance;

    uint internal constant time_index = 0;
    uint internal constant quantity_index = 1;

    
    uint public constant max_vesting_entries = 52 * 5;

    

    constructor(
        address _owner,
        isynthetix _synthetix,
        ifeepool _feepool
    ) public owned(_owner) {
        synthetix = _synthetix;
        feepool = _feepool;
    }

    

    
    function setsynthetix(isynthetix _synthetix) external onlyowner {
        synthetix = _synthetix;
        emit synthetixupdated(address(_synthetix));
    }

    
    function setfeepool(ifeepool _feepool) external onlyowner {
        feepool = _feepool;
        emit feepoolupdated(address(_feepool));
    }

    

    
    function balanceof(address account) public view returns (uint) {
        return totalescrowedaccountbalance[account];
    }

    function _numvestingentries(address account) internal view returns (uint) {
        return vestingschedules[account].length;
    }

    
    function numvestingentries(address account) external view returns (uint) {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index) public view returns (uint[2] memory) {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index) public view returns (uint) {
        return getvestingscheduleentry(account, index)[time_index];
    }

    
    function getvestingquantity(address account, uint index) public view returns (uint) {
        return getvestingscheduleentry(account, index)[quantity_index];
    }

    
    function getnextvestingindex(address account) public view returns (uint) {
        uint len = _numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account) public view returns (uint[2] memory) {
        uint index = getnextvestingindex(account);
        if (index == _numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account) external view returns (uint) {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account) external view returns (uint) {
        return getnextvestingentry(account)[quantity_index];
    }

    
    function checkaccountschedule(address account) public view returns (uint[520] memory) {
        uint[520] memory _result;
        uint schedules = _numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = getvestingscheduleentry(account, i);
            _result[i * 2] = pair[0];
            _result[i * 2 + 1] = pair[1];
        }
        return _result;
    }

    

    function _appendvestingentry(address account, uint quantity) internal {
        
        require(quantity != 0, );

        
        totalescrowedbalance = totalescrowedbalance.add(quantity);
        require(
            totalescrowedbalance <= ierc20(address(synthetix)).balanceof(address(this)),
            
        );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        
        uint time = now + 52 weeks;

        if (schedulelength == 0) {
            totalescrowedaccountbalance[account] = quantity;
        } else {
            
            require(
                getvestingtime(account, schedulelength  1) < time,
                
            );
            totalescrowedaccountbalance[account] = totalescrowedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);

        emit vestingentrycreated(account, now, quantity);
    }

    
    function appendvestingentry(address account, uint quantity) external onlyfeepool {
        _appendvestingentry(account, quantity);
    }

    
    function vest() external {
        uint numentries = _numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalescrowedbalance = totalescrowedbalance.sub(total);
            totalescrowedaccountbalance[msg.sender] = totalescrowedaccountbalance[msg.sender].sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].add(total);
            ierc20(address(synthetix)).transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }

    

    modifier onlyfeepool() {
        bool isfeepool = msg.sender == address(feepool);

        require(isfeepool, );
        _;
    }

    

    event synthetixupdated(address newsynthetix);

    event feepoolupdated(address newfeepool);

    event vested(address indexed beneficiary, uint time, uint value);

    event vestingentrycreated(address indexed beneficiary, uint time, uint value);
}

pragma solidity ^0.5.16;


import ;
import ;
import ;
import ;


import ;



contract synthetixstate is owned, state, limitedsetup, isynthetixstate {
    using safemath for uint;
    using safedecimalmath for uint;

    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    
    mapping(address => issuancedata) public issuancedata;

    
    uint public totalissuercount;

    
    uint[] public debtledger;

    
    
    uint public issuanceratio = safedecimalmath.unit() / 5;
    
    uint public constant max_issuance_ratio = 1e18;

    
    
    mapping(address => bytes4) public preferredcurrency;

    constructor(address _owner, address _associatedcontract)
        public
        owned(_owner)
        state(_associatedcontract)
        limitedsetup(1 weeks)
    {}

    

    
    function setcurrentissuancedata(address account, uint initialdebtownership) external onlyassociatedcontract {
        issuancedata[account].initialdebtownership = initialdebtownership;
        issuancedata[account].debtentryindex = debtledger.length;
    }

    
    function clearissuancedata(address account) external onlyassociatedcontract {
        delete issuancedata[account];
    }

    
    function incrementtotalissuercount() external onlyassociatedcontract {
        totalissuercount = totalissuercount.add(1);
    }

    
    function decrementtotalissuercount() external onlyassociatedcontract {
        totalissuercount = totalissuercount.sub(1);
    }

    
    function appenddebtledgervalue(uint value) external onlyassociatedcontract {
        debtledger.push(value);
    }

    
    function setpreferredcurrency(address account, bytes4 currencykey) external onlyassociatedcontract {
        preferredcurrency[account] = currencykey;
    }

    
    function setissuanceratio(uint _issuanceratio) external onlyowner {
        require(_issuanceratio <= max_issuance_ratio, );
        issuanceratio = _issuanceratio;
        emit issuanceratioupdated(_issuanceratio);
    }

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    
    
    
    
    

    

    
    function debtledgerlength() external view returns (uint) {
        return debtledger.length;
    }

    
    function lastdebtledgerentry() external view returns (uint) {
        return debtledger[debtledger.length  1];
    }

    
    function hasissued(address account) external view returns (bool) {
        return issuancedata[account].initialdebtownership > 0;
    }

    event issuanceratioupdated(uint newratio);
}

pragma solidity ^0.5.16;


import ;



library math {
    using safemath for uint;
    using safedecimalmath for uint;

    
    function powdecimal(uint x, uint n) internal pure returns (uint) {
        

        uint result = safedecimalmath.unit();
        while (n > 0) {
            if (n % 2 != 0) {
                result = result.multiplydecimal(x);
            }
            x = x.multiplydecimal(x);
            n /= 2;
        }
        return result;
    }
}

pragma solidity ^0.5.16;


import ;



contract multicollateralsynth is synth {
    bytes32 public multicollateralkey;

    

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        string memory _tokenname,
        string memory _tokensymbol,
        address _owner,
        bytes32 _currencykey,
        uint _totalsupply,
        address _resolver,
        bytes32 _multicollateralkey
    ) public synth(_proxy, _tokenstate, _tokenname, _tokensymbol, _owner, _currencykey, _totalsupply, _resolver) {
        multicollateralkey = _multicollateralkey;

        appendtoaddresscache(multicollateralkey);
    }

    

    function multicollateral() internal view returns (address) {
        return requireandgetaddress(multicollateralkey, );
    }

    

    
    function issue(address account, uint amount) external onlyinternalcontracts {
        super._internalissue(account, amount);
    }

    
    function burn(address account, uint amount) external onlyinternalcontracts {
        super._internalburn(account, amount);
    }

    

    
    modifier onlyinternalcontracts() {
        bool issynthetix = msg.sender == address(synthetix());
        bool isfeepool = msg.sender == address(feepool());
        bool isexchanger = msg.sender == address(exchanger());
        bool isissuer = msg.sender == address(issuer());
        bool ismulticollateral = msg.sender == address(multicollateral());

        require(
            issynthetix || isfeepool || isexchanger || isissuer || ismulticollateral,
            
        );
        _;
    }
}

pragma solidity ^0.5.16;


import ;



contract selfdestructible is owned {
    uint public constant selfdestruct_delay = 4 weeks;

    uint public initiationtime;
    bool public selfdestructinitiated;

    address public selfdestructbeneficiary;

    constructor() internal {
        
        require(owner != address(0), );
        selfdestructbeneficiary = owner;
        emit selfdestructbeneficiaryupdated(owner);
    }

    
    function setselfdestructbeneficiary(address payable _beneficiary) external onlyowner {
        require(_beneficiary != address(0), );
        selfdestructbeneficiary = _beneficiary;
        emit selfdestructbeneficiaryupdated(_beneficiary);
    }

    
    function initiateselfdestruct() external onlyowner {
        initiationtime = now;
        selfdestructinitiated = true;
        emit selfdestructinitiated(selfdestruct_delay);
    }

    
    function terminateselfdestruct() external onlyowner {
        initiationtime = 0;
        selfdestructinitiated = false;
        emit selfdestructterminated();
    }

    
    function selfdestruct() external onlyowner {
        require(selfdestructinitiated, );
        require(initiationtime + selfdestruct_delay < now, );
        emit selfdestructed(selfdestructbeneficiary);
        selfdestruct(address(uint160(selfdestructbeneficiary)));
    }

    event selfdestructterminated();
    event selfdestructed(address beneficiary);
    event selfdestructinitiated(uint selfdestructdelay);
    event selfdestructbeneficiaryupdated(address newbeneficiary);
}

pragma solidity ^0.5.16;


import ;



contract rewardsdistributionrecipient is owned {
    address public rewardsdistribution;

    function notifyrewardamount(uint256 reward) external;

    modifier onlyrewardsdistribution() {
        require(msg.sender == rewardsdistribution, );
        _;
    }

    function setrewardsdistribution(address _rewardsdistribution) external onlyowner {
        rewardsdistribution = _rewardsdistribution;
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;


import ;



contract feepoolstate is owned, selfdestructible, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    

    uint8 public constant fee_period_length = 6;

    address public feepool;

    
    struct issuancedata {
        uint debtpercentage;
        uint debtentryindex;
    }

    
    mapping(address => issuancedata[fee_period_length]) public accountissuanceledger;

    constructor(address _owner, ifeepool _feepool) public owned(_owner) selfdestructible() limitedsetup(6 weeks) {
        feepool = address(_feepool);
    }

    

    
    function setfeepool(ifeepool _feepool) external onlyowner {
        feepool = address(_feepool);
    }

    

    
    function getaccountsdebtentry(address account, uint index)
        public
        view
        returns (uint debtpercentage, uint debtentryindex)
    {
        require(index < fee_period_length, );

        debtpercentage = accountissuanceledger[account][index].debtpercentage;
        debtentryindex = accountissuanceledger[account][index].debtentryindex;
    }

    
    function applicableissuancedata(address account, uint closingdebtindex) external view returns (uint, uint) {
        issuancedata[fee_period_length] memory issuancedata = accountissuanceledger[account];

        
        
        for (uint i = 0; i < fee_period_length; i++) {
            if (closingdebtindex >= issuancedata[i].debtentryindex) {
                return (issuancedata[i].debtpercentage, issuancedata[i].debtentryindex);
            }
        }
    }

    

    
    function appendaccountissuancerecord(
        address account,
        uint debtratio,
        uint debtentryindex,
        uint currentperiodstartdebtindex
    ) external onlyfeepool {
        
        if (accountissuanceledger[account][0].debtentryindex < currentperiodstartdebtindex) {
            
            issuancedataindexorder(account);
        }

        
        accountissuanceledger[account][0].debtpercentage = debtratio;
        accountissuanceledger[account][0].debtentryindex = debtentryindex;
    }

    
    function issuancedataindexorder(address account) private {
        for (uint i = fee_period_length  2; i < fee_period_length; i) {
            uint next = i + 1;
            accountissuanceledger[account][next].debtpercentage = accountissuanceledger[account][i].debtpercentage;
            accountissuanceledger[account][next].debtentryindex = accountissuanceledger[account][i].debtentryindex;
        }
    }

    
    function importissuerdata(
        address[] calldata accounts,
        uint[] calldata ratios,
        uint periodtoinsert,
        uint feeperiodcloseindex
    ) external onlyowner onlyduringsetup {
        require(accounts.length == ratios.length, );

        for (uint i = 0; i < accounts.length; i++) {
            accountissuanceledger[accounts[i]][periodtoinsert].debtpercentage = ratios[i];
            accountissuanceledger[accounts[i]][periodtoinsert].debtentryindex = feeperiodcloseindex;
            emit issuancedebtratioentry(accounts[i], ratios[i], feeperiodcloseindex);
        }
    }

    

    modifier onlyfeepool {
        require(msg.sender == address(feepool), );
        _;
    }

    
    event issuancedebtratioentry(address indexed account, uint debtratio, uint feeperiodcloseindex);
}

pragma solidity ^0.5.16;


import ;


import ;
import ;


import ;
import ;
import ;



contract supplyschedule is owned {
    using safemath for uint;
    using safedecimalmath for uint;
    using math for uint;

    
    uint public lastmintevent;

    
    uint public weekcounter;

    
    uint public minterreward = 200 * safedecimalmath.unit();

    
    
    uint public constant initial_weekly_supply = 1442307692307692307692307;

    
    address payable public synthetixproxy;

    
    uint public constant max_minter_reward = 200 * 1e18;

    
    uint public constant mint_period_duration = 1 weeks;

    uint public constant inflation_start_date = 1551830400; 
    uint public constant mint_buffer = 1 days;
    uint8 public constant supply_decay_start = 40; 
    uint8 public constant supply_decay_end = 234; 

    
    uint public constant decay_rate = 12500000000000000; 

    
    uint public constant terminal_supply_rate_annual = 25000000000000000; 

    constructor(
        address _owner,
        uint _lastmintevent,
        uint _currentweek
    ) public owned(_owner) {
        lastmintevent = _lastmintevent;
        weekcounter = _currentweek;
    }

    

    
    function mintablesupply() external view returns (uint) {
        uint totalamount;

        if (!ismintable()) {
            return totalamount;
        }

        uint remainingweekstomint = weekssincelastissuance();

        uint currentweek = weekcounter;

        
        
        while (remainingweekstomint > 0) {
            currentweek++;

            if (currentweek < supply_decay_start) {
                
                totalamount = totalamount.add(initial_weekly_supply);
                remainingweekstomint;
            } else if (currentweek <= supply_decay_end) {
                
                
                uint decaycount = currentweek.sub(supply_decay_start  1);

                totalamount = totalamount.add(tokendecaysupplyforweek(decaycount));
                remainingweekstomint;
            } else {
                
                
                uint totalsupply = ierc20(synthetixproxy).totalsupply();
                uint currenttotalsupply = totalsupply.add(totalamount);

                totalamount = totalamount.add(terminalinflationsupply(currenttotalsupply, remainingweekstomint));
                remainingweekstomint = 0;
            }
        }

        return totalamount;
    }

    
    function tokendecaysupplyforweek(uint counter) public pure returns (uint) {
        
        
        uint effectivedecay = (safedecimalmath.unit().sub(decay_rate)).powdecimal(counter);
        uint supplyforweek = initial_weekly_supply.multiplydecimal(effectivedecay);

        return supplyforweek;
    }

    
    function terminalinflationsupply(uint totalsupply, uint numofweeks) public pure returns (uint) {
        
        uint effectivecompoundrate = safedecimalmath.unit().add(terminal_supply_rate_annual.div(52)).powdecimal(numofweeks);

        
        return totalsupply.multiplydecimal(effectivecompoundrate.sub(safedecimalmath.unit()));
    }

    
    function weekssincelastissuance() public view returns (uint) {
        
        
        uint timediff = lastmintevent > 0 ? now.sub(lastmintevent) : now.sub(inflation_start_date);
        return timediff.div(mint_period_duration);
    }

    
    function ismintable() public view returns (bool) {
        if (now  lastmintevent > mint_period_duration) {
            return true;
        }
        return false;
    }

    

    
    function recordmintevent(uint supplyminted) external onlysynthetix returns (bool) {
        uint numberofweeksissued = weekssincelastissuance();

        
        weekcounter = weekcounter.add(numberofweeksissued);

        
        
        lastmintevent = inflation_start_date.add(weekcounter.mul(mint_period_duration)).add(mint_buffer);

        emit supplyminted(supplyminted, numberofweeksissued, lastmintevent, now);
        return true;
    }

    
    function setminterreward(uint amount) external onlyowner {
        require(amount <= max_minter_reward, );
        minterreward = amount;
        emit minterrewardupdated(minterreward);
    }

    

    
    function setsynthetixproxy(isynthetix _synthetixproxy) external onlyowner {
        require(address(_synthetixproxy) != address(0), );
        synthetixproxy = address(uint160(address(_synthetixproxy)));
        emit synthetixproxyupdated(synthetixproxy);
    }

    

    
    modifier onlysynthetix() {
        require(
            msg.sender == address(proxy(address(synthetixproxy)).target()),
            
        );
        _;
    }

    
    
    event supplyminted(uint supplyminted, uint numberofweeksissued, uint lastmintevent, uint timestamp);

    
    event minterrewardupdated(uint newrewardamount);

    
    event synthetixproxyupdated(address newaddress);
}

pragma solidity ^0.5.16;


import ;


import ;



contract mixinresolver is owned {
    addressresolver public resolver;

    mapping(bytes32 => address) private addresscache;

    bytes32[] public resolveraddressesrequired;

    uint public constant max_addresses_from_resolver = 24;

    constructor(address _resolver, bytes32[max_addresses_from_resolver] memory _addressestocache) internal {
        
        require(owner != address(0), );

        for (uint i = 0; i < _addressestocache.length; i++) {
            if (_addressestocache[i] != bytes32(0)) {
                resolveraddressesrequired.push(_addressestocache[i]);
            } else {
                
                
                break;
            }
        }
        resolver = addressresolver(_resolver);
        
    }

    
    function setresolverandsynccache(addressresolver _resolver) external onlyowner {
        resolver = _resolver;

        for (uint i = 0; i < resolveraddressesrequired.length; i++) {
            bytes32 name = resolveraddressesrequired[i];
            
            addresscache[name] = resolver.requireandgetaddress(name, );
        }
    }

    

    function requireandgetaddress(bytes32 name, string memory reason) internal view returns (address) {
        address _foundaddress = addresscache[name];
        require(_foundaddress != address(0), reason);
        return _foundaddress;
    }

    
    
    function isresolvercached(addressresolver _resolver) external view returns (bool) {
        if (resolver != _resolver) {
            return false;
        }

        
        for (uint i = 0; i < resolveraddressesrequired.length; i++) {
            bytes32 name = resolveraddressesrequired[i];
            
            if (resolver.getaddress(name) != addresscache[name] || addresscache[name] == address(0)) {
                return false;
            }
        }

        return true;
    }

    
    function getresolveraddressesrequired()
        external
        view
        returns (bytes32[max_addresses_from_resolver] memory addressesrequired)
    {
        for (uint i = 0; i < resolveraddressesrequired.length; i++) {
            addressesrequired[i] = resolveraddressesrequired[i];
        }
    }

    
    function appendtoaddresscache(bytes32 name) internal {
        resolveraddressesrequired.push(name);
        require(resolveraddressesrequired.length < max_addresses_from_resolver, );
        
        
        addresscache[name] = resolver.getaddress(name);
    }
}

pragma solidity ^0.5.16;


interface isynthetixescrow {
    function numvestingentries(address account) external view returns (uint);

    function getvestingscheduleentry(address account, uint index) external view returns (uint[2] memory);
}



contract escrowchecker {
    isynthetixescrow public synthetix_escrow;

    constructor(isynthetixescrow _esc) public {
        synthetix_escrow = _esc;
    }

    function checkaccountschedule(address account) public view returns (uint[16] memory) {
        uint[16] memory _result;
        uint schedules = synthetix_escrow.numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = synthetix_escrow.getvestingscheduleentry(account, i);
            _result[i * 2] = pair[0];
            _result[i * 2 + 1] = pair[1];
        }
        return _result;
    }
}

pragma solidity ^0.5.16;


import ;



contract pausable is owned {
    uint public lastpausetime;
    bool public paused;

    constructor() internal {
        
        require(owner != address(0), );
        
    }

    
    function setpaused(bool _paused) external onlyowner {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;

        
        if (paused) {
            lastpausetime = now;
        }

        
        emit pausechanged(paused);
    }

    event pausechanged(bool ispaused);

    modifier notpaused {
        require(!paused, );
        _;
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;


import ;
import ;
import ;
import ;
import ;
import ;



contract issuer is owned, mixinresolver, iissuer {
    using safemath for uint;
    using safedecimalmath for uint;

    bytes32 private constant susd = ;
    bytes32 public constant last_issue_event = ;

    
    uint public constant max_minimum_staking_time = 1 weeks;

    uint public minimumstaketime = 24 hours; 

    

    bytes32 private constant contract_synthetix = ;
    bytes32 private constant contract_exchanger = ;
    bytes32 private constant contract_synthetixstate = ;
    bytes32 private constant contract_feepool = ;
    bytes32 private constant contract_delegateapprovals = ;
    bytes32 private constant contract_issuanceeternalstorage = ;

    bytes32[24] private addressestocache = [
        contract_synthetix,
        contract_exchanger,
        contract_synthetixstate,
        contract_feepool,
        contract_delegateapprovals,
        contract_issuanceeternalstorage
    ];

    constructor(address _owner, address _resolver) public owned(_owner) mixinresolver(_resolver, addressestocache) {}

    
    function synthetix() internal view returns (isynthetix) {
        return isynthetix(requireandgetaddress(contract_synthetix, ));
    }

    function exchanger() internal view returns (iexchanger) {
        return iexchanger(requireandgetaddress(contract_exchanger, ));
    }

    function synthetixstate() internal view returns (isynthetixstate) {
        return isynthetixstate(requireandgetaddress(contract_synthetixstate, ));
    }

    function feepool() internal view returns (ifeepool) {
        return ifeepool(requireandgetaddress(contract_feepool, ));
    }

    function delegateapprovals() internal view returns (idelegateapprovals) {
        return idelegateapprovals(requireandgetaddress(contract_delegateapprovals, ));
    }

    function issuanceeternalstorage() internal view returns (issuanceeternalstorage) {
        return
            issuanceeternalstorage(
                requireandgetaddress(contract_issuanceeternalstorage, )
            );
    }

    

    function canburnsynths(address account) public view returns (bool) {
        return now >= lastissueevent(account).add(minimumstaketime);
    }

    function lastissueevent(address account) public view returns (uint) {
        
        return issuanceeternalstorage().getuintvalue(keccak256(abi.encodepacked(last_issue_event, account)));
    }

    

    function setminimumstaketime(uint _seconds) external onlyowner {
        
        require(_seconds <= max_minimum_staking_time, );
        minimumstaketime = _seconds;
        emit minimumstaketimeupdated(minimumstaketime);
    }

    
    function _setlastissueevent(address account) internal {
        
        issuanceeternalstorage().setuintvalue(keccak256(abi.encodepacked(last_issue_event, account)), block.timestamp);
    }

    function issuesynthsonbehalf(
        address issueforaddress,
        address from,
        uint amount
    ) external onlysynthetix {
        require(delegateapprovals().canissuefor(issueforaddress, from), );

        (uint maxissuable, uint existingdebt, uint totalsystemdebt) = synthetix().remainingissuablesynths(issueforaddress);
        require(amount <= maxissuable, );
        _internalissuesynths(issueforaddress, amount, existingdebt, totalsystemdebt);
    }

    function issuemaxsynthsonbehalf(address issueforaddress, address from) external onlysynthetix {
        require(delegateapprovals().canissuefor(issueforaddress, from), );

        (uint maxissuable, uint existingdebt, uint totalsystemdebt) = synthetix().remainingissuablesynths(issueforaddress);
        _internalissuesynths(issueforaddress, maxissuable, existingdebt, totalsystemdebt);
    }

    function issuesynths(address from, uint amount) external onlysynthetix {
        
        (uint maxissuable, uint existingdebt, uint totalsystemdebt) = synthetix().remainingissuablesynths(from);
        require(amount <= maxissuable, );

        _internalissuesynths(from, amount, existingdebt, totalsystemdebt);
    }

    function issuemaxsynths(address from) external onlysynthetix {
        
        (uint maxissuable, uint existingdebt, uint totalsystemdebt) = synthetix().remainingissuablesynths(from);

        _internalissuesynths(from, maxissuable, existingdebt, totalsystemdebt);
    }

    
    function _internalissuesynths(
        address from,
        uint amount,
        uint existingdebt,
        uint totalsystemdebt
    ) internal {
        
        _addtodebtregister(from, amount, existingdebt, totalsystemdebt);

        
        _setlastissueevent(from);

        
        synthetix().synths(susd).issue(from, amount);

        
        _appendaccountissuancerecord(from);
    }

    function burnsynthsonbehalf(
        address burnforaddress,
        address from,
        uint amount
    ) external onlysynthetix {
        require(delegateapprovals().canburnfor(burnforaddress, from), );
        _burnsynths(burnforaddress, amount);
    }

    function burnsynths(address from, uint amount) external onlysynthetix {
        _burnsynths(from, amount);
    }

    
    function _burnsynths(address from, uint amount) internal {
        require(canburnsynths(from), );

        
        (, uint refunded, uint numentriessettled) = exchanger().settle(from, susd);

        
        (uint existingdebt, uint totalsystemvalue) = synthetix().debtbalanceofandtotaldebt(from, susd);

        require(existingdebt > 0, );

        uint debttoremoveaftersettlement = amount;

        if (numentriessettled > 0) {
            debttoremoveaftersettlement = exchanger().calculateamountaftersettlement(from, susd, amount, refunded);
        }

        _internalburnsynths(from, debttoremoveaftersettlement, existingdebt, totalsystemvalue);
    }

    function burnsynthstotargetonbehalf(address burnforaddress, address from) external onlysynthetix {
        require(delegateapprovals().canburnfor(burnforaddress, from), );
        _burnsynthstotarget(burnforaddress);
    }

    function burnsynthstotarget(address from) external onlysynthetix {
        _burnsynthstotarget(from);
    }

    
    
    function _burnsynthstotarget(address from) internal {
        
        (uint existingdebt, uint totalsystemvalue) = synthetix().debtbalanceofandtotaldebt(from, susd);

        require(existingdebt > 0, );

        
        uint maxissuable = synthetix().maxissuablesynths(from);

        
        uint amounttoburntotarget = existingdebt.sub(maxissuable);

        
        _internalburnsynths(from, amounttoburntotarget, existingdebt, totalsystemvalue);
    }

    
    function _internalburnsynths(
        address from,
        uint amount,
        uint existingdebt,
        uint totalsystemvalue
    ) internal {
        
        
        uint amounttoremove = existingdebt < amount ? existingdebt : amount;

        
        _removefromdebtregister(from, amounttoremove, existingdebt, totalsystemvalue);

        uint amounttoburn = amounttoremove;

        
        synthetix().synths(susd).burn(from, amounttoburn);

        
        _appendaccountissuancerecord(from);
    }

    

    
    function _appendaccountissuancerecord(address from) internal {
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetixstate().issuancedata(from);

        feepool().appendaccountissuancerecord(from, initialdebtownership, debtentryindex);
    }

    
    function _addtodebtregister(
        address from,
        uint amount,
        uint existingdebt,
        uint totaldebtissued
    ) internal {
        isynthetixstate state = synthetixstate();

        
        uint newtotaldebtissued = amount.add(totaldebtissued);

        
        uint debtpercentage = amount.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        
        if (existingdebt > 0) {
            debtpercentage = amount.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (existingdebt == 0) {
            state.incrementtotalissuercount();
        }

        
        state.setcurrentissuancedata(from, debtpercentage);

        
        
        if (state.debtledgerlength() > 0) {
            state.appenddebtledgervalue(state.lastdebtledgerentry().multiplydecimalroundprecise(delta));
        } else {
            state.appenddebtledgervalue(safedecimalmath.preciseunit());
        }
    }

    
    function _removefromdebtregister(
        address from,
        uint amount,
        uint existingdebt,
        uint totaldebtissued
    ) internal {
        isynthetixstate state = synthetixstate();

        uint debttoremove = amount;

        
        uint newtotaldebtissued = totaldebtissued.sub(debttoremove);

        uint delta = 0;

        
        
        if (newtotaldebtissued > 0) {
            
            uint debtpercentage = debttoremove.dividedecimalroundprecise(newtotaldebtissued);

            
            
            
            delta = safedecimalmath.preciseunit().add(debtpercentage);
        }

        
        if (debttoremove == existingdebt) {
            state.setcurrentissuancedata(from, 0);
            state.decrementtotalissuercount();
        } else {
            
            uint newdebt = existingdebt.sub(debttoremove);
            uint newdebtpercentage = newdebt.dividedecimalroundprecise(newtotaldebtissued);

            
            state.setcurrentissuancedata(from, newdebtpercentage);
        }

        
        state.appenddebtledgervalue(state.lastdebtledgerentry().multiplydecimalroundprecise(delta));
    }

    

    modifier onlysynthetix() {
        require(msg.sender == address(synthetix()), );
        _;
    }

    

    event minimumstaketimeupdated(uint minimumstaketime);
}

pragma solidity ^0.5.16;


import ;



library safedecimalmath {
    using safemath for uint;

    
    uint8 public constant decimals = 18;
    uint8 public constant highprecisiondecimals = 27;

    
    uint public constant unit = 10**uint(decimals);

    
    uint public constant precise_unit = 10**uint(highprecisiondecimals);
    uint private constant unit_to_high_precision_conversion_factor = 10**uint(highprecisiondecimals  decimals);

    
    function unit() external pure returns (uint) {
        return unit;
    }

    
    function preciseunit() external pure returns (uint) {
        return precise_unit;
    }

    
    function multiplydecimal(uint x, uint y) internal pure returns (uint) {
        
        return x.mul(y) / unit;
    }

    
    function _multiplydecimalround(
        uint x,
        uint y,
        uint precisionunit
    ) private pure returns (uint) {
        
        uint quotienttimesten = x.mul(y) / (precisionunit / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

    
    function multiplydecimalroundprecise(uint x, uint y) internal pure returns (uint) {
        return _multiplydecimalround(x, y, precise_unit);
    }

    
    function multiplydecimalround(uint x, uint y) internal pure returns (uint) {
        return _multiplydecimalround(x, y, unit);
    }

    
    function dividedecimal(uint x, uint y) internal pure returns (uint) {
        
        return x.mul(unit).div(y);
    }

    
    function _dividedecimalround(
        uint x,
        uint y,
        uint precisionunit
    ) private pure returns (uint) {
        uint resulttimesten = x.mul(precisionunit * 10).div(y);

        if (resulttimesten % 10 >= 5) {
            resulttimesten += 10;
        }

        return resulttimesten / 10;
    }

    
    function dividedecimalround(uint x, uint y) internal pure returns (uint) {
        return _dividedecimalround(x, y, unit);
    }

    
    function dividedecimalroundprecise(uint x, uint y) internal pure returns (uint) {
        return _dividedecimalround(x, y, precise_unit);
    }

    
    function decimaltoprecisedecimal(uint i) internal pure returns (uint) {
        return i.mul(unit_to_high_precision_conversion_factor);
    }

    
    function precisedecimaltodecimal(uint i) internal pure returns (uint) {
        uint quotienttimesten = i / (unit_to_high_precision_conversion_factor / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }
}

pragma solidity ^0.5.16;


import ;


import ;



contract proxy is owned {
    proxyable public target;
    bool public usedelegatecall;

    constructor(address _owner) public owned(_owner) {}

    function settarget(proxyable _target) external onlyowner {
        target = _target;
        emit targetupdated(_target);
    }

    function setusedelegatecall(bool value) external onlyowner {
        usedelegatecall = value;
    }

    function _emit(
        bytes calldata calldata,
        uint numtopics,
        bytes32 topic1,
        bytes32 topic2,
        bytes32 topic3,
        bytes32 topic4
    ) external onlytarget {
        uint size = calldata.length;
        bytes memory _calldata = calldata;

        assembly {
            
            switch numtopics
                case 0 {
                    log0(add(_calldata, 32), size)
                }
                case 1 {
                    log1(add(_calldata, 32), size, topic1)
                }
                case 2 {
                    log2(add(_calldata, 32), size, topic1, topic2)
                }
                case 3 {
                    log3(add(_calldata, 32), size, topic1, topic2, topic3)
                }
                case 4 {
                    log4(add(_calldata, 32), size, topic1, topic2, topic3, topic4)
                }
        }
    }

    function() external payable {
        if (usedelegatecall) {
            assembly {
                
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                
                if iszero(result) {
                    revert(free_ptr, returndatasize)
                }
                return(free_ptr, returndatasize)
            }
        } else {
            
            target.setmessagesender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) {
                    revert(free_ptr, returndatasize)
                }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlytarget {
        require(proxyable(msg.sender) == target, );
        _;
    }

    event targetupdated(proxyable newtarget);
}

pragma solidity ^0.5.16;



contract limitedsetup {
    uint public setupexpirytime;

    
    constructor(uint setupduration) internal {
        setupexpirytime = now + setupduration;
    }

    modifier onlyduringsetup {
        require(now < setupexpirytime, );
        _;
    }
}

pragma solidity ^0.5.16;


import ;





contract issuanceeternalstorage is eternalstorage {
    constructor(address _owner, address _issuer) public eternalstorage(_owner, _issuer) {}
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;



import ;



contract exchangerates is owned, selfdestructible, iexchangerates {
    using safemath for uint;
    using safedecimalmath for uint;

    struct rateandupdatedtime {
        uint216 rate;
        uint40 time;
    }

    
    mapping(bytes32 => mapping(uint => rateandupdatedtime)) private _rates;

    
    address public oracle;

    
    mapping(bytes32 => aggregatorinterface) public aggregators;

    
    bytes32[] public aggregatorkeys;

    
    uint private constant oracle_future_limit = 10 minutes;

    
    uint public ratestaleperiod = 3 hours;

    
    struct inversepricing {
        uint entrypoint;
        uint upperlimit;
        uint lowerlimit;
        bool frozen;
    }
    mapping(bytes32 => inversepricing) public inversepricing;
    bytes32[] public invertedkeys;

    mapping(bytes32 => uint) public currentroundforrate;

    

    constructor(
        address _owner,
        address _oracle,
        bytes32[] memory _currencykeys,
        uint[] memory _newrates
    ) public owned(_owner) selfdestructible() {
        require(_currencykeys.length == _newrates.length, );

        oracle = _oracle;

        
        _setrate(, safedecimalmath.unit(), now);

        internalupdaterates(_currencykeys, _newrates, now);
    }

    

    function setoracle(address _oracle) external onlyowner {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    function setratestaleperiod(uint _time) external onlyowner {
        ratestaleperiod = _time;
        emit ratestaleperiodupdated(ratestaleperiod);
    }

    

    
    function updaterates(
        bytes32[] calldata currencykeys,
        uint[] calldata newrates,
        uint timesent
    ) external onlyoracle returns (bool) {
        return internalupdaterates(currencykeys, newrates, timesent);
    }

    
    function deleterate(bytes32 currencykey) external onlyoracle {
        require(getrate(currencykey) > 0, );

        delete _rates[currencykey][currentroundforrate[currencykey]];

        currentroundforrate[currencykey];

        emit ratedeleted(currencykey);
    }

    
    function setinversepricing(
        bytes32 currencykey,
        uint entrypoint,
        uint upperlimit,
        uint lowerlimit,
        bool freeze,
        bool freezeatupperlimit
    ) external onlyowner {
        require(entrypoint > 0, );
        require(lowerlimit > 0, );
        require(upperlimit > entrypoint, );
        require(upperlimit < entrypoint.mul(2), );
        require(lowerlimit < entrypoint, );

        if (inversepricing[currencykey].entrypoint <= 0) {
            
            invertedkeys.push(currencykey);
        }
        inversepricing[currencykey].entrypoint = entrypoint;
        inversepricing[currencykey].upperlimit = upperlimit;
        inversepricing[currencykey].lowerlimit = lowerlimit;
        inversepricing[currencykey].frozen = freeze;

        emit inversepriceconfigured(currencykey, entrypoint, upperlimit, lowerlimit);

        
        
        
        if (freeze) {
            emit inversepricefrozen(currencykey);

            _setrate(currencykey, freezeatupperlimit ? upperlimit : lowerlimit, now);
        }
    }

    
    function removeinversepricing(bytes32 currencykey) external onlyowner {
        require(inversepricing[currencykey].entrypoint > 0, );

        inversepricing[currencykey].entrypoint = 0;
        inversepricing[currencykey].upperlimit = 0;
        inversepricing[currencykey].lowerlimit = 0;
        inversepricing[currencykey].frozen = false;

        
        bool wasremoved = removefromarray(currencykey, invertedkeys);

        if (wasremoved) {
            emit inversepriceconfigured(currencykey, 0, 0, 0);
        }
    }

    
    function addaggregator(bytes32 currencykey, address aggregatoraddress) external onlyowner {
        aggregatorinterface aggregator = aggregatorinterface(aggregatoraddress);
        require(aggregator.latesttimestamp() >= 0, );
        if (address(aggregators[currencykey]) == address(0)) {
            aggregatorkeys.push(currencykey);
        }
        aggregators[currencykey] = aggregator;
        emit aggregatoradded(currencykey, address(aggregator));
    }

    
    function removeaggregator(bytes32 currencykey) external onlyowner {
        address aggregator = address(aggregators[currencykey]);
        require(aggregator != address(0), );
        delete aggregators[currencykey];

        bool wasremoved = removefromarray(currencykey, aggregatorkeys);

        if (wasremoved) {
            emit aggregatorremoved(currencykey, aggregator);
        }
    }

    function getlastroundidbeforeelapsedsecs(
        bytes32 currencykey,
        uint startingroundid,
        uint startingtimestamp,
        uint timediff
    ) external view returns (uint) {
        uint roundid = startingroundid;
        uint nexttimestamp = 0;
        while (true) {
            (, nexttimestamp) = getrateandtimestampatround(currencykey, roundid + 1);
            
            if (nexttimestamp == 0 || nexttimestamp > startingtimestamp + timediff) {
                return roundid;
            }
            roundid++;
        }
        return roundid;
    }

    function getcurrentroundid(bytes32 currencykey) external view returns (uint) {
        if (address(aggregators[currencykey]) != address(0)) {
            aggregatorinterface aggregator = aggregators[currencykey];
            return aggregator.latestround();
        } else {
            return currentroundforrate[currencykey];
        }
    }

    function effectivevalueatround(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        uint roundidforsrc,
        uint roundidfordest
    ) external view ratenotstale(sourcecurrencykey) ratenotstale(destinationcurrencykey) returns (uint) {
        
        if (sourcecurrencykey == destinationcurrencykey) return sourceamount;

        (uint srcrate, ) = getrateandtimestampatround(sourcecurrencykey, roundidforsrc);
        (uint destrate, ) = getrateandtimestampatround(destinationcurrencykey, roundidfordest);
        
        return sourceamount.multiplydecimalround(srcrate).dividedecimalround(destrate);
    }

    function rateandtimestampatround(bytes32 currencykey, uint roundid) external view returns (uint rate, uint time) {
        return getrateandtimestampatround(currencykey, roundid);
    }

    

    
    function lastrateupdatetimes(bytes32 currencykey) public view returns (uint256) {
        return getrateandupdatedtime(currencykey).time;
    }

    
    function lastrateupdatetimesforcurrencies(bytes32[] memory currencykeys) public view returns (uint[] memory) {
        uint[] memory lastupdatetimes = new uint[](currencykeys.length);

        for (uint i = 0; i < currencykeys.length; i++) {
            lastupdatetimes[i] = lastrateupdatetimes(currencykeys[i]);
        }

        return lastupdatetimes;
    }

    
    function effectivevalue(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) public view ratenotstale(sourcecurrencykey) ratenotstale(destinationcurrencykey) returns (uint) {
        
        if (sourcecurrencykey == destinationcurrencykey) return sourceamount;

        
        return
            sourceamount.multiplydecimalround(getrate(sourcecurrencykey)).dividedecimalround(
                getrate(destinationcurrencykey)
            );
    }

    
    function rateforcurrency(bytes32 currencykey) external view returns (uint) {
        return getrateandupdatedtime(currencykey).rate;
    }

    
    function ratesforcurrencies(bytes32[] calldata currencykeys) external view returns (uint[] memory) {
        uint[] memory _localrates = new uint[](currencykeys.length);

        for (uint i = 0; i < currencykeys.length; i++) {
            _localrates[i] = getrate(currencykeys[i]);
        }

        return _localrates;
    }

    
    function ratesandstaleforcurrencies(bytes32[] calldata currencykeys) external view returns (uint[] memory, bool) {
        uint[] memory _localrates = new uint[](currencykeys.length);

        bool anyratestale = false;
        uint period = ratestaleperiod;
        for (uint i = 0; i < currencykeys.length; i++) {
            rateandupdatedtime memory rateandupdatetime = getrateandupdatedtime(currencykeys[i]);
            _localrates[i] = uint256(rateandupdatetime.rate);
            if (!anyratestale) {
                anyratestale = (currencykeys[i] !=  && uint256(rateandupdatetime.time).add(period) < now);
            }
        }

        return (_localrates, anyratestale);
    }

    
    function rateisstale(bytes32 currencykey) public view returns (bool) {
        
        if (currencykey == ) return false;

        return lastrateupdatetimes(currencykey).add(ratestaleperiod) < now;
    }

    
    function rateisfrozen(bytes32 currencykey) external view returns (bool) {
        return inversepricing[currencykey].frozen;
    }

    
    function anyrateisstale(bytes32[] calldata currencykeys) external view returns (bool) {
        
        uint256 i = 0;

        while (i < currencykeys.length) {
            
            if (currencykeys[i] !=  && lastrateupdatetimes(currencykeys[i]).add(ratestaleperiod) < now) {
                return true;
            }
            i += 1;
        }

        return false;
    }

    

    function _setrate(
        bytes32 currencykey,
        uint256 rate,
        uint256 time
    ) internal {
        
        currentroundforrate[currencykey]++;

        _rates[currencykey][currentroundforrate[currencykey]] = rateandupdatedtime({
            rate: uint216(rate),
            time: uint40(time)
        });
    }

    
    function internalupdaterates(
        bytes32[] memory currencykeys,
        uint[] memory newrates,
        uint timesent
    ) internal returns (bool) {
        require(currencykeys.length == newrates.length, );
        require(timesent < (now + oracle_future_limit), );

        
        for (uint i = 0; i < currencykeys.length; i++) {
            bytes32 currencykey = currencykeys[i];

            
            
            
            require(newrates[i] != 0, );
            require(currencykey != , );

            
            if (timesent < lastrateupdatetimes(currencykey)) {
                continue;
            }

            newrates[i] = rateorinverted(currencykey, newrates[i]);

            
            _setrate(currencykey, newrates[i], timesent);
        }

        emit ratesupdated(currencykeys, newrates);

        return true;
    }

    
    function rateorinverted(bytes32 currencykey, uint rate) internal returns (uint) {
        
        inversepricing storage inverse = inversepricing[currencykey];
        if (inverse.entrypoint <= 0) {
            return rate;
        }

        
        uint newinverserate = getrate(currencykey);

        
        if (!inverse.frozen) {
            uint doubleentrypoint = inverse.entrypoint.mul(2);
            if (doubleentrypoint <= rate) {
                
                
                
                newinverserate = 0;
            } else {
                newinverserate = doubleentrypoint.sub(rate);
            }

            
            if (newinverserate >= inverse.upperlimit) {
                newinverserate = inverse.upperlimit;
            } else if (newinverserate <= inverse.lowerlimit) {
                newinverserate = inverse.lowerlimit;
            }

            if (newinverserate == inverse.upperlimit || newinverserate == inverse.lowerlimit) {
                inverse.frozen = true;
                emit inversepricefrozen(currencykey);
            }
        }

        return newinverserate;
    }

    function getrateandupdatedtime(bytes32 currencykey) internal view returns (rateandupdatedtime memory) {
        if (address(aggregators[currencykey]) != address(0)) {
            return
                rateandupdatedtime({
                    rate: uint216(aggregators[currencykey].latestanswer() * 1e10),
                    time: uint40(aggregators[currencykey].latesttimestamp())
                });
        } else {
            return _rates[currencykey][currentroundforrate[currencykey]];
        }
    }

    
    function removefromarray(bytes32 entry, bytes32[] storage array) internal returns (bool) {
        for (uint i = 0; i < array.length; i++) {
            if (array[i] == entry) {
                delete array[i];

                
                
                
                array[i] = array[array.length  1];

                
                array.length;

                return true;
            }
        }
        return false;
    }

    function getrateandtimestampatround(bytes32 currencykey, uint roundid) internal view returns (uint rate, uint time) {
        if (address(aggregators[currencykey]) != address(0)) {
            aggregatorinterface aggregator = aggregators[currencykey];
            return (uint(aggregator.getanswer(roundid) * 1e10), aggregator.gettimestamp(roundid));
        } else {
            rateandupdatedtime storage update = _rates[currencykey][roundid];
            return (update.rate, update.time);
        }
    }

    function getrate(bytes32 currencykey) internal view returns (uint256) {
        return getrateandupdatedtime(currencykey).rate;
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!rateisstale(currencykey), );
        _;
    }

    modifier onlyoracle {
        require(msg.sender == oracle, );
        _;
    }

    

    event oracleupdated(address neworacle);
    event ratestaleperiodupdated(uint ratestaleperiod);
    event ratesupdated(bytes32[] currencykeys, uint[] newrates);
    event ratedeleted(bytes32 currencykey);
    event inversepriceconfigured(bytes32 currencykey, uint entrypoint, uint upperlimit, uint lowerlimit);
    event inversepricefrozen(bytes32 currencykey);
    event aggregatoradded(bytes32 currencykey, address aggregator);
    event aggregatorremoved(bytes32 currencykey, address aggregator);
}

pragma solidity ^0.5.16;


import ;

import ;
import ;



contract addressresolver is owned, iaddressresolver {
    mapping(bytes32 => address) public repository;

    constructor(address _owner) public owned(_owner) {}

    

    function importaddresses(bytes32[] calldata names, address[] calldata destinations) external onlyowner {
        require(names.length == destinations.length, );

        for (uint i = 0; i < names.length; i++) {
            repository[names[i]] = destinations[i];
        }
    }

    

    function getaddress(bytes32 name) external view returns (address) {
        return repository[name];
    }

    function requireandgetaddress(bytes32 name, string calldata reason) external view returns (address) {
        address _foundaddress = repository[name];
        require(_foundaddress != address(0), reason);
        return _foundaddress;
    }

    function getsynth(bytes32 key) external view returns (address) {
        isynthetix synthetix = isynthetix(repository[]);
        require(address(synthetix) != address(0), );
        return address(synthetix.synths(key));
    }
}

pragma solidity ^0.5.16;


import ;
import ;



contract proxyerc20 is proxy, ierc20 {
    constructor(address _owner) public proxy(_owner) {}

    

    function name() public view returns (string memory) {
        
        return ierc20(address(target)).name();
    }

    function symbol() public view returns (string memory) {
        
        return ierc20(address(target)).symbol();
    }

    function decimals() public view returns (uint8) {
        
        return ierc20(address(target)).decimals();
    }

    

    
    function totalsupply() public view returns (uint256) {
        
        return ierc20(address(target)).totalsupply();
    }

    
    function balanceof(address account) public view returns (uint256) {
        
        return ierc20(address(target)).balanceof(account);
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        
        return ierc20(address(target)).allowance(owner, spender);
    }

    
    function transfer(address to, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(address(target)).transfer(to, value);

        
        return true;
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(address(target)).approve(spender, value);

        
        return true;
    }

    
    function transferfrom(
        address from,
        address to,
        uint256 value
    ) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(address(target)).transferfrom(from, to, value);

        
        return true;
    }
}

pragma solidity ^0.5.16;


import ;


import ;



contract proxyable is owned {
    

    
    proxy public proxy;
    proxy public integrationproxy;

    
    address public messagesender;

    constructor(address payable _proxy) internal {
        
        require(owner != address(0), );

        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setproxy(address payable _proxy) external onlyowner {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setintegrationproxy(address payable _integrationproxy) external onlyowner {
        integrationproxy = proxy(_integrationproxy);
    }

    function setmessagesender(address sender) external onlyproxy {
        messagesender = sender;
    }

    modifier onlyproxy {
        require(proxy(msg.sender) == proxy || proxy(msg.sender) == integrationproxy, );
        _;
    }

    modifier optionalproxy {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy && messagesender != msg.sender) {
            messagesender = msg.sender;
        }
        _;
    }

    modifier optionalproxy_onlyowner {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy && messagesender != msg.sender) {
            messagesender = msg.sender;
        }
        require(messagesender == owner, );
        _;
    }

    event proxyupdated(address proxyaddress);
}

pragma solidity ^0.5.16;


import ;
import ;



contract tokenstate is owned, state {
    
    mapping(address => uint) public balanceof;
    mapping(address => mapping(address => uint)) public allowance;

    constructor(address _owner, address _associatedcontract) public owned(_owner) state(_associatedcontract) {}

    

    
    function setallowance(
        address tokenowner,
        address spender,
        uint value
    ) external onlyassociatedcontract {
        allowance[tokenowner][spender] = value;
    }

    
    function setbalanceof(address account, uint value) external onlyassociatedcontract {
        balanceof[account] = value;
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;
import ;
import ;
import ;


import ;


import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;



contract feepool is owned, proxyable, selfdestructible, limitedsetup, mixinresolver, ifeepool {
    using safemath for uint;
    using safedecimalmath for uint;

    
    uint public exchangefeerate;

    
    uint public constant max_exchange_fee_rate = 1e18 / 10;

    
    address public constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    
    bytes32 private susd = ;

    
    struct feeperiod {
        uint64 feeperiodid;
        uint64 startingdebtindex;
        uint64 starttime;
        uint feestodistribute;
        uint feesclaimed;
        uint rewardstodistribute;
        uint rewardsclaimed;
    }

    
    
    
    
    
    uint8 public constant fee_period_length = 2;

    feeperiod[fee_period_length] private _recentfeeperiods;
    uint256 private _currentfeeperiod;

    
    
    
    
    uint public feeperiodduration = 1 weeks;
    
    uint public constant min_fee_period_duration = 1 days;
    uint public constant max_fee_period_duration = 60 days;

    
    uint public targetthreshold = (1 * safedecimalmath.unit()) / 100;

    

    bytes32 private constant contract_systemstatus = ;
    bytes32 private constant contract_synthetix = ;
    bytes32 private constant contract_feepoolstate = ;
    bytes32 private constant contract_feepooleternalstorage = ;
    bytes32 private constant contract_exchanger = ;
    bytes32 private constant contract_issuer = ;
    bytes32 private constant contract_synthetixstate = ;
    bytes32 private constant contract_rewardescrow = ;
    bytes32 private constant contract_delegateapprovals = ;
    bytes32 private constant contract_rewardsdistribution = ;

    bytes32[24] private addressestocache = [
        contract_systemstatus,
        contract_synthetix,
        contract_feepoolstate,
        contract_feepooleternalstorage,
        contract_exchanger,
        contract_issuer,
        contract_synthetixstate,
        contract_rewardescrow,
        contract_delegateapprovals,
        contract_rewardsdistribution
    ];

    

    bytes32 private constant last_fee_withdrawal = ;

    constructor(
        address payable _proxy,
        address _owner,
        uint _exchangefeerate,
        address _resolver
    )
        public
        owned(_owner)
        selfdestructible()
        proxyable(_proxy)
        limitedsetup(3 weeks)
        mixinresolver(_resolver, addressestocache)
    {
        
        require(_exchangefeerate <= max_exchange_fee_rate, );

        exchangefeerate = _exchangefeerate;

        
        _recentfeeperiodsstorage(0).feeperiodid = 1;
        _recentfeeperiodsstorage(0).starttime = uint64(now);
    }

    

    function systemstatus() internal view returns (isystemstatus) {
        return isystemstatus(requireandgetaddress(contract_systemstatus, ));
    }

    function synthetix() internal view returns (isynthetix) {
        return isynthetix(requireandgetaddress(contract_synthetix, ));
    }

    function feepoolstate() internal view returns (feepoolstate) {
        return feepoolstate(requireandgetaddress(contract_feepoolstate, ));
    }

    function feepooleternalstorage() internal view returns (feepooleternalstorage) {
        return
            feepooleternalstorage(
                requireandgetaddress(contract_feepooleternalstorage, )
            );
    }

    function exchanger() internal view returns (iexchanger) {
        return iexchanger(requireandgetaddress(contract_exchanger, ));
    }

    function issuer() internal view returns (iissuer) {
        return iissuer(requireandgetaddress(contract_issuer, ));
    }

    function synthetixstate() internal view returns (isynthetixstate) {
        return isynthetixstate(requireandgetaddress(contract_synthetixstate, ));
    }

    function rewardescrow() internal view returns (irewardescrow) {
        return irewardescrow(requireandgetaddress(contract_rewardescrow, ));
    }

    function delegateapprovals() internal view returns (idelegateapprovals) {
        return idelegateapprovals(requireandgetaddress(contract_delegateapprovals, ));
    }

    function rewardsdistribution() internal view returns (irewardsdistribution) {
        return
            irewardsdistribution(requireandgetaddress(contract_rewardsdistribution, ));
    }

    function recentfeeperiods(uint index)
        external
        view
        returns (
            uint64 feeperiodid,
            uint64 startingdebtindex,
            uint64 starttime,
            uint feestodistribute,
            uint feesclaimed,
            uint rewardstodistribute,
            uint rewardsclaimed
        )
    {
        feeperiod memory feeperiod = _recentfeeperiodsstorage(index);
        return (
            feeperiod.feeperiodid,
            feeperiod.startingdebtindex,
            feeperiod.starttime,
            feeperiod.feestodistribute,
            feeperiod.feesclaimed,
            feeperiod.rewardstodistribute,
            feeperiod.rewardsclaimed
        );
    }

    function _recentfeeperiodsstorage(uint index) internal view returns (feeperiod storage) {
        return _recentfeeperiods[(_currentfeeperiod + index) % fee_period_length];
    }

    

    
    function appendaccountissuancerecord(
        address account,
        uint debtratio,
        uint debtentryindex
    ) external onlyissuer {
        feepoolstate().appendaccountissuancerecord(
            account,
            debtratio,
            debtentryindex,
            _recentfeeperiodsstorage(0).startingdebtindex
        );

        emitissuancedebtratioentry(account, debtratio, debtentryindex, _recentfeeperiodsstorage(0).startingdebtindex);
    }

    
    function setexchangefeerate(uint _exchangefeerate) external optionalproxy_onlyowner {
        require(_exchangefeerate < max_exchange_fee_rate, );
        exchangefeerate = _exchangefeerate;
    }

    
    function setfeeperiodduration(uint _feeperiodduration) external optionalproxy_onlyowner {
        require(_feeperiodduration >= min_fee_period_duration, );
        require(_feeperiodduration <= max_fee_period_duration, );

        feeperiodduration = _feeperiodduration;

        emitfeeperioddurationupdated(_feeperiodduration);
    }

    function settargetthreshold(uint _percent) external optionalproxy_onlyowner {
        require(_percent >= 0, );
        require(_percent <= 50, );
        targetthreshold = _percent.mul(safedecimalmath.unit()).div(100);
    }

    
    function recordfeepaid(uint amount) external onlyexchangerorsynth {
        
        _recentfeeperiodsstorage(0).feestodistribute = _recentfeeperiodsstorage(0).feestodistribute.add(amount);
    }

    
    function setrewardstodistribute(uint amount) external {
        address rewardsauthority = address(rewardsdistribution());
        require(messagesender == rewardsauthority || msg.sender == rewardsauthority, );
        
        _recentfeeperiodsstorage(0).rewardstodistribute = _recentfeeperiodsstorage(0).rewardstodistribute.add(amount);
    }

    
    function closecurrentfeeperiod() external {
        require(_recentfeeperiodsstorage(0).starttime <= (now  feeperiodduration), );

        systemstatus().requireissuanceactive();

        
        feeperiod storage periodclosing = _recentfeeperiodsstorage(fee_period_length  2);
        feeperiod storage periodtorollover = _recentfeeperiodsstorage(fee_period_length  1);

        
        
        
        
        
        _recentfeeperiodsstorage(fee_period_length  2).feestodistribute = periodtorollover
            .feestodistribute
            .sub(periodtorollover.feesclaimed)
            .add(periodclosing.feestodistribute);
        _recentfeeperiodsstorage(fee_period_length  2).rewardstodistribute = periodtorollover
            .rewardstodistribute
            .sub(periodtorollover.rewardsclaimed)
            .add(periodclosing.rewardstodistribute);

        
        _currentfeeperiod = _currentfeeperiod.add(fee_period_length).sub(1).mod(fee_period_length);

        
        delete _recentfeeperiods[_currentfeeperiod];

        
        
        _recentfeeperiodsstorage(0).feeperiodid = uint64(uint256(_recentfeeperiodsstorage(1).feeperiodid).add(1));
        _recentfeeperiodsstorage(0).startingdebtindex = uint64(synthetixstate().debtledgerlength());
        _recentfeeperiodsstorage(0).starttime = uint64(now);

        emitfeeperiodclosed(_recentfeeperiodsstorage(1).feeperiodid);
    }

    
    function claimfees() external optionalproxy returns (bool) {
        return _claimfees(messagesender);
    }

    
    function claimonbehalf(address claimingforaddress) external optionalproxy returns (bool) {
        require(delegateapprovals().canclaimfor(claimingforaddress, messagesender), );

        return _claimfees(claimingforaddress);
    }

    function _claimfees(address claimingaddress) internal returns (bool) {
        systemstatus().requireissuanceactive();

        uint rewardspaid = 0;
        uint feespaid = 0;
        uint availablefees;
        uint availablerewards;

        
        
        require(isfeesclaimable(claimingaddress), );

        
        (availablefees, availablerewards) = feesavailable(claimingaddress);

        require(
            availablefees > 0 || availablerewards > 0,
            
        );

        
        _setlastfeewithdrawal(claimingaddress, _recentfeeperiodsstorage(1).feeperiodid);

        if (availablefees > 0) {
            
            feespaid = _recordfeepayment(availablefees);

            
            _payfees(claimingaddress, feespaid);
        }

        if (availablerewards > 0) {
            
            rewardspaid = _recordrewardpayment(availablerewards);

            
            _payrewards(claimingaddress, rewardspaid);
        }

        emitfeesclaimed(claimingaddress, feespaid, rewardspaid);

        return true;
    }

    
    function importfeeperiod(
        uint feeperiodindex,
        uint feeperiodid,
        uint startingdebtindex,
        uint starttime,
        uint feestodistribute,
        uint feesclaimed,
        uint rewardstodistribute,
        uint rewardsclaimed
    ) public optionalproxy_onlyowner onlyduringsetup {
        require(startingdebtindex <= synthetixstate().debtledgerlength(), );

        _recentfeeperiods[_currentfeeperiod.add(feeperiodindex).mod(fee_period_length)] = feeperiod({
            feeperiodid: uint64(feeperiodid),
            startingdebtindex: uint64(startingdebtindex),
            starttime: uint64(starttime),
            feestodistribute: feestodistribute,
            feesclaimed: feesclaimed,
            rewardstodistribute: rewardstodistribute,
            rewardsclaimed: rewardsclaimed
        });
    }

    
    function appendvestingentry(address account, uint quantity) public optionalproxy_onlyowner {
        
        ierc20(address(synthetix())).transferfrom(messagesender, address(rewardescrow()), quantity);

        
        rewardescrow().appendvestingentry(account, quantity);
    }

    
    function _recordfeepayment(uint susdamount) internal returns (uint) {
        
        uint remainingtoallocate = susdamount;

        uint feespaid;
        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint feesalreadyclaimed = _recentfeeperiodsstorage(i).feesclaimed;
            uint delta = _recentfeeperiodsstorage(i).feestodistribute.sub(feesalreadyclaimed);

            if (delta > 0) {
                
                uint amountinperiod = delta < remainingtoallocate ? delta : remainingtoallocate;

                _recentfeeperiodsstorage(i).feesclaimed = feesalreadyclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);
                feespaid = feespaid.add(amountinperiod);

                
                if (remainingtoallocate == 0) return feespaid;

                
                
                if (i == 0 && remainingtoallocate > 0) {
                    remainingtoallocate = 0;
                }
            }
        }

        return feespaid;
    }

    
    function _recordrewardpayment(uint snxamount) internal returns (uint) {
        
        uint remainingtoallocate = snxamount;

        uint rewardpaid;

        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint todistribute = _recentfeeperiodsstorage(i).rewardstodistribute.sub(
                _recentfeeperiodsstorage(i).rewardsclaimed
            );

            if (todistribute > 0) {
                
                uint amountinperiod = todistribute < remainingtoallocate ? todistribute : remainingtoallocate;

                _recentfeeperiodsstorage(i).rewardsclaimed = _recentfeeperiodsstorage(i).rewardsclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);
                rewardpaid = rewardpaid.add(amountinperiod);

                
                if (remainingtoallocate == 0) return rewardpaid;

                
                
                
                if (i == 0 && remainingtoallocate > 0) {
                    remainingtoallocate = 0;
                }
            }
        }
        return rewardpaid;
    }

    
    function _payfees(address account, uint susdamount) internal notfeeaddress(account) {
        
        require(
            account != address(0) ||
                account != address(this) ||
                account != address(proxy) ||
                account != address(synthetix()),
            
        );

        
        isynth susdsynth = synthetix().synths(susd);

        
        
        

        
        susdsynth.burn(fee_address, susdamount);

        
        susdsynth.issue(account, susdamount);
    }

    
    function _payrewards(address account, uint snxamount) internal notfeeaddress(account) {
        require(account != address(0), );
        require(account != address(this), );
        require(account != address(proxy), );
        require(account != address(synthetix()), );

        
        
        rewardescrow().appendvestingentry(account, snxamount);
    }

    
    function exchangefeeincurred(uint value) public view returns (uint) {
        return value.multiplydecimal(exchangefeerate);

        
        
        
        
        
        
        
    }

    
    function amountreceivedfromexchange(uint value) external view returns (uint) {
        return value.multiplydecimal(safedecimalmath.unit().sub(exchangefeerate));
    }

    
    function totalfeesavailable() external view returns (uint) {
        uint totalfees = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(_recentfeeperiodsstorage(i).feestodistribute);
            totalfees = totalfees.sub(_recentfeeperiodsstorage(i).feesclaimed);
        }

        return totalfees;
    }

    
    function totalrewardsavailable() external view returns (uint) {
        uint totalrewards = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalrewards = totalrewards.add(_recentfeeperiodsstorage(i).rewardstodistribute);
            totalrewards = totalrewards.sub(_recentfeeperiodsstorage(i).rewardsclaimed);
        }

        return totalrewards;
    }

    
    function feesavailable(address account) public view returns (uint, uint) {
        
        uint[2][fee_period_length] memory userfees = feesbyperiod(account);

        uint totalfees = 0;
        uint totalrewards = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(userfees[i][0]);
            totalrewards = totalrewards.add(userfees[i][1]);
        }

        
        
        return (totalfees, totalrewards);
    }

    
    function isfeesclaimable(address account) public view returns (bool) {
        
        
        
        uint ratio = synthetix().collateralisationratio(account);
        uint targetratio = synthetixstate().issuanceratio();

        
        if (ratio < targetratio) {
            return true;
        }

        
        uint ratio_threshold = targetratio.multiplydecimal(safedecimalmath.unit().add(targetthreshold));

        
        if (ratio > ratio_threshold) {
            return false;
        }

        return true;
    }

    
    function feesbyperiod(address account) public view returns (uint[2][fee_period_length] memory results) {
        
        uint userownershippercentage;
        uint debtentryindex;
        feepoolstate _feepoolstate = feepoolstate();

        (userownershippercentage, debtentryindex) = _feepoolstate.getaccountsdebtentry(account, 0);

        
        
        
        if (debtentryindex == 0 && userownershippercentage == 0) {
            uint[2][fee_period_length] memory nullresults;
            return nullresults;
        }

        
        
        uint feesfromperiod;
        uint rewardsfromperiod;
        (feesfromperiod, rewardsfromperiod) = _feesandrewardsfromperiod(0, userownershippercentage, debtentryindex);

        results[0][0] = feesfromperiod;
        results[0][1] = rewardsfromperiod;

        
        uint lastfeewithdrawal = getlastfeewithdrawal(account);

        
        
        for (uint i = fee_period_length  1; i > 0; i) {
            uint next = i  1;
            uint nextperiodstartingdebtindex = _recentfeeperiodsstorage(next).startingdebtindex;

            
            if (nextperiodstartingdebtindex > 0 && lastfeewithdrawal < _recentfeeperiodsstorage(i).feeperiodid) {
                
                
                
                uint closingdebtindex = uint256(nextperiodstartingdebtindex).sub(1);

                
                
                
                (userownershippercentage, debtentryindex) = _feepoolstate.applicableissuancedata(account, closingdebtindex);

                (feesfromperiod, rewardsfromperiod) = _feesandrewardsfromperiod(i, userownershippercentage, debtentryindex);

                results[i][0] = feesfromperiod;
                results[i][1] = rewardsfromperiod;
            }
        }
    }

    
    function _feesandrewardsfromperiod(
        uint period,
        uint ownershippercentage,
        uint debtentryindex
    ) internal view returns (uint, uint) {
        
        if (ownershippercentage == 0) return (0, 0);

        uint debtownershipforperiod = ownershippercentage;

        
        if (period > 0) {
            uint closingdebtindex = uint256(_recentfeeperiodsstorage(period  1).startingdebtindex).sub(1);
            debtownershipforperiod = _effectivedebtratioforperiod(closingdebtindex, ownershippercentage, debtentryindex);
        }

        
        
        uint feesfromperiod = _recentfeeperiodsstorage(period).feestodistribute.multiplydecimal(debtownershipforperiod);

        uint rewardsfromperiod = _recentfeeperiodsstorage(period).rewardstodistribute.multiplydecimal(
            debtownershipforperiod
        );

        return (feesfromperiod.precisedecimaltodecimal(), rewardsfromperiod.precisedecimaltodecimal());
    }

    function _effectivedebtratioforperiod(
        uint closingdebtindex,
        uint ownershippercentage,
        uint debtentryindex
    ) internal view returns (uint) {
        
        
        isynthetixstate _synthetixstate = synthetixstate();
        uint feeperioddebtownership = _synthetixstate
            .debtledger(closingdebtindex)
            .dividedecimalroundprecise(_synthetixstate.debtledger(debtentryindex))
            .multiplydecimalroundprecise(ownershippercentage);

        return feeperioddebtownership;
    }

    function effectivedebtratioforperiod(address account, uint period) external view returns (uint) {
        require(period != 0, );
        require(period < fee_period_length, );

        
        if (_recentfeeperiodsstorage(period  1).startingdebtindex == 0) return 0;

        uint closingdebtindex = uint256(_recentfeeperiodsstorage(period  1).startingdebtindex).sub(1);

        uint ownershippercentage;
        uint debtentryindex;
        (ownershippercentage, debtentryindex) = feepoolstate().applicableissuancedata(account, closingdebtindex);

        
        return _effectivedebtratioforperiod(closingdebtindex, ownershippercentage, debtentryindex);
    }

    
    function getlastfeewithdrawal(address _claimingaddress) public view returns (uint) {
        return feepooleternalstorage().getuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, _claimingaddress)));
    }

    
    function getpenaltythresholdratio() public view returns (uint) {
        uint targetratio = synthetixstate().issuanceratio();

        return targetratio.multiplydecimal(safedecimalmath.unit().add(targetthreshold));
    }

    
    function _setlastfeewithdrawal(address _claimingaddress, uint _feeperiodid) internal {
        feepooleternalstorage().setuintvalue(
            keccak256(abi.encodepacked(last_fee_withdrawal, _claimingaddress)),
            _feeperiodid
        );
    }

    
    modifier onlyexchangerorsynth {
        bool isexchanger = msg.sender == address(exchanger());
        bool issynth = synthetix().synthsbyaddress(msg.sender) != bytes32(0);

        require(isexchanger || issynth, );
        _;
    }

    modifier onlyissuer {
        require(msg.sender == address(issuer()), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != fee_address, );
        _;
    }

    

    event issuancedebtratioentry(
        address indexed account,
        uint debtratio,
        uint debtentryindex,
        uint feeperiodstartingdebtindex
    );
    bytes32 private constant issuancedebtratioentry_sig = keccak256(
        
    );

    function emitissuancedebtratioentry(
        address account,
        uint debtratio,
        uint debtentryindex,
        uint feeperiodstartingdebtindex
    ) internal {
        proxy._emit(
            abi.encode(debtratio, debtentryindex, feeperiodstartingdebtindex),
            2,
            issuancedebtratioentry_sig,
            bytes32(uint256(uint160(account))),
            0,
            0
        );
    }

    event exchangefeeupdated(uint newfeerate);
    bytes32 private constant exchangefeeupdated_sig = keccak256();

    function emitexchangefeeupdated(uint newfeerate) internal {
        proxy._emit(abi.encode(newfeerate), 1, exchangefeeupdated_sig, 0, 0, 0);
    }

    event feeperioddurationupdated(uint newfeeperiodduration);
    bytes32 private constant feeperioddurationupdated_sig = keccak256();

    function emitfeeperioddurationupdated(uint newfeeperiodduration) internal {
        proxy._emit(abi.encode(newfeeperiodduration), 1, feeperioddurationupdated_sig, 0, 0, 0);
    }

    event feeperiodclosed(uint feeperiodid);
    bytes32 private constant feeperiodclosed_sig = keccak256();

    function emitfeeperiodclosed(uint feeperiodid) internal {
        proxy._emit(abi.encode(feeperiodid), 1, feeperiodclosed_sig, 0, 0, 0);
    }

    event feesclaimed(address account, uint susdamount, uint snxrewards);
    bytes32 private constant feesclaimed_sig = keccak256();

    function emitfeesclaimed(
        address account,
        uint susdamount,
        uint snxrewards
    ) internal {
        proxy._emit(abi.encode(account, susdamount, snxrewards), 1, feesclaimed_sig, 0, 0, 0);
    }
}

pragma solidity ^0.5.16;


import ;
import ;



contract feepooleternalstorage is eternalstorage, limitedsetup {
    bytes32 internal constant last_fee_withdrawal = ;

    constructor(address _owner, address _feepool) public eternalstorage(_owner, _feepool) limitedsetup(6 weeks) {}

    function importfeewithdrawaldata(address[] calldata accounts, uint[] calldata feeperiodids)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == feeperiodids.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            this.setuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, accounts[i])), feeperiodids[i]);
        }
    }
}

pragma solidity ^0.5.16;


import ;
import ;
import ;
import ;
import ;


import ;


import ;
import ;
import ;
import ;
import ;



contract ethercollateral is owned, pausable, reentrancyguard, mixinresolver, iethercollateral {
    using safemath for uint256;
    using safedecimalmath for uint256;

    
    uint256 internal constant one_thousand = 1e18 * 1000;
    uint256 internal constant one_hundred = 1e18 * 100;

    uint256 internal constant seconds_in_a_year = 31536000; 

    
    address internal constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    

    
    uint256 public collateralizationratio = safedecimalmath.unit() * 150;

    
    uint256 public interestrate = (5 * safedecimalmath.unit()) / 100;
    uint256 public interestpersecond = interestrate.div(seconds_in_a_year);

    
    uint256 public issuefeerate = (5 * safedecimalmath.unit()) / 1000;

    
    uint256 public issuelimit = safedecimalmath.unit() * 5000;

    
    uint256 public minloansize = safedecimalmath.unit() * 1;

    
    uint256 public accountloanlimit = 50;

    
    bool public loanliquidationopen = false;

    
    uint256 public liquidationdeadline;

    

    
    uint256 public totalissuedsynths;

    
    uint256 public totalloanscreated;

    
    uint256 public totalopenloancount;

    
    struct synthloanstruct {
        
        address account;
        
        uint256 collateralamount;
        
        uint256 loanamount;
        
        uint256 timecreated;
        
        uint256 loanid;
        
        uint256 timeclosed;
    }

    
    mapping(address => synthloanstruct[]) public accountssynthloans;

    
    mapping(address => uint256) public accountopenloancounter;

    

    bytes32 private constant contract_systemstatus = ;
    bytes32 private constant contract_synthseth = ;
    bytes32 private constant contract_synthsusd = ;
    bytes32 private constant contract_depot = ;

    bytes32[24] private addressestocache = [contract_systemstatus, contract_synthseth, contract_synthsusd, contract_depot];

    
    constructor(address _owner, address _resolver)
        public
        owned(_owner)
        pausable()
        mixinresolver(_resolver, addressestocache)
    {
        liquidationdeadline = now + 92 days; 
    }

    

    function setcollateralizationratio(uint256 ratio) external onlyowner {
        require(ratio <= one_thousand, );
        require(ratio >= one_hundred, );
        collateralizationratio = ratio;
        emit collateralizationratioupdated(ratio);
    }

    function setinterestrate(uint256 _interestrate) external onlyowner {
        require(_interestrate > seconds_in_a_year, );
        require(_interestrate <= safedecimalmath.unit(), );
        interestrate = _interestrate;
        interestpersecond = _interestrate.div(seconds_in_a_year);
        emit interestrateupdated(interestrate);
    }

    function setissuefeerate(uint256 _issuefeerate) external onlyowner {
        issuefeerate = _issuefeerate;
        emit issuefeerateupdated(issuefeerate);
    }

    function setissuelimit(uint256 _issuelimit) external onlyowner {
        issuelimit = _issuelimit;
        emit issuelimitupdated(issuelimit);
    }

    function setminloansize(uint256 _minloansize) external onlyowner {
        minloansize = _minloansize;
        emit minloansizeupdated(minloansize);
    }

    function setaccountloanlimit(uint256 _loanlimit) external onlyowner {
        uint256 hard_cap = 1000;
        require(_loanlimit < hard_cap, );
        accountloanlimit = _loanlimit;
        emit accountloanlimitupdated(accountloanlimit);
    }

    function setloanliquidationopen(bool _loanliquidationopen) external onlyowner {
        require(now > liquidationdeadline, );
        loanliquidationopen = _loanliquidationopen;
        emit loanliquidationopenupdated(loanliquidationopen);
    }

    

    function getcontractinfo()
        external
        view
        returns (
            uint256 _collateralizationratio,
            uint256 _issuanceratio,
            uint256 _interestrate,
            uint256 _interestpersecond,
            uint256 _issuefeerate,
            uint256 _issuelimit,
            uint256 _minloansize,
            uint256 _totalissuedsynths,
            uint256 _totalloanscreated,
            uint256 _totalopenloancount,
            uint256 _ethbalance,
            uint256 _liquidationdeadline,
            bool _loanliquidationopen
        )
    {
        _collateralizationratio = collateralizationratio;
        _issuanceratio = issuanceratio();
        _interestrate = interestrate;
        _interestpersecond = interestpersecond;
        _issuefeerate = issuefeerate;
        _issuelimit = issuelimit;
        _minloansize = minloansize;
        _totalissuedsynths = totalissuedsynths;
        _totalloanscreated = totalloanscreated;
        _totalopenloancount = totalopenloancount;
        _ethbalance = address(this).balance;
        _liquidationdeadline = liquidationdeadline;
        _loanliquidationopen = loanliquidationopen;
    }

    
    
    
    function issuanceratio() public view returns (uint256) {
        
        
        return one_hundred.dividedecimalround(collateralizationratio);
    }

    function loanamountfromcollateral(uint256 collateralamount) public view returns (uint256) {
        return collateralamount.multiplydecimal(issuanceratio());
    }

    function collateralamountforloan(uint256 loanamount) external view returns (uint256) {
        return loanamount.multiplydecimal(collateralizationratio.dividedecimalround(one_hundred));
    }

    function currentinterestonloan(address _account, uint256 _loanid) external view returns (uint256) {
        
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        uint256 loanlifespan = _loanlifespan(synthloan);
        return accruedinterestonloan(synthloan.loanamount, loanlifespan);
    }

    function accruedinterestonloan(uint256 _loanamount, uint256 _seconds) public view returns (uint256 interestamount) {
        
        
        interestamount = _loanamount.multiplydecimalround(interestpersecond.mul(_seconds));
    }

    function calculatemintingfee(address _account, uint256 _loanid) external view returns (uint256) {
        
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        return _calculatemintingfee(synthloan);
    }

    function openloanidsbyaccount(address _account) external view returns (uint256[] memory) {
        synthloanstruct[] memory synthloans = accountssynthloans[_account];

        uint256[] memory _openloanids = new uint256[](synthloans.length);
        uint256 _counter = 0;

        for (uint256 i = 0; i < synthloans.length; i++) {
            if (synthloans[i].timeclosed == 0) {
                _openloanids[_counter] = synthloans[i].loanid;
                _counter++;
            }
        }
        
        uint256[] memory _result = new uint256[](_counter);

        
        for (uint256 j = 0; j < _counter; j++) {
            _result[j] = _openloanids[j];
        }
        
        return _result;
    }

    function getloan(address _account, uint256 _loanid)
        external
        view
        returns (
            address account,
            uint256 collateralamount,
            uint256 loanamount,
            uint256 timecreated,
            uint256 loanid,
            uint256 timeclosed,
            uint256 interest,
            uint256 totalfees
        )
    {
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        account = synthloan.account;
        collateralamount = synthloan.collateralamount;
        loanamount = synthloan.loanamount;
        timecreated = synthloan.timecreated;
        loanid = synthloan.loanid;
        timeclosed = synthloan.timeclosed;
        interest = accruedinterestonloan(synthloan.loanamount, _loanlifespan(synthloan));
        totalfees = interest.add(_calculatemintingfee(synthloan));
    }

    function loanlifespan(address _account, uint256 _loanid) external view returns (uint256 loanlifespanresult) {
        synthloanstruct memory synthloan = _getloanfromstorage(_account, _loanid);
        loanlifespanresult = _loanlifespan(synthloan);
    }

    

    function openloan() external payable notpaused nonreentrant returns (uint256 loanid) {
        systemstatus().requireissuanceactive();

        
        require(msg.value >= minloansize, );

        
        require(loanliquidationopen == false, );

        
        require(accountssynthloans[msg.sender].length < accountloanlimit, );

        
        uint256 loanamount = loanamountfromcollateral(msg.value);

        
        require(totalissuedsynths.add(loanamount) < issuelimit, );

        
        loanid = _incrementtotalloanscounter();

        
        synthloanstruct memory synthloan = synthloanstruct({
            account: msg.sender,
            collateralamount: msg.value,
            loanamount: loanamount,
            timecreated: now,
            loanid: loanid,
            timeclosed: 0
        });

        
        accountssynthloans[msg.sender].push(synthloan);

        
        totalissuedsynths = totalissuedsynths.add(loanamount);

        
        synthseth().issue(msg.sender, loanamount);

        
        emit loancreated(msg.sender, loanid, loanamount);
    }

    function closeloan(uint256 loanid) external nonreentrant {
        _closeloan(msg.sender, loanid);
    }

    
    function liquidateunclosedloan(address _loancreatorsaddress, uint256 _loanid) external nonreentrant {
        require(loanliquidationopen, );
        
        _closeloan(_loancreatorsaddress, _loanid);
        
        emit loanliquidated(_loancreatorsaddress, _loanid, msg.sender);
    }

    

    function _closeloan(address account, uint256 loanid) private {
        systemstatus().requireissuanceactive();

        
        synthloanstruct memory synthloan = _getloanfromstorage(account, loanid);

        require(synthloan.loanid > 0, );
        require(synthloan.timeclosed == 0, );
        require(
            ierc20(address(synthseth())).balanceof(msg.sender) >= synthloan.loanamount,
            
        );

        
        _recordloanclosure(synthloan);

        
        totalissuedsynths = totalissuedsynths.sub(synthloan.loanamount);

        
        uint256 interestamount = accruedinterestonloan(synthloan.loanamount, _loanlifespan(synthloan));
        uint256 mintingfee = _calculatemintingfee(synthloan);
        uint256 totalfees = interestamount.add(mintingfee);

        
        synthseth().burn(msg.sender, synthloan.loanamount);

        
        require(
            ierc20(address(synthsusd())).balanceof(address(depot())) >= totalfees,
            
        );
        depot().exchangeetherforsynths.value(totalfees)();

        
        ierc20(address(synthsusd())).transfer(fee_address, ierc20(address(synthsusd())).balanceof(address(this)));

        
        address(msg.sender).transfer(synthloan.collateralamount.sub(totalfees));

        
        emit loanclosed(account, loanid, totalfees);
    }

    function _getloanfromstorage(address account, uint256 loanid) private view returns (synthloanstruct memory) {
        synthloanstruct[] memory synthloans = accountssynthloans[account];
        for (uint256 i = 0; i < synthloans.length; i++) {
            if (synthloans[i].loanid == loanid) {
                return synthloans[i];
            }
        }
    }

    function _recordloanclosure(synthloanstruct memory synthloan) private {
        
        synthloanstruct[] storage synthloans = accountssynthloans[synthloan.account];
        for (uint256 i = 0; i < synthloans.length; i++) {
            if (synthloans[i].loanid == synthloan.loanid) {
                
                synthloans[i].timeclosed = now;
            }
        }

        
        totalopenloancount = totalopenloancount.sub(1);
    }

    function _incrementtotalloanscounter() private returns (uint256) {
        
        totalopenloancount = totalopenloancount.add(1);
        
        totalloanscreated = totalloanscreated.add(1);
        
        return totalloanscreated;
    }

    function _calculatemintingfee(synthloanstruct memory synthloan) private view returns (uint256 mintingfee) {
        mintingfee = synthloan.loanamount.multiplydecimalround(issuefeerate);
    }

    function _loanlifespan(synthloanstruct memory synthloan) private view returns (uint256 loanlifespanresult) {
        
        bool loanclosed = synthloan.timeclosed > 0;
        
        loanlifespanresult = loanclosed ? synthloan.timeclosed.sub(synthloan.timecreated) : now.sub(synthloan.timecreated);
    }

    

    function systemstatus() internal view returns (isystemstatus) {
        return isystemstatus(requireandgetaddress(contract_systemstatus, ));
    }

    function synthseth() internal view returns (isynth) {
        return isynth(requireandgetaddress(contract_synthseth, ));
    }

    function synthsusd() internal view returns (isynth) {
        return isynth(requireandgetaddress(contract_synthsusd, ));
    }

    function depot() internal view returns (idepot) {
        return idepot(requireandgetaddress(contract_depot, ));
    }

    

    event collateralizationratioupdated(uint256 ratio);
    event interestrateupdated(uint256 interestrate);
    event issuefeerateupdated(uint256 issuefeerate);
    event issuelimitupdated(uint256 issuelimit);
    event minloansizeupdated(uint256 minloansize);
    event accountloanlimitupdated(uint256 loanlimit);
    event loanliquidationopenupdated(bool loanliquidationopen);
    event loancreated(address indexed account, uint256 loanid, uint256 amount);
    event loanclosed(address indexed account, uint256 loanid, uint256 feespaid);
    event loanliquidated(address indexed account, uint256 loanid, address liquidator);
}

pragma solidity ^0.5.16;



contract owned {
    address public owner;
    address public nominatedowner;

    constructor(address _owner) public {
        require(_owner != address(0), );
        owner = _owner;
        emit ownerchanged(address(0), _owner);
    }

    function nominatenewowner(address _owner) external onlyowner {
        nominatedowner = _owner;
        emit ownernominated(_owner);
    }

    function acceptownership() external {
        require(msg.sender == nominatedowner, );
        emit ownerchanged(owner, nominatedowner);
        owner = nominatedowner;
        nominatedowner = address(0);
    }

    modifier onlyowner {
        require(msg.sender == owner, );
        _;
    }

    event ownernominated(address newowner);
    event ownerchanged(address oldowner, address newowner);
}

pragma solidity ^0.5.16;


import ;
import ;
import ;
import ;
import ;
import ;


import ;


import ;
import ;



contract depot is owned, selfdestructible, pausable, reentrancyguard, mixinresolver, idepot {
    using safemath for uint;
    using safedecimalmath for uint;

    bytes32 internal constant snx = ;
    bytes32 internal constant eth = ;

    

    
    
    
    address payable public fundswallet;

    
    struct synthdepositentry {
        
        address payable user;
        
        uint amount;
    }

    
    mapping(uint => synthdepositentry) public deposits;
    
    uint public depositstartindex;
    
    uint public depositendindex;

    
    uint public totalsellabledeposits;

    
    uint public minimumdepositamount = 50 * safedecimalmath.unit();

    
    uint public maxethpurchase = 500 * safedecimalmath.unit();

    
    
    
    mapping(address => uint) public smalldeposits;

    

    bytes32 private constant contract_synthsusd = ;
    bytes32 private constant contract_exrates = ;
    bytes32 private constant contract_synthetix = ;

    bytes32[24] private addressestocache = [contract_synthsusd, contract_exrates, contract_synthetix];

    

    constructor(
        address _owner,
        address payable _fundswallet,
        address _resolver
    ) public owned(_owner) selfdestructible() pausable() mixinresolver(_resolver, addressestocache) {
        fundswallet = _fundswallet;
    }

    

    function setmaxethpurchase(uint _maxethpurchase) external onlyowner {
        maxethpurchase = _maxethpurchase;
        emit maxethpurchaseupdated(maxethpurchase);
    }

    
    function setfundswallet(address payable _fundswallet) external onlyowner {
        fundswallet = _fundswallet;
        emit fundswalletupdated(fundswallet);
    }

    
    function setminimumdepositamount(uint _amount) external onlyowner {
        
        require(_amount > safedecimalmath.unit(), );
        minimumdepositamount = _amount;
        emit minimumdepositamountupdated(minimumdepositamount);
    }

    

    
    function() external payable nonreentrant ratenotstale(eth) notpaused {
        _exchangeetherforsynths();
    }

    
    
    function exchangeetherforsynths()
        external
        payable
        nonreentrant
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        return _exchangeetherforsynths();
    }

    function _exchangeetherforsynths() internal returns (uint) {
        require(msg.value <= maxethpurchase, );
        uint ethtosend;

        
        
        uint requestedtopurchase = msg.value.multiplydecimal(exchangerates().rateforcurrency(eth));
        uint remainingtofulfill = requestedtopurchase;

        
        for (uint i = depositstartindex; remainingtofulfill > 0 && i < depositendindex; i++) {
            synthdepositentry memory deposit = deposits[i];

            
            
            if (deposit.user == address(0)) {
                depositstartindex = depositstartindex.add(1);
            } else {
                
                
                if (deposit.amount > remainingtofulfill) {
                    
                    
                    
                    uint newamount = deposit.amount.sub(remainingtofulfill);
                    deposits[i] = synthdepositentry({user: deposit.user, amount: newamount});

                    totalsellabledeposits = totalsellabledeposits.sub(remainingtofulfill);

                    
                    
                    
                    
                    
                    ethtosend = remainingtofulfill.dividedecimal(exchangerates().rateforcurrency(eth));

                    
                    
                    
                    if (!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, remainingtofulfill, i);
                    }

                    
                    
                    
                    
                    synthsusd().transfer(msg.sender, remainingtofulfill);

                    
                    remainingtofulfill = 0;
                } else if (deposit.amount <= remainingtofulfill) {
                    
                    
                    
                    delete deposits[i];
                    
                    depositstartindex = depositstartindex.add(1);
                    
                    totalsellabledeposits = totalsellabledeposits.sub(deposit.amount);

                    
                    
                    
                    
                    
                    ethtosend = deposit.amount.dividedecimal(exchangerates().rateforcurrency(eth));

                    
                    
                    
                    if (!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, deposit.amount, i);
                    }

                    
                    
                    
                    
                    synthsusd().transfer(msg.sender, deposit.amount);

                    
                    
                    remainingtofulfill = remainingtofulfill.sub(deposit.amount);
                }
            }
        }

        
        
        if (remainingtofulfill > 0) {
            msg.sender.transfer(remainingtofulfill.dividedecimal(exchangerates().rateforcurrency(eth)));
        }

        
        uint fulfilled = requestedtopurchase.sub(remainingtofulfill);

        if (fulfilled > 0) {
            
            emit exchange(, msg.value, , fulfilled);
        }

        return fulfilled;
    }

    

    
    function exchangeetherforsynthsatrate(uint guaranteedrate)
        external
        payable
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        require(guaranteedrate == exchangerates().rateforcurrency(eth), );

        return _exchangeetherforsynths();
    }

    function _exchangeetherforsnx() internal returns (uint) {
        
        uint synthetixtosend = synthetixreceivedforether(msg.value);

        
        fundswallet.transfer(msg.value);

        
        synthetix().transfer(msg.sender, synthetixtosend);

        emit exchange(, msg.value, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangeetherforsnx()
        external
        payable
        ratenotstale(snx)
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        return _exchangeetherforsnx();
    }

    
    function exchangeetherforsnxatrate(uint guaranteedetherrate, uint guaranteedsynthetixrate)
        external
        payable
        ratenotstale(snx)
        ratenotstale(eth)
        notpaused
        returns (
            uint 
        )
    {
        require(guaranteedetherrate == exchangerates().rateforcurrency(eth), );
        require(
            guaranteedsynthetixrate == exchangerates().rateforcurrency(snx),
            
        );

        return _exchangeetherforsnx();
    }

    function _exchangesynthsforsnx(uint synthamount) internal returns (uint) {
        
        uint synthetixtosend = synthetixreceivedforsynths(synthamount);

        
        
        
        synthsusd().transferfrom(msg.sender, fundswallet, synthamount);

        
        synthetix().transfer(msg.sender, synthetixtosend);

        emit exchange(, synthamount, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangesynthsforsnx(uint synthamount)
        external
        ratenotstale(snx)
        notpaused
        returns (
            uint 
        )
    {
        return _exchangesynthsforsnx(synthamount);
    }

    
    function exchangesynthsforsnxatrate(uint synthamount, uint guaranteedrate)
        external
        ratenotstale(snx)
        notpaused
        returns (
            uint 
        )
    {
        require(guaranteedrate == exchangerates().rateforcurrency(snx), );

        return _exchangesynthsforsnx(synthamount);
    }

    
    function withdrawsynthetix(uint amount) external onlyowner {
        synthetix().transfer(owner, amount);

        
        
        
        
    }

    
    function withdrawmydepositedsynths() external {
        uint synthstosend = 0;

        for (uint i = depositstartindex; i < depositendindex; i++) {
            synthdepositentry memory deposit = deposits[i];

            if (deposit.user == msg.sender) {
                
                
                synthstosend = synthstosend.add(deposit.amount);
                delete deposits[i];
                
                emit synthdepositremoved(deposit.user, deposit.amount, i);
            }
        }

        
        totalsellabledeposits = totalsellabledeposits.sub(synthstosend);

        
        
        synthstosend = synthstosend.add(smalldeposits[msg.sender]);
        smalldeposits[msg.sender] = 0;

        
        require(synthstosend > 0, );

        
        synthsusd().transfer(msg.sender, synthstosend);

        emit synthwithdrawal(msg.sender, synthstosend);
    }

    
    function depositsynths(uint amount) external {
        
        synthsusd().transferfrom(msg.sender, address(this), amount);

        
        
        if (amount < minimumdepositamount) {
            
            
            smalldeposits[msg.sender] = smalldeposits[msg.sender].add(amount);

            emit synthdepositnotaccepted(msg.sender, amount, minimumdepositamount);
        } else {
            
            deposits[depositendindex] = synthdepositentry({user: msg.sender, amount: amount});
            emit synthdeposit(msg.sender, amount, depositendindex);

            
            depositendindex = depositendindex.add(1);

            
            totalsellabledeposits = totalsellabledeposits.add(amount);
        }
    }

    

    
    function synthetixreceivedforsynths(uint amount) public view returns (uint) {
        
        return amount.dividedecimal(exchangerates().rateforcurrency(snx));
    }

    
    function synthetixreceivedforether(uint amount) public view returns (uint) {
        
        uint valuesentinsynths = amount.multiplydecimal(exchangerates().rateforcurrency(eth));

        
        return synthetixreceivedforsynths(valuesentinsynths);
    }

    
    function synthsreceivedforether(uint amount) public view returns (uint) {
        
        return amount.multiplydecimal(exchangerates().rateforcurrency(eth));
    }

    

    function synthsusd() internal view returns (ierc20) {
        return ierc20(requireandgetaddress(contract_synthsusd, ));
    }

    function synthetix() internal view returns (ierc20) {
        return ierc20(requireandgetaddress(contract_synthetix, ));
    }

    function exchangerates() internal view returns (iexchangerates) {
        return iexchangerates(requireandgetaddress(contract_exrates, ));
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!exchangerates().rateisstale(currencykey), );
        _;
    }

    

    event maxethpurchaseupdated(uint amount);
    event fundswalletupdated(address newfundswallet);
    event exchange(string fromcurrency, uint fromamount, string tocurrency, uint toamount);
    event synthwithdrawal(address user, uint amount);
    event synthdeposit(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositremoved(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositnotaccepted(address user, uint amount, uint minimum);
    event minimumdepositamountupdated(uint amount);
    event nonpayablecontract(address indexed receiver, uint amount);
    event cleareddeposit(
        address indexed fromaddress,
        address indexed toaddress,
        uint fromethamount,
        uint toamount,
        uint indexed depositindex
    );
}

pragma solidity ^0.5.16;

import ;





contract readproxy is owned {
    address public target;

    constructor(address _owner) public owned(_owner) {}

    function settarget(address _target) external onlyowner {
        target = _target;
        emit targetupdated(target);
    }

    function() external {
        
        
        assembly {
            calldatacopy(0, 0, calldatasize)

            
            let result := staticcall(gas, sload(target_slot), 0, calldatasize, 0, 0)
            returndatacopy(0, 0, returndatasize)

            if iszero(result) {
                revert(0, returndatasize)
            }
            return(0, returndatasize)
        }
    }

    event targetupdated(address newtarget);
}

pragma solidity ^0.5.16;


import ;
import ;
import ;


import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;



contract synthetix is ierc20, externstatetoken, mixinresolver, isynthetix {
    

    
    isynth[] public availablesynths;
    mapping(bytes32 => isynth) public synths;
    mapping(address => bytes32) public synthsbyaddress;

    string public constant token_name = ;
    string public constant token_symbol = ;
    uint8 public constant decimals = 18;
    bytes32 public constant susd = ;

    

    bytes32 private constant contract_systemstatus = ;
    bytes32 private constant contract_exchanger = ;
    bytes32 private constant contract_ethercollateral = ;
    bytes32 private constant contract_issuer = ;
    bytes32 private constant contract_synthetixstate = ;
    bytes32 private constant contract_exrates = ;
    bytes32 private constant contract_supplyschedule = ;
    bytes32 private constant contract_rewardescrow = ;
    bytes32 private constant contract_synthetixescrow = ;
    bytes32 private constant contract_rewardsdistribution = ;

    bytes32[24] private addressestocache = [
        contract_systemstatus,
        contract_exchanger,
        contract_ethercollateral,
        contract_issuer,
        contract_synthetixstate,
        contract_exrates,
        contract_supplyschedule,
        contract_rewardescrow,
        contract_synthetixescrow,
        contract_rewardsdistribution
    ];

    

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        address _owner,
        uint _totalsupply,
        address _resolver
    )
        public
        externstatetoken(_proxy, _tokenstate, token_name, token_symbol, _totalsupply, decimals, _owner)
        mixinresolver(_resolver, addressestocache)
    {}

    

    function systemstatus() internal view returns (isystemstatus) {
        return isystemstatus(requireandgetaddress(contract_systemstatus, ));
    }

    function exchanger() internal view returns (iexchanger) {
        return iexchanger(requireandgetaddress(contract_exchanger, ));
    }

    function ethercollateral() internal view returns (iethercollateral) {
        return iethercollateral(requireandgetaddress(contract_ethercollateral, ));
    }

    function issuer() internal view returns (iissuer) {
        return iissuer(requireandgetaddress(contract_issuer, ));
    }

    function synthetixstate() internal view returns (isynthetixstate) {
        return isynthetixstate(requireandgetaddress(contract_synthetixstate, ));
    }

    function exchangerates() internal view returns (iexchangerates) {
        return iexchangerates(requireandgetaddress(contract_exrates, ));
    }

    function supplyschedule() internal view returns (supplyschedule) {
        return supplyschedule(requireandgetaddress(contract_supplyschedule, ));
    }

    function rewardescrow() internal view returns (irewardescrow) {
        return irewardescrow(requireandgetaddress(contract_rewardescrow, ));
    }

    function synthetixescrow() internal view returns (ihasbalance) {
        return ihasbalance(requireandgetaddress(contract_synthetixescrow, ));
    }

    function rewardsdistribution() internal view returns (irewardsdistribution) {
        return
            irewardsdistribution(requireandgetaddress(contract_rewardsdistribution, ));
    }

    
    function _totalissuedsynths(bytes32 currencykey, bool excludeethercollateral) internal view returns (uint) {
        iexchangerates exrates = exchangerates();
        uint total = 0;
        uint currencyrate = exrates.rateforcurrency(currencykey);

        (uint[] memory rates, bool anyratestale) = exrates.ratesandstaleforcurrencies(availablecurrencykeys());
        require(!anyratestale, );

        for (uint i = 0; i < availablesynths.length; i++) {
            
            
            
            
            uint totalsynths = ierc20(address(availablesynths[i])).totalsupply();

            
            if (excludeethercollateral && availablesynths[i] == synths[]) {
                totalsynths = totalsynths.sub(ethercollateral().totalissuedsynths());
            }

            uint synthvalue = totalsynths.multiplydecimalround(rates[i]);
            total = total.add(synthvalue);
        }

        return total.dividedecimalround(currencyrate);
    }

    
    function totalissuedsynths(bytes32 currencykey) public view returns (uint) {
        return _totalissuedsynths(currencykey, false);
    }

    
    function totalissuedsynthsexcludeethercollateral(bytes32 currencykey) public view returns (uint) {
        return _totalissuedsynths(currencykey, true);
    }

    function availablecurrencykeys() public view returns (bytes32[] memory) {
        bytes32[] memory currencykeys = new bytes32[](availablesynths.length);

        for (uint i = 0; i < availablesynths.length; i++) {
            currencykeys[i] = synthsbyaddress[address(availablesynths[i])];
        }

        return currencykeys;
    }

    function availablesynthcount() external view returns (uint) {
        return availablesynths.length;
    }

    function iswaitingperiod(bytes32 currencykey) external view returns (bool) {
        return exchanger().maxsecsleftinwaitingperiod(messagesender, currencykey) > 0;
    }

    

    
    function addsynth(isynth synth) external optionalproxy_onlyowner {
        bytes32 currencykey = synth.currencykey();

        require(synths[currencykey] == isynth(0), );
        require(synthsbyaddress[address(synth)] == bytes32(0), );

        availablesynths.push(synth);
        synths[currencykey] = synth;
        synthsbyaddress[address(synth)] = currencykey;
    }

    
    function removesynth(bytes32 currencykey) external optionalproxy_onlyowner {
        require(address(synths[currencykey]) != address(0), );
        require(ierc20(address(synths[currencykey])).totalsupply() == 0, );
        require(currencykey != susd, );

        
        address synthtoremove = address(synths[currencykey]);

        
        for (uint i = 0; i < availablesynths.length; i++) {
            if (address(availablesynths[i]) == synthtoremove) {
                delete availablesynths[i];

                
                
                
                availablesynths[i] = availablesynths[availablesynths.length  1];

                
                availablesynths.length;

                break;
            }
        }

        
        delete synthsbyaddress[address(synths[currencykey])];
        delete synths[currencykey];

        
        
        
    }

    
    function transfer(address to, uint value) public optionalproxy returns (bool) {
        systemstatus().requiresystemactive();

        
        require(value <= transferablesynthetix(messagesender), );

        
        _transferbyproxy(messagesender, to, value);

        return true;
    }

    
    function transferfrom(
        address from,
        address to,
        uint value
    ) public optionalproxy returns (bool) {
        systemstatus().requiresystemactive();

        
        require(value <= transferablesynthetix(from), );

        
        
        return _transferfrombyproxy(messagesender, from, to, value);
    }

    function issuesynths(uint amount) external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().issuesynths(messagesender, amount);
    }

    function issuesynthsonbehalf(address issueforaddress, uint amount) external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().issuesynthsonbehalf(issueforaddress, messagesender, amount);
    }

    function issuemaxsynths() external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().issuemaxsynths(messagesender);
    }

    function issuemaxsynthsonbehalf(address issueforaddress) external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().issuemaxsynthsonbehalf(issueforaddress, messagesender);
    }

    function burnsynths(uint amount) external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().burnsynths(messagesender, amount);
    }

    function burnsynthsonbehalf(address burnforaddress, uint amount) external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().burnsynthsonbehalf(burnforaddress, messagesender, amount);
    }

    function burnsynthstotarget() external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().burnsynthstotarget(messagesender);
    }

    function burnsynthstotargetonbehalf(address burnforaddress) external optionalproxy {
        systemstatus().requireissuanceactive();

        return issuer().burnsynthstotargetonbehalf(burnforaddress, messagesender);
    }

    function exchange(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external optionalproxy returns (uint amountreceived) {
        systemstatus().requireexchangeactive();

        systemstatus().requiresynthsactive(sourcecurrencykey, destinationcurrencykey);

        return exchanger().exchange(messagesender, sourcecurrencykey, sourceamount, destinationcurrencykey, messagesender);
    }

    function exchangeonbehalf(
        address exchangeforaddress,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external optionalproxy returns (uint amountreceived) {
        systemstatus().requireexchangeactive();

        systemstatus().requiresynthsactive(sourcecurrencykey, destinationcurrencykey);

        return
            exchanger().exchangeonbehalf(
                exchangeforaddress,
                messagesender,
                sourcecurrencykey,
                sourceamount,
                destinationcurrencykey
            );
    }

    function settle(bytes32 currencykey)
        external
        optionalproxy
        returns (
            uint reclaimed,
            uint refunded,
            uint numentriessettled
        )
    {
        return exchanger().settle(messagesender, currencykey);
    }

    

    
    function maxissuablesynths(address _issuer)
        public
        view
        returns (
            
            uint
        )
    {
        
        uint destinationvalue = exchangerates().effectivevalue(, collateral(_issuer), susd);

        
        return destinationvalue.multiplydecimal(synthetixstate().issuanceratio());
    }

    
    function collateralisationratio(address _issuer) public view returns (uint) {
        uint totalownedsynthetix = collateral(_issuer);
        if (totalownedsynthetix == 0) return 0;

        uint debtbalance = debtbalanceof(_issuer, );
        return debtbalance.dividedecimalround(totalownedsynthetix);
    }

    
    function debtbalanceof(address _issuer, bytes32 currencykey)
        public
        view
        returns (
            
            uint
        )
    {
        isynthetixstate state = synthetixstate();

        
        (uint initialdebtownership, ) = state.issuancedata(_issuer);

        
        if (initialdebtownership == 0) return 0;

        (uint debtbalance, ) = debtbalanceofandtotaldebt(_issuer, currencykey);
        return debtbalance;
    }

    function debtbalanceofandtotaldebt(address _issuer, bytes32 currencykey)
        public
        view
        returns (uint debtbalance, uint totalsystemvalue)
    {
        isynthetixstate state = synthetixstate();

        
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = state.issuancedata(_issuer);

        
        totalsystemvalue = totalissuedsynthsexcludeethercollateral(currencykey);

        
        if (initialdebtownership == 0) return (0, totalsystemvalue);

        
        
        uint currentdebtownership = state
            .lastdebtledgerentry()
            .dividedecimalroundprecise(state.debtledger(debtentryindex))
            .multiplydecimalroundprecise(initialdebtownership);

        
        uint highprecisionbalance = totalsystemvalue.decimaltoprecisedecimal().multiplydecimalroundprecise(
            currentdebtownership
        );

        
        debtbalance = highprecisionbalance.precisedecimaltodecimal();
    }

    
    function remainingissuablesynths(address _issuer)
        public
        view
        returns (
            
            uint maxissuable,
            uint alreadyissued,
            uint totalsystemdebt
        )
    {
        (alreadyissued, totalsystemdebt) = debtbalanceofandtotaldebt(_issuer, susd);
        maxissuable = maxissuablesynths(_issuer);

        if (alreadyissued >= maxissuable) {
            maxissuable = 0;
        } else {
            maxissuable = maxissuable.sub(alreadyissued);
        }
    }

    
    function collateral(address account) public view returns (uint) {
        uint balance = tokenstate.balanceof(account);

        if (address(synthetixescrow()) != address(0)) {
            balance = balance.add(synthetixescrow().balanceof(account));
        }

        if (address(rewardescrow()) != address(0)) {
            balance = balance.add(rewardescrow().balanceof(account));
        }

        return balance;
    }

    
    function transferablesynthetix(address account)
        public
        view
        ratenotstale() 
        returns (uint)
    {
        
        
        
        uint balance = tokenstate.balanceof(account);

        
        
        
        
        uint lockedsynthetixvalue = debtbalanceof(account, ).dividedecimalround(synthetixstate().issuanceratio());

        
        if (lockedsynthetixvalue >= balance) {
            return 0;
        } else {
            return balance.sub(lockedsynthetixvalue);
        }
    }

    
    function mint() external returns (bool) {
        require(address(rewardsdistribution()) != address(0), );

        systemstatus().requireissuanceactive();

        supplyschedule _supplyschedule = supplyschedule();
        irewardsdistribution _rewardsdistribution = rewardsdistribution();

        uint supplytomint = _supplyschedule.mintablesupply();
        require(supplytomint > 0, );

        
        _supplyschedule.recordmintevent(supplytomint);

        
        
        uint minterreward = _supplyschedule.minterreward();
        
        uint amounttodistribute = supplytomint.sub(minterreward);

        
        tokenstate.setbalanceof(
            address(_rewardsdistribution),
            tokenstate.balanceof(address(_rewardsdistribution)).add(amounttodistribute)
        );
        emittransfer(address(this), address(_rewardsdistribution), amounttodistribute);

        
        _rewardsdistribution.distributerewards(amounttodistribute);

        
        tokenstate.setbalanceof(msg.sender, tokenstate.balanceof(msg.sender).add(minterreward));
        emittransfer(address(this), msg.sender, minterreward);

        totalsupply = totalsupply.add(supplytomint);

        return true;
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!exchangerates().rateisstale(currencykey), );
        _;
    }

    modifier onlyexchanger() {
        require(msg.sender == address(exchanger()), );
        _;
    }

    

    event synthexchange(
        address indexed account,
        bytes32 fromcurrencykey,
        uint256 fromamount,
        bytes32 tocurrencykey,
        uint256 toamount,
        address toaddress
    );
    bytes32 internal constant synthexchange_sig = keccak256(
        
    );

    function emitsynthexchange(
        address account,
        bytes32 fromcurrencykey,
        uint256 fromamount,
        bytes32 tocurrencykey,
        uint256 toamount,
        address toaddress
    ) external onlyexchanger {
        proxy._emit(
            abi.encode(fromcurrencykey, fromamount, tocurrencykey, toamount, toaddress),
            2,
            synthexchange_sig,
            addresstobytes32(account),
            0,
            0
        );
    }

    event exchangereclaim(address indexed account, bytes32 currencykey, uint amount);
    bytes32 internal constant exchangereclaim_sig = keccak256();

    function emitexchangereclaim(
        address account,
        bytes32 currencykey,
        uint256 amount
    ) external onlyexchanger {
        proxy._emit(abi.encode(currencykey, amount), 2, exchangereclaim_sig, addresstobytes32(account), 0, 0);
    }

    event exchangerebate(address indexed account, bytes32 currencykey, uint amount);
    bytes32 internal constant exchangerebate_sig = keccak256();

    function emitexchangerebate(
        address account,
        bytes32 currencykey,
        uint256 amount
    ) external onlyexchanger {
        proxy._emit(abi.encode(currencykey, amount), 2, exchangerebate_sig, addresstobytes32(account), 0, 0);
    }
}

pragma solidity ^0.5.16;


import ;
import ;


import ;


import ;
import ;



contract rewardsdistribution is owned, irewardsdistribution {
    using safemath for uint;
    using safedecimalmath for uint;

    
    address public authority;

    
    address public synthetixproxy;

    
    address public rewardescrow;

    
    address public feepoolproxy;

    
    struct distributiondata {
        address destination;
        uint amount;
    }

    
    distributiondata[] public distributions;

    
    constructor(
        address _owner,
        address _authority,
        address _synthetixproxy,
        address _rewardescrow,
        address _feepoolproxy
    ) public owned(_owner) {
        authority = _authority;
        synthetixproxy = _synthetixproxy;
        rewardescrow = _rewardescrow;
        feepoolproxy = _feepoolproxy;
    }

    

    function setsynthetixproxy(address _synthetixproxy) external onlyowner {
        synthetixproxy = _synthetixproxy;
    }

    function setrewardescrow(address _rewardescrow) external onlyowner {
        rewardescrow = _rewardescrow;
    }

    function setfeepoolproxy(address _feepoolproxy) external onlyowner {
        feepoolproxy = _feepoolproxy;
    }

    
    function setauthority(address _authority) external onlyowner {
        authority = _authority;
    }

    

    
    function addrewarddistribution(address destination, uint amount) external onlyowner returns (bool) {
        require(destination != address(0), );
        require(amount != 0, );

        distributiondata memory rewardsdistribution = distributiondata(destination, amount);
        distributions.push(rewardsdistribution);

        emit rewarddistributionadded(distributions.length  1, destination, amount);
        return true;
    }

    
    function removerewarddistribution(uint index) external onlyowner {
        require(index <= distributions.length  1, );

        
        for (uint i = index; i < distributions.length  1; i++) {
            distributions[i] = distributions[i + 1];
        }
        distributions.length;

        
        
        
        
    }

    
    function editrewarddistribution(
        uint index,
        address destination,
        uint amount
    ) external onlyowner returns (bool) {
        require(index <= distributions.length  1, );

        distributions[index].destination = destination;
        distributions[index].amount = amount;

        return true;
    }

    function distributerewards(uint amount) external returns (bool) {
        require(msg.sender == authority, );
        require(rewardescrow != address(0), );
        require(synthetixproxy != address(0), );
        require(feepoolproxy != address(0), );
        require(amount > 0, );
        require(
            ierc20(synthetixproxy).balanceof(address(this)) >= amount,
            
        );

        uint remainder = amount;

        
        for (uint i = 0; i < distributions.length; i++) {
            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {
                remainder = remainder.sub(distributions[i].amount);

                
                ierc20(synthetixproxy).transfer(distributions[i].destination, distributions[i].amount);

                
                bytes memory payload = abi.encodewithsignature(, distributions[i].amount);

                
                (bool success, ) = distributions[i].destination.call(payload);

                if (!success) {
                    
                }
            }
        }

        
        ierc20(synthetixproxy).transfer(rewardescrow, remainder);

        
        ifeepool(feepoolproxy).setrewardstodistribute(remainder);

        emit rewardsdistributed(amount);
        return true;
    }

    

    
    function distributionslength() external view returns (uint) {
        return distributions.length;
    }

    

    event rewarddistributionadded(uint index, address destination, uint amount);
    event rewardsdistributed(uint amount);
}

pragma solidity ^0.5.16;


import ;
import ;



contract systemstatus is owned, isystemstatus {
    struct status {
        bool cansuspend;
        bool canresume;
    }

    mapping(bytes32 => mapping(address => status)) public accesscontrol;

    struct suspension {
        bool suspended;
        
        
        uint248 reason;
    }

    uint248 public constant suspension_reason_upgrade = 1;

    bytes32 public constant section_system = ;
    bytes32 public constant section_issuance = ;
    bytes32 public constant section_exchange = ;
    bytes32 public constant section_synth = ;

    suspension public systemsuspension;

    suspension public issuancesuspension;

    suspension public exchangesuspension;

    mapping(bytes32 => suspension) public synthsuspension;

    constructor(address _owner) public owned(_owner) {
        _internalupdateaccesscontrol(section_system, _owner, true, true);
        _internalupdateaccesscontrol(section_issuance, _owner, true, true);
        _internalupdateaccesscontrol(section_exchange, _owner, true, true);
        _internalupdateaccesscontrol(section_synth, _owner, true, true);
    }

    
    function requiresystemactive() external view {
        _internalrequiresystemactive();
    }

    function requireissuanceactive() external view {
        
        _internalrequiresystemactive();
        require(!issuancesuspension.suspended, );
    }

    function requireexchangeactive() external view {
        
        _internalrequiresystemactive();
        require(!exchangesuspension.suspended, );
    }

    function requiresynthactive(bytes32 currencykey) external view {
        
        _internalrequiresystemactive();
        require(!synthsuspension[currencykey].suspended, );
    }

    function requiresynthsactive(bytes32 sourcecurrencykey, bytes32 destinationcurrencykey) external view {
        
        _internalrequiresystemactive();

        require(
            !synthsuspension[sourcecurrencykey].suspended && !synthsuspension[destinationcurrencykey].suspended,
            
        );
    }

    function issystemupgrading() external view returns (bool) {
        return systemsuspension.suspended && systemsuspension.reason == suspension_reason_upgrade;
    }

    function getsynthsuspensions(bytes32[] calldata synths)
        external
        view
        returns (bool[] memory suspensions, uint256[] memory reasons)
    {
        suspensions = new bool[](synths.length);
        reasons = new uint256[](synths.length);

        for (uint i = 0; i < synths.length; i++) {
            suspensions[i] = synthsuspension[synths[i]].suspended;
            reasons[i] = synthsuspension[synths[i]].reason;
        }
    }

    
    function updateaccesscontrol(
        bytes32 section,
        address account,
        bool cansuspend,
        bool canresume
    ) external onlyowner {
        _internalupdateaccesscontrol(section, account, cansuspend, canresume);
    }

    function suspendsystem(uint256 reason) external {
        _requireaccesstosuspend(section_system);
        systemsuspension.suspended = true;
        systemsuspension.reason = uint248(reason);
        emit systemsuspended(systemsuspension.reason);
    }

    function resumesystem() external {
        _requireaccesstoresume(section_system);
        systemsuspension.suspended = false;
        emit systemresumed(uint256(systemsuspension.reason));
        systemsuspension.reason = 0;
    }

    function suspendissuance(uint256 reason) external {
        _requireaccesstosuspend(section_issuance);
        issuancesuspension.suspended = true;
        issuancesuspension.reason = uint248(reason);
        emit issuancesuspended(reason);
    }

    function resumeissuance() external {
        _requireaccesstoresume(section_issuance);
        issuancesuspension.suspended = false;
        emit issuanceresumed(uint256(issuancesuspension.reason));
        issuancesuspension.reason = 0;
    }

    function suspendexchange(uint256 reason) external {
        _requireaccesstosuspend(section_exchange);
        exchangesuspension.suspended = true;
        exchangesuspension.reason = uint248(reason);
        emit exchangesuspended(reason);
    }

    function resumeexchange() external {
        _requireaccesstoresume(section_exchange);
        exchangesuspension.suspended = false;
        emit exchangeresumed(uint256(exchangesuspension.reason));
        exchangesuspension.reason = 0;
    }

    function suspendsynth(bytes32 currencykey, uint256 reason) external {
        _requireaccesstosuspend(section_synth);
        synthsuspension[currencykey].suspended = true;
        synthsuspension[currencykey].reason = uint248(reason);
        emit synthsuspended(currencykey, reason);
    }

    function resumesynth(bytes32 currencykey) external {
        _requireaccesstoresume(section_synth);
        emit synthresumed(currencykey, uint256(synthsuspension[currencykey].reason));
        delete synthsuspension[currencykey];
    }

    

    function _requireaccesstosuspend(bytes32 section) internal view {
        require(accesscontrol[section][msg.sender].cansuspend, );
    }

    function _requireaccesstoresume(bytes32 section) internal view {
        require(accesscontrol[section][msg.sender].canresume, );
    }

    function _internalrequiresystemactive() internal view {
        require(
            !systemsuspension.suspended,
            systemsuspension.reason == suspension_reason_upgrade
                ? 
                : 
        );
    }

    function _internalupdateaccesscontrol(
        bytes32 section,
        address account,
        bool cansuspend,
        bool canresume
    ) internal {
        require(
            section == section_system ||
                section == section_issuance ||
                section == section_exchange ||
                section == section_synth,
            
        );
        accesscontrol[section][account].cansuspend = cansuspend;
        accesscontrol[section][account].canresume = canresume;
        emit accesscontrolupdated(section, account, cansuspend, canresume);
    }

    

    event systemsuspended(uint256 reason);
    event systemresumed(uint256 reason);

    event issuancesuspended(uint256 reason);
    event issuanceresumed(uint256 reason);

    event exchangesuspended(uint256 reason);
    event exchangeresumed(uint256 reason);

    event synthsuspended(bytes32 currencykey, uint256 reason);
    event synthresumed(bytes32 currencykey, uint256 reason);

    event accesscontrolupdated(bytes32 indexed section, address indexed account, bool cansuspend, bool canresume);
}

pragma solidity >=0.4.24;

import ;


interface isynthetix {
    
    function availablecurrencykeys() external view returns (bytes32[] memory);

    function availablesynthcount() external view returns (uint);

    function collateral(address account) external view returns (uint);

    function collateralisationratio(address issuer) external view returns (uint);

    function debtbalanceof(address issuer, bytes32 currencykey) external view returns (uint);

    function debtbalanceofandtotaldebt(address issuer, bytes32 currencykey)
        external
        view
        returns (uint debtbalance, uint totalsystemvalue);

    function iswaitingperiod(bytes32 currencykey) external view returns (bool);

    function maxissuablesynths(address issuer) external view returns (uint maxissuable);

    function remainingissuablesynths(address issuer)
        external
        view
        returns (
            uint maxissuable,
            uint alreadyissued,
            uint totalsystemdebt
        );

    function synths(bytes32 currencykey) external view returns (isynth);

    function synthsbyaddress(address synthaddress) external view returns (bytes32);

    function totalissuedsynths(bytes32 currencykey) external view returns (uint);

    function totalissuedsynthsexcludeethercollateral(bytes32 currencykey) external view returns (uint);

    function transferablesynthetix(address account) external view returns (uint);

    
    function burnsynths(uint amount) external;

    function burnsynthsonbehalf(address burnforaddress, uint amount) external;

    function burnsynthstotarget() external;

    function burnsynthstotargetonbehalf(address burnforaddress) external;

    function exchange(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external returns (uint amountreceived);

    function exchangeonbehalf(
        address exchangeforaddress,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external returns (uint amountreceived);

    function issuemaxsynths() external;

    function issuemaxsynthsonbehalf(address issueforaddress) external;

    function issuesynths(uint amount) external;

    function issuesynthsonbehalf(address issueforaddress, uint amount) external;

    function mint() external returns (bool);

    function settle(bytes32 currencykey)
        external
        returns (
            uint reclaimed,
            uint refunded,
            uint numentries
        );
}

pragma solidity >=0.4.24;


interface iissuer {
    
    function canburnsynths(address account) external view returns (bool);

    function lastissueevent(address account) external view returns (uint);

    
    function issuesynths(address from, uint amount) external;

    function issuesynthsonbehalf(
        address issuefor,
        address from,
        uint amount
    ) external;

    function issuemaxsynths(address from) external;

    function issuemaxsynthsonbehalf(address issuefor, address from) external;

    function burnsynths(address from, uint amount) external;

    function burnsynthsonbehalf(
        address burnforaddress,
        address from,
        uint amount
    ) external;

    function burnsynthstotarget(address from) external;

    function burnsynthstotargetonbehalf(address burnforaddress, address from) external;
}

pragma solidity >=0.4.24;


interface iaddressresolver {
    function getaddress(bytes32 name) external view returns (address);

    function getsynth(bytes32 key) external view returns (address);

    function requireandgetaddress(bytes32 name, string calldata reason) external view returns (address);
}

pragma solidity >=0.4.24;


interface iethercollateral {
    
    function totalissuedsynths() external view returns (uint256);

    function totalloanscreated() external view returns (uint256);

    function totalopenloancount() external view returns (uint256);

    
    function openloan() external payable returns (uint256 loanid);

    function closeloan(uint256 loanid) external;

    function liquidateunclosedloan(address _loancreatorsaddress, uint256 _loanid) external;
}

pragma solidity >=0.4.24;


interface isynthetixstate {
    
    function debtledger(uint index) external view returns (uint);

    function issuanceratio() external view returns (uint);

    function issuancedata(address account) external view returns (uint initialdebtownership, uint debtentryindex);

    function debtledgerlength() external view returns (uint);

    function hasissued(address account) external view returns (bool);

    function lastdebtledgerentry() external view returns (uint);

    
    function incrementtotalissuercount() external;

    function decrementtotalissuercount() external;

    function setcurrentissuancedata(address account, uint initialdebtownership) external;

    function appenddebtledgervalue(uint value) external;

    function clearissuancedata(address account) external;
}

pragma solidity >=0.4.24;


interface isystemstatus {
    
    function requiresystemactive() external view;

    function requireissuanceactive() external view;

    function requireexchangeactive() external view;

    function requiresynthactive(bytes32 currencykey) external view;

    function requiresynthsactive(bytes32 sourcecurrencykey, bytes32 destinationcurrencykey) external view;
}

pragma solidity >=0.4.24;


interface irewardescrow {
    
    function balanceof(address account) external view returns (uint);

    function numvestingentries(address account) external view returns (uint);

    
    function appendvestingentry(address account, uint quantity) external;

    function vest() external;
}

pragma solidity >=0.4.24;


interface iexchangestate {
    
    function getlengthofentries(address account, bytes32 currencykey) external view returns (uint);

    function getentryat(
        address account,
        bytes32 currencykey,
        uint index
    )
        external
        view
        returns (
            bytes32 src,
            uint amount,
            bytes32 dest,
            uint amountreceived,
            uint exchangefeerate,
            uint timestamp,
            uint roundidforsrc,
            uint roundidfordest
        );

    function getmaxtimestamp(address account, bytes32 currencykey) external view returns (uint);

    
    function appendexchangeentry(
        address account,
        bytes32 src,
        uint amount,
        bytes32 dest,
        uint amountreceived,
        uint exchangefeerate,
        uint timestamp,
        uint roundidforsrc,
        uint roundidfordest
    ) external;

    function removeentries(address account, bytes32 currencykey) external;
}

pragma solidity >=0.4.24;


interface ifeepool {
    
    function amountreceivedfromexchange(uint value) external view returns (uint);

    function exchangefeerate() external view returns (uint);

    
    function fee_address() external view returns (address);

    function feesavailable(address account) external view returns (uint, uint);

    function isfeesclaimable(address account) external view returns (bool);

    function totalfeesavailable() external view returns (uint);

    function totalrewardsavailable() external view returns (uint);

    
    function claimfees() external returns (bool);

    function claimonbehalf(address claimingforaddress) external returns (bool);

    function closecurrentfeeperiod() external;

    
    function appendaccountissuancerecord(
        address account,
        uint lockedamount,
        uint debtentryindex
    ) external;

    function recordfeepaid(uint susdamount) external;

    function setrewardstodistribute(uint amount) external;
}

pragma solidity >=0.4.24;


interface irewardsdistribution {
    
    function distributerewards(uint amount) external returns (bool);
}

pragma solidity >=0.4.24;


interface ihasbalance {
    
    function balanceof(address account) external view returns (uint);
}

pragma solidity >=0.4.24;


interface iexchanger {
    
    function calculateamountaftersettlement(
        address from,
        bytes32 currencykey,
        uint amount,
        uint refunded
    ) external view returns (uint amountaftersettlement);

    function feerateforexchange(bytes32 sourcecurrencykey, bytes32 destinationcurrencykey) external view returns (uint);

    function maxsecsleftinwaitingperiod(address account, bytes32 currencykey) external view returns (uint);

    function settlementowing(address account, bytes32 currencykey)
        external
        view
        returns (
            uint reclaimamount,
            uint rebateamount,
            uint numentries
        );

    
    function exchange(
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        address destinationaddress
    ) external returns (uint amountreceived);

    function exchangeonbehalf(
        address exchangeforaddress,
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external returns (uint amountreceived);

    function settle(address from, bytes32 currencykey)
        external
        returns (
            uint reclaimed,
            uint refunded,
            uint numentries
        );
}

pragma solidity >=0.4.24;


interface isynth {
    
    function currencykey() external view returns (bytes32);

    function transferablesynths(address account) external view returns (uint);

    
    function transferandsettle(address to, uint value) external returns (bool);

    function transferfromandsettle(
        address from,
        address to,
        uint value
    ) external returns (bool);

    
    function burn(address account, uint amount) external;

    function issue(address account, uint amount) external;
}

pragma solidity >=0.4.24;


interface iexchangerates {
    
    function aggregators(bytes32 currencykey) external view returns (address);

    function anyrateisstale(bytes32[] calldata currencykeys) external view returns (bool);

    function currentroundforrate(bytes32 currencykey) external view returns (uint);

    function effectivevalue(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey
    ) external view returns (uint);

    function effectivevalueatround(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        uint roundidforsrc,
        uint roundidfordest
    ) external view returns (uint);

    function getcurrentroundid(bytes32 currencykey) external view returns (uint);

    function getlastroundidbeforeelapsedsecs(
        bytes32 currencykey,
        uint startingroundid,
        uint startingtimestamp,
        uint timediff
    ) external view returns (uint);

    function inversepricing(bytes32 currencykey)
        external
        view
        returns (
            uint entrypoint,
            uint upperlimit,
            uint lowerlimit,
            bool frozen
        );

    function lastrateupdatetimes(bytes32 currencykey) external view returns (uint256);

    function oracle() external view returns (address);

    function rateandtimestampatround(bytes32 currencykey, uint roundid) external view returns (uint rate, uint time);

    function rateforcurrency(bytes32 currencykey) external view returns (uint);

    function rateisfrozen(bytes32 currencykey) external view returns (bool);

    function rateisstale(bytes32 currencykey) external view returns (bool);

    function ratesandstaleforcurrencies(bytes32[] calldata currencykeys) external view returns (uint[] memory, bool);

    function ratesforcurrencies(bytes32[] calldata currencykeys) external view returns (uint[] memory);

    function ratestaleperiod() external view returns (uint);
}

pragma solidity >=0.4.24;


interface idelegateapprovals {
    
    function canburnfor(address authoriser, address delegate) external view returns (bool);

    function canissuefor(address authoriser, address delegate) external view returns (bool);

    function canclaimfor(address authoriser, address delegate) external view returns (bool);

    function canexchangefor(address authoriser, address delegate) external view returns (bool);

    
    function approvealldelegatepowers(address delegate) external;

    function removealldelegatepowers(address delegate) external;

    function approveburnonbehalf(address delegate) external;

    function removeburnonbehalf(address delegate) external;

    function approveissueonbehalf(address delegate) external;

    function removeissueonbehalf(address delegate) external;

    function approveclaimonbehalf(address delegate) external;

    function removeclaimonbehalf(address delegate) external;

    function approveexchangeonbehalf(address delegate) external;

    function removeexchangeonbehalf(address delegate) external;
}

pragma solidity >=0.4.24;


interface ierc20 {
    
    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    
    function totalsupply() external view returns (uint);

    function balanceof(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);

    
    function transfer(address to, uint value) external returns (bool);

    function approve(address spender, uint value) external returns (bool);

    function transferfrom(
        address from,
        address to,
        uint value
    ) external returns (bool);

    
    event transfer(address indexed from, address indexed to, uint value);

    event approval(address indexed owner, address indexed spender, uint value);
}

pragma solidity >=0.4.24;


interface idepot {
    
    function fundswallet() external view returns (address payable);

    function maxethpurchase() external view returns (uint);

    function minimumdepositamount() external view returns (uint);

    function synthsreceivedforether(uint amount) external view returns (uint);

    function totalsellabledeposits() external view returns (uint);

    
    function depositsynths(uint amount) external;

    function exchangeetherforsynths() external payable returns (uint);

    function exchangeetherforsynthsatrate(uint guaranteedrate) external payable returns (uint);

    function withdrawmydepositedsynths() external;

    
    function exchangeetherforsnx() external payable returns (uint);

    function exchangeetherforsnxatrate(uint guaranteedrate, uint guaranteedsynthetixrate) external payable returns (uint);

    function exchangesynthsforsnx(uint synthamount) external returns (uint);

    function exchangesynthsforsnxatrate(uint synthamount, uint guaranteedrate) external returns (uint);
}

pragma solidity ^0.5.16;

import ;
import ;


contract testablestate is owned, state {
    constructor(address _owner, address _associatedcontract) public owned(_owner) state(_associatedcontract) {}

    function testmodifier() external onlyassociatedcontract {}
}

pragma solidity ^0.5.16;

import ;


contract oneweeksetup is limitedsetup(1 weeks) {
    function testfunc() public view onlyduringsetup returns (bool) {
        return true;
    }

    function publicsetupexpirytime() public view returns (uint) {
        return setupexpirytime;
    }
}

pragma solidity ^0.5.16;

import ;
import ;




contract mocksynth is externstatetoken {
    isystemstatus private systemstatus;
    bytes32 public currencykey;

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        string memory _name,
        string memory _symbol,
        uint _totalsupply,
        address _owner,
        bytes32 _currencykey
    ) public externstatetoken(_proxy, _tokenstate, _name, _symbol, _totalsupply, 18, _owner) {
        currencykey = _currencykey;
    }

    
    function setsystemstatus(isystemstatus _status) external {
        systemstatus = _status;
    }

    
    function settotalsupply(uint256 _totalsupply) external {
        totalsupply = _totalsupply;
    }

    function transfer(address to, uint value) external optionalproxy returns (bool) {
        systemstatus.requiresynthactive(currencykey);

        return _transferbyproxy(messagesender, to, value);
    }

    function transferfrom(
        address from,
        address to,
        uint value
    ) external optionalproxy returns (bool) {
        systemstatus.requiresynthactive(currencykey);

        return _transferfrombyproxy(messagesender, from, to, value);
    }

    event issued(address indexed account, uint value);

    event burned(address indexed account, uint value);

    
    function issue(address account, uint amount) external {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).add(amount));
        totalsupply = totalsupply.add(amount);
        emit issued(account, amount);
    }

    function burn(address account, uint amount) external {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).sub(amount));
        totalsupply = totalsupply.sub(amount);
        emit burned(account, amount);
    }
}

pragma solidity ^0.5.16;

import ;


contract mockexchanger {
    uint256 private _mockreclaimamount;
    uint256 private _mockrefundamount;
    uint256 private _mocknumentries;
    uint256 private _mockmaxsecsleft;

    isynthetix public synthetix;

    constructor(isynthetix _synthetix) public {
        synthetix = _synthetix;
    }

    
    function settle(address from, bytes32 currencykey)
        external
        returns (
            uint256 reclaimed,
            uint256 refunded,
            uint numentriessettled
        )
    {
        if (_mockreclaimamount > 0) {
            synthetix.synths(currencykey).burn(from, _mockreclaimamount);
        }

        if (_mockrefundamount > 0) {
            synthetix.synths(currencykey).issue(from, _mockrefundamount);
        }

        _mockmaxsecsleft = 0;

        return (_mockreclaimamount, _mockrefundamount, _mocknumentries);
    }

    
    function maxsecsleftinwaitingperiod(
        address, 
        bytes32 
    ) public view returns (uint) {
        return _mockmaxsecsleft;
    }

    
    function settlementowing(
        address, 
        bytes32 
    )
        public
        view
        returns (
            uint,
            uint,
            uint
        )
    {
        return (_mockreclaimamount, _mockrefundamount, _mocknumentries);
    }

    function setreclaim(uint256 _reclaimamount) external {
        _mockreclaimamount = _reclaimamount;
    }

    function setrefund(uint256 _refundamount) external {
        _mockrefundamount = _refundamount;
    }

    function setnumentries(uint256 _numentries) external {
        _mocknumentries = _numentries;
    }

    function setmaxsecsleft(uint _maxsecsleft) external {
        _mockmaxsecsleft = _maxsecsleft;
    }
}

pragma solidity ^0.5.16;

import ;
import ;


contract usingreadproxy {
    iaddressresolver public resolver;

    constructor(iaddressresolver _resolver) public {
        resolver = _resolver;
    }

    function run(bytes32 currencykey) external view returns (uint) {
        iexchangerates exrates = iexchangerates(resolver.getaddress());
        require(address(exrates) != address(0), );
        return exrates.rateforcurrency(currencykey);
    }
}

pragma solidity ^0.5.16;

import ;
import ;


contract testableselfdestructible is owned, selfdestructible {
    constructor(address _owner) public owned(_owner) selfdestructible() {}
}


pragma solidity ^0.5.16;

import ;


contract publicmath {
    using math for uint;

    function powerdecimal(uint x, uint y) public pure returns (uint) {
        return x.powdecimal(y);
    }
}

pragma solidity ^0.5.16;

import ;
import ;



contract testablepausable is owned, pausable {
    uint public somevalue;

    constructor(address _owner) public owned(_owner) pausable() {}

    function setsomevalue(uint _value) external notpaused {
        somevalue = _value;
    }
}



pragma solidity ^0.5.16;


contract genericmock {
    mapping(bytes4 => bytes) public mockconfig;

    
    function() external {
        bytes memory ret = mockconfig[msg.sig];
        assembly {
            return(add(ret, 0x20), mload(ret))
        }
    }

    function mockreturns(bytes4 key, bytes calldata value) external {
        mockconfig[key] = value;
    }
}

pragma solidity ^0.5.16;


interface aggregatorinterface {
    function latestanswer() external view returns (int256);

    function latesttimestamp() external view returns (uint256);

    function latestround() external view returns (uint256);

    function getanswer(uint256 roundid) external view returns (int256);

    function gettimestamp(uint256 roundid) external view returns (uint256);

    
    
}


contract mockaggregator is aggregatorinterface {
    uint public roundid = 0;

    struct entry {
        int256 answer;
        uint256 timestamp;
    }

    mapping(uint => entry) public entries;

    constructor() public {}

    
    function setlatestanswer(int256 answer, uint256 timestamp) external {
        roundid++;
        entries[roundid] = entry({answer: answer, timestamp: timestamp});
    }

    function latestanswer() external view returns (int256) {
        return getanswer(latestround());
    }

    function latesttimestamp() external view returns (uint256) {
        return gettimestamp(latestround());
    }

    function latestround() public view returns (uint256) {
        return roundid;
    }

    function getanswer(uint256 _roundid) public view returns (int256) {
        return entries[_roundid].answer;
    }

    function gettimestamp(uint256 _roundid) public view returns (uint256) {
        return entries[_roundid].timestamp;
    }
}


pragma solidity ^0.5.16;

import ;
import ;
import ;
import ;


contract tokenexchanger is owned {
    address public integrationproxy;
    address public synthetix;

    constructor(address _owner, address _integrationproxy) public owned(_owner) {
        integrationproxy = _integrationproxy;
    }

    function setsynthetixproxy(address _integrationproxy) external onlyowner {
        integrationproxy = _integrationproxy;
    }

    function setsynthetix(address _synthetix) external onlyowner {
        synthetix = _synthetix;
    }

    function checkbalance(address account) public view synthetixproxyisset returns (uint) {
        return ierc20(integrationproxy).balanceof(account);
    }

    function checkallowance(address tokenowner, address spender) public view synthetixproxyisset returns (uint) {
        return ierc20(integrationproxy).allowance(tokenowner, spender);
    }

    function checkbalancesnxdirect(address account) public view synthetixproxyisset returns (uint) {
        return ierc20(synthetix).balanceof(account);
    }

    function getdecimals(address tokenaddress) public view returns (uint) {
        return ierc20(tokenaddress).decimals();
    }

    function dotokenspend(
        address fromaccount,
        address toaccount,
        uint amount
    ) public synthetixproxyisset returns (bool) {
        
        require(checkbalance(fromaccount) >= amount, );

        
        require(
            checkallowance(fromaccount, address(this)) >= amount,
            
        );

        
        return ierc20(integrationproxy).transferfrom(fromaccount, toaccount, amount);
    }

    modifier synthetixproxyisset {
        require(integrationproxy != address(0), );
        _;
    }

    event logstring(string name, string value);
    event logint(string name, uint value);
    event logaddress(string name, address value);
    event logbytes(string name, bytes4 value);
}

pragma solidity ^0.5.16;

import ;


contract publicest is externstatetoken {
    uint8 public constant decimals = 18;

    constructor(
        address payable _proxy,
        tokenstate _tokenstate,
        string memory _name,
        string memory _symbol,
        uint _totalsupply,
        address _owner
    ) public externstatetoken(_proxy, _tokenstate, _name, _symbol, _totalsupply, decimals, _owner) {}

    function transfer(address to, uint value) external optionalproxy returns (bool) {
        return _transferbyproxy(messagesender, to, value);
    }

    function transferfrom(
        address from,
        address to,
        uint value
    ) external optionalproxy returns (bool) {
        return _transferfrombyproxy(messagesender, from, to, value);
    }

    
    event received(address indexed sender, uint256 indexed inputa, bytes32 indexed inputb);

    function somethingtobeproxied(uint256 inputa, bytes32 inputb) external {
        emit received(messagesender, inputa, inputb);
    }
}

pragma solidity ^0.5.16;


contract mockmutator {
    uint256 public count;

    function read() external view returns (uint) {
        return count;
    }

    function update() external {
        count = count + 1;
    }
}

pragma solidity ^0.5.16;

import ;
import ;


contract testablemixinresolver is owned, mixinresolver {
    bytes32 private constant contract_example_1 = ;
    bytes32 private constant contract_example_2 = ;
    bytes32 private constant contract_example_3 = ;

    bytes32[24] private addressestocache = [contract_example_1, contract_example_2, contract_example_3];

    constructor(address _owner, address _resolver) public owned(_owner) mixinresolver(_resolver, addressestocache) {}
}

pragma solidity ^0.5.16;

import ;


contract mockethercollateral {
    using safemath for uint;
    using safedecimalmath for uint;

    uint public totalissuedsynths;

    constructor() public {}

    
    function openloan(uint amount) external {
        
        totalissuedsynths = totalissuedsynths.add(amount);
    }

    function closeloan(uint amount) external {
        
        totalissuedsynths = totalissuedsynths.sub(amount);
    }
}


pragma solidity ^0.5.16;

import ;


contract publicsafedecimalmath {
    using safedecimalmath for uint;

    function unit() public pure returns (uint) {
        return safedecimalmath.unit();
    }

    function preciseunit() public pure returns (uint) {
        return safedecimalmath.preciseunit();
    }

    function multiplydecimal(uint x, uint y) public pure returns (uint) {
        return x.multiplydecimal(y);
    }

    function multiplydecimalround(uint x, uint y) public pure returns (uint) {
        return x.multiplydecimalround(y);
    }

    function multiplydecimalroundprecise(uint x, uint y) public pure returns (uint) {
        return x.multiplydecimalroundprecise(y);
    }

    function dividedecimal(uint x, uint y) public pure returns (uint) {
        return x.dividedecimal(y);
    }

    function dividedecimalround(uint x, uint y) public pure returns (uint) {
        return x.dividedecimalround(y);
    }

    function dividedecimalroundprecise(uint x, uint y) public pure returns (uint) {
        return x.dividedecimalroundprecise(y);
    }

    function decimaltoprecisedecimal(uint i) public pure returns (uint) {
        return i.decimaltoprecisedecimal();
    }

    function precisedecimaltodecimal(uint i) public pure returns (uint) {
        return i.precisedecimaltodecimal();
    }
}

pragma solidity ^0.5.16;

import ;
import ;


contract mockrewardsrecipient is rewardsdistributionrecipient {
    uint256 public rewardsavailable;

    constructor(address _owner) public owned(_owner) {}

    function notifyrewardamount(uint256 reward) external onlyrewardsdistribution {
        rewardsavailable = rewardsavailable + reward;
        emit rewardadded(reward);
    }

    event rewardadded(uint256 amount);
}

