

pragma solidity ^0.4.19;


import ;
import ;
import ;
import ;


contract havven is erc20token, owned {

    

    
    
    mapping(address => uint) currentbalancesum;

    
    
    
    
    mapping(address => uint) public lastaveragebalance;

    
    
    
    
    
    mapping(address => uint) public penultimateaveragebalance;

    
    
    mapping(address => uint) lasttransfertimestamp;

    mapping(address => bool) haswithdrawnlastperiodfees;

    
    uint public feeperiodstarttime;
    
    uint public targetfeeperioddurationseconds = 4 weeks;
    
    uint constant minfeeperioddurationseconds = 1 days;
    
    uint lastfeeperiodduration = 1;

    
    
    uint public lastfeescollected;

    
    
    
    mapping(address => court.vote) public vote;
    
    mapping(address => address) public votetarget;

    ethernomin public nomin;
    court public court;


    

    function havven(address _owner)
        erc20token(, ,
                   1e8 * unit, 
                   this)
        owned(_owner)
        public
    {
        feeperiodstarttime = now;
    }


    

    function setnomin(ethernomin _nomin) 
        public
        onlyowner
    {
        nomin = _nomin;
    }

    function setcourt(court _court) 
        public
        onlyowner
    {
        court = _court;
    }

    function settargetfeeperiodduration(uint duration)
        public
        postcheckfeeperiodrollover
        onlyowner
    {
        require(duration >= minfeeperioddurationseconds);
        targetfeeperioddurationseconds = duration;
        feeperioddurationupdated(duration);
    }


    

    function hasvoted(address account)
        public
        view
        returns (bool)
    {
        return vote[account] != court.vote.abstention;
    }


    

    
    function endow(address account, uint value)
        public
        onlyowner
        returns (bool)
    {
        return this.transfer(account, value);
    }

    
    function transfer(address _to, uint _value)
        public
        postcheckfeeperiodrollover
        returns (bool)
    {
        uint senderprebalance = balanceof[msg.sender];
        uint recipientprebalance = balanceof[_to];

        
        
        super.transfer(_to, _value);

        
        if (_value == 0) {
            return true;
        }

        adjustfeeentitlement(msg.sender, senderprebalance);
        adjustfeeentitlement(_to, recipientprebalance);

        return true;
    }

    
    function transferfrom(address _from, address _to, uint _value)
        public
        postcheckfeeperiodrollover
        returns (bool)
    {
        uint senderprebalance = balanceof[_from];
        uint recipientprebalance = balanceof[_to];

        
        
        super.transferfrom(_from, _to, _value);

        
        if (_value == 0) {
            return true;
        }

        adjustfeeentitlement(_from, senderprebalance);
        adjustfeeentitlement(_to, recipientprebalance);

        return true;
    }

    
    function adjustfeeentitlement(address account, uint prebalance)
        internal
    {
        uint lasttransfertime = lasttransfertimestamp[account];

        
        
        rolloverfee(account, lasttransfertime, prebalance);
        currentbalancesum[account] = safeadd(currentbalancesum[account],
                                             safedecmul(prebalance,
                                                        inttodec(now  lasttransfertime)));

        
        lasttransfertimestamp[account] = now;
    }

    
    function rolloverfee(address account, uint lasttransfertime, uint prebalance)
        internal
    {
        if (lasttransfertime < feeperiodstarttime) {
            uint timetorollover = inttodec(feeperiodstarttime  lasttransfertime);
            penultimateaveragebalance[account] = lastaveragebalance[account];

            
            if (timetorollover >= lastfeeperiodduration) {
                lastaveragebalance[account] = prebalance;
            } else {
                lastaveragebalance[account] = safedecmul(safeadd(currentbalancesum[account],
                                                                 safedecmul(prebalance, timetorollover)),
                                                         lastfeeperiodduration);
            }

            
            currentbalancesum[account] = 0;
            haswithdrawnlastperiodfees[account] = false;
            lasttransfertimestamp[account] = feeperiodstarttime;
        }
    }

    
    function withdrawfeeentitlement()
        public
        postcheckfeeperiodrollover
    {
        
        require(!nomin.isfrozen(msg.sender));

        
        require(!haswithdrawnlastperiodfees[msg.sender]);

        rolloverfee(msg.sender, lasttransfertimestamp[msg.sender], balanceof[msg.sender]);
        uint feesowed = safedecmul(safedecmul(lastaveragebalance[msg.sender],
                                              lastfeescollected),
                                   totalsupply);
        nomin.withdrawfee(msg.sender, feesowed);
        haswithdrawnlastperiodfees[msg.sender] = true;
        feeswithdrawn(msg.sender, feesowed);
    }

    
    function setvotedyea(address account, address target)
        public
        onlycourt
    {
        require(vote[account] == court.vote.abstention);
        vote[account] = court.vote.yea;
        votetarget[account] = target;
    }

    
    function setvotednay(address account, address target)
        public
        onlycourt
    {
        require(vote[account] == court.vote.abstention);
        vote[account] = court.vote.nay;
        votetarget[account] = target;
    }

    
    function cancelvote(address account, address target)
        public
        onlycourt
    {
        require(votetarget[account] == target);
        vote[account] = court.vote.abstention;
        votetarget[account] = 0;
    }


    

    
    modifier postcheckfeeperiodrollover
    {
        _;
        uint duration = now  feeperiodstarttime;
        if (targetfeeperioddurationseconds <= duration) {
            lastfeescollected = nomin.feepool();
            lastfeeperiodduration = inttodec(duration);
            feeperiodstarttime = now;
        }
    }

    modifier onlycourt
    {
        require(court(msg.sender) == court);
        _;
    }


    

    event feeperioddurationupdated(uint duration);

    event feeswithdrawn(address indexed account, uint fees);

}



pragma solidity ^0.4.19;


import ;
import ;
import ;
import ;


contract court is owned, safedecimalmath {

    

    
    havven havven;
    ethernomin nomin;

    
    
    uint minstandingbalance = 100 * unit;

    
    
    uint votingperiod = 1 weeks;
    uint constant minvotingperiod = 3 days;
    uint constant maxvotingperiod = 4 weeks;

    
    
    
    uint confirmationperiod = 1 weeks;
    uint constant minconfirmationperiod = 1 days;
    uint constant maxconfirmationperiod = 2 weeks;

    
    
    
    uint requiredparticipation = 3 * unit / 10;
    uint constant minrequiredparticipation = unit / 10;

    
    
    
    uint requiredmajority = (2 * unit) / 3;
    uint constant minrequiredmajority = unit / 2;

    
    
    
    
    
    
    mapping(address => uint) public votestarttimes;

    
    
    
    mapping(address => uint) public votesfor;
    mapping(address => uint) public votesagainst;

    
    
    
    
    
    mapping(address => uint) voteweight;

    
    
    
    
    enum vote {abstention, yea, nay}


    

    function court(havven _havven, ethernomin _nomin, address _owner)
        owned(_owner)
        public
    {
        havven = _havven;
        nomin = _nomin;
    }


    

    function setminstandingbalance(uint balance)
        public
        onlyowner
    {
        
        
        
        minstandingbalance = balance;
        minstandingbalanceupdated(balance);
    }

    function setvotingperiod(uint duration)
        public
        onlyowner
    {
        require(minvotingperiod <= duration &&
                duration <= maxvotingperiod);
        
        
        require(duration <= havven.targetfeeperioddurationseconds());
        votingperiod = duration;
        votingperiodupdated(duration);
    }

    function setconfirmationperiod(uint duration)
        public
        onlyowner
    {
        require(minconfirmationperiod <= duration &&
                duration <= maxconfirmationperiod);
        confirmationperiod = duration;
        confirmationperiodupdated(duration);
    }

    function setrequiredparticipation(uint fraction)
        public
        onlyowner
    {
        require(minrequiredparticipation <= fraction);
        requiredparticipation = fraction;
        requiredparticipationupdated(fraction);
    }

    function setrequiredmajority(uint fraction)
        public
        onlyowner
    {
        require(minrequiredmajority <= fraction);
        requiredmajority = fraction;
        requiredmajorityupdated(fraction);
    }


    

    
    function voting(address target)
        public
        view
        returns (bool)
    {
        
        
        return now < votestarttimes[target] + votingperiod;
    }

    
    function confirming(address target)
        public
        view
        returns (bool)
    {
        uint starttime = votestarttimes[target];
        return starttime + votingperiod <= now &&
               now < starttime + votingperiod + confirmationperiod;
    }

    
    function waiting(address target)
        public
        view
        returns (bool)
    {
        return votestarttimes[target] + votingperiod + confirmationperiod <= now;
    }

    
    function votepasses(address target)
        public
        view
        returns (bool)
    {
        uint yeas = votesfor[target];
        uint nays = votesagainst[target];
        uint totalvotes = yeas + nays;

        if (totalvotes == 0) {
            return false;
        }

        uint participation = safedecdiv(totalvotes, havven.totalsupply());
        uint fractioninfavour = safedecdiv(yeas, totalvotes);

        
        
        return participation > requiredparticipation &&
               fractioninfavour > requiredmajority;
    }


    

    
    function beginconfiscationaction(address target)
        public
    {
        
        require((havven.balanceof(msg.sender) > minstandingbalance) ||
                msg.sender == owner);

        
        
        require(votingperiod <= havven.targetfeeperioddurationseconds());

        
        require(waiting(target));

        
        require(!nomin.isfrozen(target));

        votestarttimes[target] = now;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        confiscationvote(msg.sender, target);
    }

    
    function votefor(address target)
        public
    {
        
        
        require(voting(target));

        
        require(!havven.hasvoted(msg.sender));

        uint weight;
        
        
        
        if (votestarttimes[target] < havven.feeperiodstarttime()) {
            weight = havven.penultimateaveragebalance(msg.sender);
        } else {
            weight = havven.lastaveragebalance(msg.sender);
        }

        
        require(weight > 0);

        
        
        
        havven.setvotedyea(msg.sender, target);
        voteweight[msg.sender] = weight;
        votesfor[msg.sender] += weight;
        votefor(msg.sender, target, weight);
    }

    
    function voteagainst(address target)
        public
    {
        
        
        require(voting(target));

        
        require(!havven.hasvoted(msg.sender));

        uint weight;
        
        
        
        if (votestarttimes[target] < havven.feeperiodstarttime()) {
            weight = havven.penultimateaveragebalance(msg.sender);
        } else {
            weight = havven.lastaveragebalance(msg.sender);
        }

        
        require(weight > 0);

        
        
        
        havven.setvotednay(msg.sender, target);
        voteweight[msg.sender] = weight;
        votesagainst[msg.sender] += weight;
        voteagainst(msg.sender, target, weight);
    }

    
    function cancelvote(address target)
        public
    {
        
        
        
        
        require(!confirming(target));

        
        if (voting(target)) {
            
            vote vote = havven.vote(msg.sender);

            if (vote == vote.yea) {
                votesfor[msg.sender] = voteweight[msg.sender];
            }
            else if (vote == vote.nay) {
                votesagainst[msg.sender] = voteweight[msg.sender];
            } else {
                
                return;
            }

            
            voteweight[msg.sender] = 0;
            cancelledvote(msg.sender, target);
        }

        
        
        
        havven.cancelvote(msg.sender, target);
    }

    
    function closevote(address target)
        public
    {
        require((confirming(target) && !votepasses(target)) || waiting(target));

        votestarttimes[target] = 0;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        voteclosed(target);
    }

    
    function approve(address target)
        public
        onlyowner
    {
        require(confirming(target));
        require(votepasses(target));

        nomin.confiscatebalance(target);
        votestarttimes[target] = 0;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        voteclosed(target);
        confiscationapproval(target);
    }

    
    function veto(address target)
        public
        onlyowner
    {
        require(!waiting(target));
        votestarttimes[target] = 0;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        voteclosed(target);
        veto(target);
    }


    

    event minstandingbalanceupdated(uint balance);

    event votingperiodupdated(uint duration);

    event confirmationperiodupdated(uint duration);

    event requiredparticipationupdated(uint fraction);

    event requiredmajorityupdated(uint fraction);

    event confiscationvote(address indexed initiator, address indexed target);

    event votefor(address indexed account, address indexed target, uint balance);

    event voteagainst(address indexed account, address indexed target, uint balance);

    event cancelledvote(address indexed account, address indexed target);

    event voteclosed(address indexed target);

    event veto(address indexed target);

    event confiscationapproval(address indexed target);
}



pragma solidity ^0.4.19;


import ;


contract erc20token is safedecimalmath {

    

    
    
    uint public totalsupply;
    string public name;
    string public symbol;
    mapping(address => uint) public balanceof;
    mapping(address => mapping (address => uint256)) public allowance;


    

    function erc20token(string _name, string _symbol,
                        uint initialsupply, address initialbeneficiary)
        public
    {
        name = _name;
        symbol = _symbol;
        totalsupply = initialsupply;
        balanceof[initialbeneficiary] = initialsupply;
    }


    

    function transfer(address _to, uint _value)
        public
        returns (bool)
    {
        
        transfer(msg.sender, _to, _value);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[msg.sender] = safesub(balanceof[msg.sender], _value);
        balanceof[_to] = safeadd(balanceof[_to], _value);

        return true;
    }

    function transferfrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        
        transfer(_from, _to, _value);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[_from] = safesub(balanceof[_from], _value);
        allowance[_from][msg.sender] = safesub(allowance[_from][msg.sender], _value);
        balanceof[_to] = safeadd(balanceof[_to], _value);

        return true;
    }

    function approve(address _spender, uint _value)
        public
        returns (bool)
    {
        allowance[msg.sender][_spender] = _value;
        approval(msg.sender, _spender, _value);
        return true;
    }


    

    event transfer(address indexed _from, address indexed _to, uint _value);

    event approval(address indexed _owner, address indexed _spender, uint _value);

}



pragma solidity ^0.4.19;



contract safedecimalmath {

    
    uint public constant decimals = 18;

    
    uint public constant unit = 10 ** decimals;

    
    function addissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        return x + y >= y;
    }

    
    function safeadd(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        require(addissafe(x, y));
        return x + y;
    }

    
    function subissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        return y <= x;
    }

    
    function safesub(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        require(subissafe(x, y));
        return x  y;
    }

    
    function mulissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        if (x == 0) {
            return true;
        }
        uint r = x * y;
        return r / x == y;
    }

    
    function safemul(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        require(mulissafe(x, y));
        return x * y;
    }

    
    function safedecmul(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        
        
        return safemul(x, y) / unit;

    }

    
    function divissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        return y != 0;
    }

    
    function safediv(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        
        
        
        require(divissafe(x, y));
        return x / y;
    }

    
    function safedecdiv(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        
        return safediv(safemul(x, unit), y);
    }

    
    function inttodec(uint i)
        pure
        internal
        returns (uint)
    {
        return safemul(i, unit);
    }
}



pragma solidity ^0.4.19;


import ;
import ;


contract erc20feetoken is owned, safedecimalmath {

    

    
    
    uint public totalsupply;
    string public name;
    string public symbol;
    mapping(address => uint) public balanceof;
    mapping(address => mapping (address => uint256)) public allowance;

    
    
    uint public transferfeerate;
    
    uint constant maxtransferfeerate = unit / 10;

    
    uint public feepool = 0;

    
    address public feeauthority;


    

    function erc20feetoken(string _name, string _symbol,
                           uint initialsupply, address initialbeneficiary,
                           uint _feerate, address _feeauthority,
                           address _owner)
        owned(_owner)
        public
    {
        name = _name;
        symbol = _symbol;
        totalsupply = initialsupply;
        balanceof[initialbeneficiary] = initialsupply;
        transferfeerate = _feerate;
        feeauthority = _feeauthority;
    }


    

    function settransferfeerate(uint newfeerate)
        public
        onlyowner
    {
        require(newfeerate <= maxtransferfeerate);
        transferfeerate = newfeerate;
        transferfeerateupdate(newfeerate);
    }


    

    
    function transferfeeincurred(uint _value)
        public
        view
        returns (uint)
    {
        return safedecmul(_value, transferfeerate);
        
        
        
        
        
        
        
    }

    
    
    function transferplusfee(uint _value)
        public
        view
        returns (uint)
    {
        return safeadd(_value, safedecmul(_value, transferfeerate));
    }


    

    function transfer(address _to, uint _value)
        public
        returns (bool)
    {
        
        
        uint fee = transferfeeincurred(_value);
        uint totalcharge = safeadd(_value, fee);

        
        transfer(msg.sender, _to, _value);
        transferfeepaid(msg.sender, fee);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[msg.sender] = safesub(balanceof[msg.sender], totalcharge);
        balanceof[_to] = safeadd(balanceof[_to], _value);
        feepool = safeadd(feepool, fee);

        return true;
    }

    function transferfrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        
        
        uint fee = transferfeeincurred(_value);
        uint totalcharge = safeadd(_value, fee);

        
        transfer(_from, _to, _value);
        transferfeepaid(msg.sender, fee);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[_from] = safesub(balanceof[_from], totalcharge);
        allowance[_from][msg.sender] = safesub(allowance[_from][msg.sender], totalcharge);
        balanceof[_to] = safeadd(balanceof[_to], _value);
        feepool = safeadd(feepool, fee);

        return true;
    }

    function approve(address _spender, uint _value)
        public
        returns (bool)
    {
        allowance[msg.sender][_spender] = _value;
        approval(msg.sender, _spender, _value);
        return true;
    }

    
    function withdrawfee(address account, uint value)
        public
    {
        require(msg.sender == feeauthority);
        
        feepool = safesub(feepool, value);
        balanceof[account] = safeadd(balanceof[account], value);
        feewithdrawal(account, value);
    }


    

    event transfer(address indexed _from, address indexed _to, uint _value);

    event transferfeepaid(address indexed account, uint value);

    event approval(address indexed _owner, address indexed _spender, uint _value);

    event transferfeerateupdate(uint newfeerate);

    event feewithdrawal(address indexed account, uint value);
}




pragma solidity ^0.4.19;

contract owned {
    address public owner;

    function owned(address _owner)
        public
    {
        owner = _owner;
    }

    function setowner(address newowner)
        public
        onlyowner
    {
        owner = newowner;
        ownerchanged(owner, newowner);
    }

    modifier onlyowner
    {
        require(msg.sender == owner);
        _;
    }

    event ownerchanged(address oldowner, address newowner);
}



pragma solidity ^0.4.19;


import ;
import ;
import ;


contract ethernomin is erc20feetoken {

    

    
    
    address public oracle;

    
    court public court;

    
    address public beneficiary;

    
    uint public nominpool = 0;

    
    uint public poolfeerate = unit / 200;

    
    uint constant purchasemininum = unit / 100;

    
    uint constant collatratiominimum =  2 * unit;

    
    
    uint constant autoliquidationratio = unit;

    
    
    uint constant defaultliquidationperiod = 90 days;
    uint constant maxliquidationperiod = 180 days;
    uint public liquidationperiod = defaultliquidationperiod;

    
    
    
    uint public liquidationtimestamp = ~uint(0);

    
    uint public etherprice;

    
    uint public lastpriceupdate;

    
    
    uint public staleperiod = 2 days;

    
    mapping(address => bool) public isfrozen;


    

    function ethernomin(havven _havven, address _oracle,
                        address _beneficiary,
                        uint initialetherprice,
                        address _owner)
        erc20feetoken(, ,
                      0, _owner,
                      unit / 500, 
                      address(_havven), 
                      _owner)
        public
    {
        oracle = _oracle;
        beneficiary = _beneficiary;

        etherprice = initialetherprice;
        lastpriceupdate = now;
        priceupdated(etherprice);

        isfrozen[this] = true;
    }


    

    
    function setoracle(address neworacle)
        public
        onlyowner
    {
        oracle = neworacle;
        oracleupdated(neworacle);
    }

    function setcourt(address newcourt)
        public
        onlyowner
    {
        court = court(newcourt);
        courtupdated(newcourt);
    }

    
    function setbeneficiary(address newbeneficiary)
        public
        onlyowner
    {
        beneficiary = newbeneficiary;
        beneficiaryupdated(newbeneficiary);
    }

    function setpoolfeerate(uint newfeerate)
        public
        onlyowner
    {
        require(newfeerate <= unit);
        poolfeerate = newfeerate;
        poolfeerateupdated(newfeerate);
    }

    
    function setstaleperiod(uint period)
        public
        onlyowner
    {
        staleperiod = period;
        staleperiodupdated(period);
    }

    

    
    function fiatvalue(uint eth)
        public
        view
        pricenotstale
        returns (uint)
    {
        return safedecmul(eth, etherprice);
    }

    
    function fiatbalance()
        public
        view
        returns (uint)
    {
        
        return fiatvalue(this.balance);
    }

    
    function ethervalue(uint fiat)
        public
        view
        pricenotstale
        returns (uint)
    {
        return safedecdiv(fiat, etherprice);
    }

    
    function ethervalueallowstale(uint fiat) 
        internal
        view
        returns (uint)
    {
        return safedecdiv(fiat, etherprice);
    }

    
    function collateralisationratio()
        public
        view
        returns (uint)
    {
        return safedecdiv(fiatbalance(), totalsupply);
    }

    
    function poolfeeincurred(uint n)
        public
        view
        returns (uint)
    {
        return safedecmul(n, poolfeerate);
    }

    
    function purchasecostfiat(uint n)
        public
        view
        returns (uint)
    {
        return safeadd(n, poolfeeincurred(n));
    }

    
    function purchasecostether(uint n)
        public
        view
        returns (uint)
    {
        
        return ethervalue(purchasecostfiat(n));
    }

    
    function saleproceedsfiat(uint n)
        public
        view
        returns (uint)
    {
        return safesub(n, poolfeeincurred(n));
    }

    
    function saleproceedsether(uint n)
        public
        view
        returns (uint)
    {
        
        return ethervalue(saleproceedsfiat(n));
    }

    
    function saleproceedsetherallowstale(uint n)
        internal
        view
        returns (uint)
    {
        return ethervalueallowstale(saleproceedsfiat(n));
    }

    
    function priceisstale()
        public
        view
        returns (bool)
    {
        return lastpriceupdate + staleperiod < now;
    }

    function isliquidating()
        public
        view
        returns (bool)
    {
        return liquidationtimestamp <= now;
    }

    
    function canselfdestruct()
        public
        view
        returns (bool)
    {
        
        
        if (isliquidating()) {
            bool totalperiodelapsed = liquidationtimestamp + liquidationperiod < now;
            bool alltokensreturned = (liquidationtimestamp + 1 weeks < now) && (nominpool == totalsupply);
            return totalperiodelapsed || alltokensreturned;
        }
        return false;
    }


    

    
    function transfer(address _to, uint _value)
        public
        returns (bool)
    {
        require(!(isfrozen[msg.sender] || isfrozen[_to]));
        return super.transfer(_to, _value);
    }

    
    function transferfrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        require(!(isfrozen[_from] || isfrozen[_to]));
        return super.transferfrom(_from, _to, _value);
    }

    
    function updateprice(uint price)
        public
        postcheckautoliquidate
    {
        
        require(msg.sender == oracle);

        etherprice = price;
        lastpriceupdate = now;
        priceupdated(price);
    }

    
    function issue(uint n)
        public
        onlyowner
        payable
        notliquidating
    {
        
        
        
        require(fiatbalance() >= safedecmul(totalsupply + n, collatratiominimum));
        totalsupply = safeadd(totalsupply, n);
        nominpool = safeadd(nominpool, n);
        issuance(n, msg.value);
    }

    
    function burn(uint n)
        public
        onlyowner
    {
        
        require(nominpool >= n);
        nominpool = safesub(nominpool, n);
        totalsupply = safesub(totalsupply, n);
        burning(n);
    }

    
    function buy(uint n)
        public
        notliquidating
        payable
    {
        
        require(n >= purchasemininum &&
                msg.value == purchasecostether(n));
        
        nominpool = safesub(nominpool, n);
        balanceof[msg.sender] = safeadd(balanceof[msg.sender], n);
        purchase(msg.sender, n, msg.value);
    }

    
    function sell(uint n)
        public
    {

        
        
        
        uint proceeds;
        if (isliquidating()) {
            proceeds = saleproceedsetherallowstale(n);
        } else {
            proceeds = saleproceedsether(n);
        }

        require(this.balance >= proceeds);

        
        balanceof[msg.sender] = safesub(balanceof[msg.sender], n);
        nominpool = safeadd(nominpool, n);
        sale(msg.sender, n, proceeds);
        msg.sender.transfer(proceeds);
    }

    
    function forceliquidation()
        public
        onlyowner
        notliquidating
    {
        beginliquidation();
    }

    function beginliquidation()
        internal
    {
        liquidationtimestamp = now;
        liquidation(liquidationperiod);
    }

    
    function extendliquidationperiod(uint extension)
        public
        onlyowner
    {
        require(isliquidating());
        require(liquidationperiod + extension <= maxliquidationperiod);
        liquidationperiod += extension;
        liquidationextended(extension);
    }

    
    function terminateliquidation()
        public
        onlyowner
        pricenotstale
        payable
    {
        require(isliquidating());
        require(totalsupply == 0 || collateralisationratio() >= autoliquidationratio);
        liquidationtimestamp = ~uint(0);
        liquidationperiod = defaultliquidationperiod;
        liquidationterminated();
    }

    
    function selfdestruct()
        public
        onlyowner
    {
        require(canselfdestruct());
        selfdestructed();
        selfdestruct(beneficiary);
    }

    
    function confiscatebalance(address target)
        public
    {
        
        require(court(msg.sender) == court);

        
        
        
        require(court.confirming(target));
        require(court.votepasses(target));

        
        uint balance = balanceof[target];
        feepool = safeadd(feepool, balance);
        balanceof[target] = 0;
        isfrozen[target] = true;
        confiscation(target, balance);
    }

    function unfreezeaccount(address target)
        public
        onlyowner
    {
        if (isfrozen[target] && ethernomin(target) != this) {
            isfrozen[target] = false;
            accountunfrozen(target);
        }
    }

    
    function() public payable {}


    

    modifier notliquidating
    {
        require(!isliquidating());
        _;
    }

    modifier pricenotstale
    {
        require(!priceisstale());
        _;
    }

    
    modifier postcheckautoliquidate
    {
        _;
        if (!isliquidating() && totalsupply != 0 && collateralisationratio() < autoliquidationratio) {
            beginliquidation();
        }
    }


    

    event issuance(uint nominsissued, uint collateraldeposited);

    event burning(uint nominsburned);

    event purchase(address buyer, uint nomins, uint eth);

    event sale(address seller, uint nomins, uint eth);

    event priceupdated(uint newprice);

    event staleperiodupdated(uint newperiod);

    event oracleupdated(address neworacle);

    event courtupdated(address newcourt);

    event beneficiaryupdated(address newbeneficiary);

    event liquidation(uint duration);

    event liquidationterminated();

    event liquidationextended(uint extension);

    event poolfeerateupdated(uint newfeerate);

    event selfdestructed();

    event confiscation(address indexed target, uint balance);

    event accountunfrozen(address indexed target);
}


pragma solidity ^0.4.19;

import ;

contract publicmath is safedecimalmath {
    function pubaddissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return addissafe(x, y);
    }

    function pubsafeadd(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safeadd(x, y);
    }

    function pubsubissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return subissafe(x, y);
    }

    function pubsafesub(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safesub(x, y);
    }

    function pubmulissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return mulissafe(x, y);
    }

	function pubsafemul(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safemul(x, y);
    }

    function pubsafedecmul(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safedecmul(x, y);
    }

    function pubdivissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return divissafe(x, y);
    }

	function pubsafediv(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safediv(x, y);
    }

    function pubsafedecdiv(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safedecdiv(x, y);
    }

    function pubinttodec(uint i)
        pure
        public
        returns (uint)
    {
        return inttodec(i);
    }
}


pragma solidity ^0.4.19;

import ;

contract publicethernomin is ethernomin {

	function publicethernomin(havven _havven, address _oracle,
                              address _beneficiary,
                              uint initialetherprice,
                              address _owner)
		ethernomin(_havven, _oracle, _beneficiary, initialetherprice, _owner)
		public {}

	function publicethervalueallowstale(uint n) 
		public
		view
		returns (uint)
	{
		return ethervalueallowstale(n);
	}

	function publicsaleproceedsetherallowstale(uint n)
		public
		view
		returns (uint)
	{
		return saleproceedsetherallowstale(n);
	}

	function debugwithdrawallether(address recipient)
		public
	{
		recipient.send(this.balance);
	}
	
	function debugemptyfeepool()
		public
	{
		feepool = 0;
	}

	function debugfreezeaccount(address target)
		public
	{
		isfrozen[target] = true;
	}
}

pragma solidity ^0.4.19;

import ;

contract fakecourt {
		ethernomin public nomin;

		mapping(address => bool) public confirming;
		mapping(address => bool) public votepasses;

		function setnomin(ethernomin newnomin)
			public
		{
			nomin = newnomin;
		}

		function setconfirming(address target, bool status)
			public
		{
			confirming[target] = status;
		}

		function setvotepasses(address target, bool status)
			public
		{
			votepasses[target] = status;
		}

		function confiscatebalance(address target)
			public
		{
			nomin.confiscatebalance(target);
		}
}

