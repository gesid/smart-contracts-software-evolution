


pragma solidity 0.4.25;


import ;


contract state is owned {
    
    
    address public associatedcontract;


    constructor(address _owner, address _associatedcontract)
        owned(_owner)
        public
    {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    
    function setassociatedcontract(address _associatedcontract)
        external
        onlyowner
    {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    modifier onlyassociatedcontract
    {
        require(msg.sender == associatedcontract, );
        _;
    }

    

    event associatedcontractupdated(address associatedcontract);
}



pragma solidity 0.4.25;

import ;
import ;
import ;

contract synth is externstatetoken {

    

    feepool public feepool;
    synthetix public synthetix;

    
    bytes4 public currencykey;

    uint8 constant decimals = 18;

    

    constructor(address _proxy, tokenstate _tokenstate, synthetix _synthetix, feepool _feepool,
        string _tokenname, string _tokensymbol, address _owner, bytes4 _currencykey
    )
        externstatetoken(_proxy, _tokenstate, _tokenname, _tokensymbol, 0, decimals, _owner)
        public
    {
        require(_proxy != 0, );
        require(address(_synthetix) != 0, );
        require(address(_feepool) != 0, );
        require(_owner != 0, );
        require(_synthetix.synths(_currencykey) == synth(0), );

        feepool = _feepool;
        synthetix = _synthetix;
        currencykey = _currencykey;
    }

    

    function setsynthetix(synthetix _synthetix)
        external
        optionalproxy_onlyowner
    {
        synthetix = _synthetix;
        emitsynthetixupdated(_synthetix);
    }

    function setfeepool(feepool _feepool)
        external
        optionalproxy_onlyowner
    {
        feepool = _feepool;
        emitfeepoolupdated(_feepool);
    }

    

    
    function transfer(address to, uint value)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        bytes memory empty;
        return _internaltransfer(messagesender, to, amountreceived, empty);
    }

    
    function transfer(address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        return _internaltransfer(messagesender, to, amountreceived, data);
    }

    
    function transferfrom(address from, address to, uint value)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        bytes memory empty;
        return _internaltransfer(from, to, amountreceived, empty);
    }

    
    function transferfrom(address from, address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        return _internaltransfer(from, to, amountreceived, data);
    }

    
    function transfersenderpaysfee(address to, uint value)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        bytes memory empty;
        return _internaltransfer(messagesender, to, value, empty);
    }

    
    function transfersenderpaysfee(address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        return _internaltransfer(messagesender, to, value, data);
    }

    
    function transferfromsenderpaysfee(address from, address to, uint value)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value.add(fee)));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        bytes memory empty;
        return _internaltransfer(from, to, value, empty);
    }

    
    function transferfromsenderpaysfee(address from, address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value.add(fee)));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        return _internaltransfer(from, to, value, data);
    }

    
    function _internaltransfer(address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        bytes4 preferredcurrencykey = synthetix.synthetixstate().preferredcurrency(to);

        
        if (preferredcurrencykey != 0 && preferredcurrencykey != currencykey) {
            return synthetix.synthinitiatedexchange(from, currencykey, value, preferredcurrencykey, to);
        } else {
            
            return super._internaltransfer(from, to, value, data);
        }
    }

    
    function issue(address account, uint amount)
        external
        onlysynthetixorfeepool
    {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).add(amount));
        totalsupply = totalsupply.add(amount);
        emittransfer(address(0), account, amount);
        emitissued(account, amount);
    }

    
    function burn(address account, uint amount)
        external
        onlysynthetixorfeepool
    {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).sub(amount));
        totalsupply = totalsupply.sub(amount);
        emittransfer(account, address(0), amount);
        emitburned(account, amount);
    }

    
    function settotalsupply(uint amount)
        external
        optionalproxy_onlyowner
    {
        totalsupply = amount;
    }

    
    
    function triggertokenfallbackifneeded(address sender, address recipient, uint amount)
        external
        onlysynthetixorfeepool
    {
        bytes memory empty;
        calltokenfallbackifneeded(sender, recipient, amount, empty);
    }

    

    modifier onlysynthetixorfeepool() {
        bool issynthetix = msg.sender == address(synthetix);
        bool isfeepool = msg.sender == address(feepool);

        require(issynthetix || isfeepool, );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != feepool.fee_address(), );
        _;
    }

    

    event synthetixupdated(address newsynthetix);
    bytes32 constant synthetixupdated_sig = keccak256();
    function emitsynthetixupdated(address newsynthetix) internal {
        proxy._emit(abi.encode(newsynthetix), 1, synthetixupdated_sig, 0, 0, 0);
    }

    event feepoolupdated(address newfeepool);
    bytes32 constant feepoolupdated_sig = keccak256();
    function emitfeepoolupdated(address newfeepool) internal {
        proxy._emit(abi.encode(newfeepool), 1, feepoolupdated_sig, 0, 0, 0);
    }

    event issued(address indexed account, uint value);
    bytes32 constant issued_sig = keccak256();
    function emitissued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, issued_sig, bytes32(account), 0, 0);
    }

    event burned(address indexed account, uint value);
    bytes32 constant burned_sig = keccak256();
    function emitburned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, burned_sig, bytes32(account), 0, 0);
    }
}



pragma solidity 0.4.25;

import ;

contract tokenfallbackcaller is reentrancypreventer {
    function calltokenfallbackifneeded(address sender, address recipient, uint amount, bytes data)
        internal
        preventreentrancy
    {
        

        
        uint length;

        
        assembly {
            
            length := extcodesize(recipient)
        }

        
        if (length > 0) {
            
            

            
            recipient.call(abi.encodewithsignature(, sender, amount, data));

            
        }
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;


contract externstatetoken is selfdestructible, proxyable, tokenfallbackcaller {

    using safemath for uint;
    using safedecimalmath for uint;

    

    
    tokenstate public tokenstate;

    
    string public name;
    string public symbol;
    uint public totalsupply;
    uint8 public decimals;

    
    constructor(address _proxy, tokenstate _tokenstate,
                string _name, string _symbol, uint _totalsupply,
                uint8 _decimals, address _owner)
        selfdestructible(_owner)
        proxyable(_proxy, _owner)
        public
    {
        tokenstate = _tokenstate;

        name = _name;
        symbol = _symbol;
        totalsupply = _totalsupply;
        decimals = _decimals;
    }

    

    
    function allowance(address owner, address spender)
        public
        view
        returns (uint)
    {
        return tokenstate.allowance(owner, spender);
    }

    
    function balanceof(address account)
        public
        view
        returns (uint)
    {
        return tokenstate.balanceof(account);
    }

    

     
    function settokenstate(tokenstate _tokenstate)
        external
        optionalproxy_onlyowner
    {
        tokenstate = _tokenstate;
        emittokenstateupdated(_tokenstate);
    }

    function _internaltransfer(address from, address to, uint value, bytes data) 
        internal
        returns (bool)
    { 
        
        require(to != address(0), );
        require(to != address(this), );
        require(to != address(proxy), );

        
        tokenstate.setbalanceof(from, tokenstate.balanceof(from).sub(value));
        tokenstate.setbalanceof(to, tokenstate.balanceof(to).add(value));

        
        
        
        calltokenfallbackifneeded(from, to, value, data);
        
        
        emittransfer(from, to, value);

        return true;
    }

    
    function _transfer_byproxy(address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        return _internaltransfer(from, to, value, data);
    }

    
    function _transferfrom_byproxy(address sender, address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        
        tokenstate.setallowance(from, sender, tokenstate.allowance(from, sender).sub(value));
        return _internaltransfer(from, to, value, data);
    }

    
    function approve(address spender, uint value)
        public
        optionalproxy
        returns (bool)
    {
        address sender = messagesender;

        tokenstate.setallowance(sender, spender, value);
        emitapproval(sender, spender, value);
        return true;
    }

    

    event transfer(address indexed from, address indexed to, uint value);
    bytes32 constant transfer_sig = keccak256();
    function emittransfer(address from, address to, uint value) internal {
        proxy._emit(abi.encode(value), 3, transfer_sig, bytes32(from), bytes32(to), 0);
    }

    event approval(address indexed owner, address indexed spender, uint value);
    bytes32 constant approval_sig = keccak256();
    function emitapproval(address owner, address spender, uint value) internal {
        proxy._emit(abi.encode(value), 3, approval_sig, bytes32(owner), bytes32(spender), 0);
    }

    event tokenstateupdated(address newtokenstate);
    bytes32 constant tokenstateupdated_sig = keccak256();
    function emittokenstateupdated(address newtokenstate) internal {
        proxy._emit(abi.encode(newtokenstate), 1, tokenstateupdated_sig, 0, 0, 0);
    }
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;
import ;


contract synthetixescrow is owned, limitedsetup(8 weeks) {

    using safemath for uint;

    
    synthetix public synthetix;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalvestedbalance;

    uint constant time_index = 0;
    uint constant quantity_index = 1;

    
    uint constant max_vesting_entries = 20;


    

    constructor(address _owner, synthetix _synthetix)
        owned(_owner)
        public
    {
        synthetix = _synthetix;
    }


    

    function setsynthetix(synthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }


    

    
    function balanceof(address account)
        public
        view
        returns (uint)
    {
        return totalvestedaccountbalance[account];
    }

    
    function numvestingentries(address account)
        public
        view
        returns (uint)
    {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index)
        public
        view
        returns (uint[2])
    {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index)
        public
        view
        returns (uint)
    {
        return getvestingscheduleentry(account,index)[time_index];
    }

    
    function getvestingquantity(address account, uint index)
        public
        view
        returns (uint)
    {
        return getvestingscheduleentry(account,index)[quantity_index];
    }

    
    function getnextvestingindex(address account)
        public
        view
        returns (uint)
    {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account)
        public
        view
        returns (uint[2])
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account)
        external
        view
        returns (uint)
    {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account)
        external
        view
        returns (uint)
    {
        return getnextvestingentry(account)[quantity_index];
    }


    

    
    function withdrawsynthetix(uint quantity)
        external
        onlyowner
        onlyduringsetup
    {
        synthetix.transfer(synthetix, quantity);
    }

    
    function purgeaccount(address account)
        external
        onlyowner
        onlyduringsetup
    {
        delete vestingschedules[account];
        totalvestedbalance = totalvestedbalance.sub(totalvestedaccountbalance[account]);
        delete totalvestedaccountbalance[account];
    }

    
    function appendvestingentry(address account, uint time, uint quantity)
        public
        onlyowner
        onlyduringsetup
    {
        
        require(now < time, );
        require(quantity != 0, );

        
        totalvestedbalance = totalvestedbalance.add(quantity);
        require(totalvestedbalance <= synthetix.balanceof(this), );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        if (schedulelength == 0) {
            totalvestedaccountbalance[account] = quantity;
        } else {
            
            require(getvestingtime(account, numvestingentries(account)  1) < time, );
            totalvestedaccountbalance[account] = totalvestedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);
    }

    
    function addvestingschedule(address account, uint[] times, uint[] quantities)
        external
        onlyowner
        onlyduringsetup
    {
        for (uint i = 0; i < times.length; i++) {
            appendvestingentry(account, times[i], quantities[i]);
        }

    }

    
    function vest()
        external
    {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalvestedbalance = totalvestedbalance.sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].sub(total);
            synthetix.transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }


    

    event synthetixupdated(address newsynthetix);

    event vested(address indexed beneficiary, uint time, uint value);
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;


contract synthetixstate is state, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    
    mapping(address => issuancedata) public issuancedata;

    
    uint public totalissuercount;

    
    uint[] public debtledger;

    
    uint public importedxdramount;

    
    
    uint public issuanceratio = safedecimalmath.unit() / 5;
    
    uint constant max_issuance_ratio = safedecimalmath.unit();

    
    
    mapping(address => bytes4) public preferredcurrency;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        limitedsetup(1 weeks)
        public
    {}

    

    
    function setcurrentissuancedata(address account, uint initialdebtownership)
        external
        onlyassociatedcontract
    {
        issuancedata[account].initialdebtownership = initialdebtownership;
        issuancedata[account].debtentryindex = debtledger.length;
    }

    
    function clearissuancedata(address account)
        external
        onlyassociatedcontract
    {
        delete issuancedata[account];
    }

    
    function incrementtotalissuercount()
        external
        onlyassociatedcontract
    {
        totalissuercount = totalissuercount.add(1);
    }

    
    function decrementtotalissuercount()
        external
        onlyassociatedcontract
    {
        totalissuercount = totalissuercount.sub(1);
    }

    
    function appenddebtledgervalue(uint value)
        external
        onlyassociatedcontract
    {
        debtledger.push(value);
    }

    
    function setpreferredcurrency(address account, bytes4 currencykey)
        external
        onlyassociatedcontract
    {
        preferredcurrency[account] = currencykey;
    }

    
    function setissuanceratio(uint _issuanceratio)
        external
        onlyowner
    {
        require(_issuanceratio <= max_issuance_ratio, );
        issuanceratio = _issuanceratio;
        emit issuanceratioupdated(_issuanceratio);
    }

    
    function importissuerdata(address[] accounts, uint[] susdamounts)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == susdamounts.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            _addtodebtregister(accounts[i], susdamounts[i]);
        }
    }

    
    function _addtodebtregister(address account, uint amount)
        internal
    {
        
        
        synthetix synthetix = synthetix(associatedcontract);

        
        uint xdrvalue = synthetix.effectivevalue(, amount, );

        
        uint totaldebtissued = importedxdramount;

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        importedxdramount = newtotaldebtissued;

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        uint existingdebt = synthetix.debtbalanceof(account, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (issuancedata[account].initialdebtownership == 0) {
            totalissuercount = totalissuercount.add(1);
        }

        
        issuancedata[account].initialdebtownership = debtpercentage;
        issuancedata[account].debtentryindex = debtledger.length;

        
        
        if (debtledger.length > 0) {
            debtledger.push(
                debtledger[debtledger.length  1].multiplydecimalroundprecise(delta)
            );
        } else {
            debtledger.push(safedecimalmath.preciseunit());
        }
    }

    

    
    function debtledgerlength()
        external
        view
        returns (uint)
    {
        return debtledger.length;
    }

    
    function lastdebtledgerentry()
        external
        view
        returns (uint)
    {
        return debtledger[debtledger.length  1];
    }

    
    function hasissued(address account)
        external
        view
        returns (bool)
    {
        return issuancedata[account].initialdebtownership > 0;
    }

    event issuanceratioupdated(uint newratio);
}



pragma solidity 0.4.25;


import ;



contract selfdestructible is owned {
    
    uint public initiationtime;
    bool public selfdestructinitiated;
    address public selfdestructbeneficiary;
    uint public constant selfdestruct_delay = 4 weeks;

    
    constructor(address _owner)
        owned(_owner)
        public
    {
        require(_owner != address(0), );
        selfdestructbeneficiary = _owner;
        emit selfdestructbeneficiaryupdated(_owner);
    }

    
    function setselfdestructbeneficiary(address _beneficiary)
        external
        onlyowner
    {
        require(_beneficiary != address(0), );
        selfdestructbeneficiary = _beneficiary;
        emit selfdestructbeneficiaryupdated(_beneficiary);
    }

    
    function initiateselfdestruct()
        external
        onlyowner
    {
        initiationtime = now;
        selfdestructinitiated = true;
        emit selfdestructinitiated(selfdestruct_delay);
    }

    
    function terminateselfdestruct()
        external
        onlyowner
    {
        initiationtime = 0;
        selfdestructinitiated = false;
        emit selfdestructterminated();
    }

    
    function selfdestruct()
        external
        onlyowner
    {
        require(selfdestructinitiated, );
        require(initiationtime + selfdestruct_delay < now, );
        address beneficiary = selfdestructbeneficiary;
        emit selfdestructed(beneficiary);
        selfdestruct(beneficiary);
    }

    event selfdestructterminated();
    event selfdestructed(address beneficiary);
    event selfdestructinitiated(uint selfdestructdelay);
    event selfdestructbeneficiaryupdated(address newbeneficiary);
}

pragma solidity 0.4.25;

contract migrations {
    address public owner;
    uint public last_completed_migration;

    constructor() public {
        owner = msg.sender;
    }

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function setcompleted(uint completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        migrations upgraded = migrations(new_address);
        upgraded.setcompleted(last_completed_migration);
    }
}

pragma solidity 0.4.25;

contract synthetixescrow {
    function numvestingentries(address account) public returns (uint);
    function getvestingscheduleentry(address account, uint index) public returns (uint[2]);
}

contract escrowchecker {
    synthetixescrow public synthetix_escrow;
    function escrowchecker(synthetixescrow _esc) public {
        synthetix_escrow = _esc;
    }

    function checkaccountschedule(address account)
        public
        view
        returns (uint[16])
    {
        uint[16] memory _result;
        uint schedules = synthetix_escrow.numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = synthetix_escrow.getvestingscheduleentry(account, i);
            _result[i*2] = pair[0];
            _result[i*2 + 1] = pair[1];
        }
        return _result;
    }
}



pragma solidity 0.4.25;


import ;



contract pausable is owned {
    
    uint public lastpausetime;
    bool public paused;

    
    constructor(address _owner)
        owned(_owner)
        public
    {
        
    }

    
    function setpaused(bool _paused)
        external
        onlyowner
    {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;
        
        
        if (paused) {
            lastpausetime = now;
        }

        
        emit pausechanged(paused);
    }

    event pausechanged(bool ispaused);

    modifier notpaused {
        require(!paused, );
        _;
    }
}



pragma solidity 0.4.25;

import ;


library safedecimalmath {

    using safemath for uint;

    
    uint8 public constant decimals = 18;
    uint8 public constant highprecisiondecimals = 27;

    
    uint public constant unit = 10 ** uint(decimals);

    
    uint public constant precise_unit = 10 ** uint(highprecisiondecimals);
    uint private constant unit_to_high_precision_conversion_factor = 10 ** uint(highprecisiondecimals  decimals);

    
    function unit()
        external
        pure
        returns (uint)
    {
        return unit;
    }

    
    function preciseunit()
        external
        pure 
        returns (uint)
    {
        return precise_unit;
    }

    
    function multiplydecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        
        return x.mul(y) / unit;
    }

    
    function _multiplydecimalround(uint x, uint y, uint precisionunit)
        private
        pure
        returns (uint)
    {
        
        uint quotienttimesten = x.mul(y) / (precisionunit / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

    
    function multiplydecimalroundprecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplydecimalround(x, y, precise_unit);
    }

    
    function multiplydecimalround(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplydecimalround(x, y, unit);
    }

    
    function dividedecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        
        return x.mul(unit).div(y);
    }

    
    function _dividedecimalround(uint x, uint y, uint precisionunit)
        private
        pure
        returns (uint)
    {
        uint resulttimesten = x.mul(precisionunit * 10).div(y);

        if (resulttimesten % 10 >= 5) {
            resulttimesten += 10;
        }

        return resulttimesten / 10;
    }

    
    function dividedecimalround(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _dividedecimalround(x, y, unit);
    }

    
    function dividedecimalroundprecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _dividedecimalround(x, y, precise_unit);
    }

    
    function decimaltoprecisedecimal(uint i)
        internal
        pure
        returns (uint)
    {
        return i.mul(unit_to_high_precision_conversion_factor);
    }

    
    function precisedecimaltodecimal(uint i)
        internal
        pure
        returns (uint)
    {
        uint quotienttimesten = i / (unit_to_high_precision_conversion_factor / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

}




pragma solidity 0.4.25;


import ;
import ;


contract proxy is owned {

    proxyable public target;
    bool public usedelegatecall;

    constructor(address _owner)
        owned(_owner)
        public
    {}

    function settarget(proxyable _target)
        external
        onlyowner
    {
        target = _target;
        emit targetupdated(_target);
    }

    function setusedelegatecall(bool value) 
        external
        onlyowner
    {
        usedelegatecall = value;
    }

    function _emit(bytes calldata, uint numtopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlytarget
    {
        uint size = calldata.length;
        bytes memory _calldata = calldata;

        assembly {
            
            switch numtopics
            case 0 {
                log0(add(_calldata, 32), size)
            } 
            case 1 {
                log1(add(_calldata, 32), size, topic1)
            }
            case 2 {
                log2(add(_calldata, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_calldata, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_calldata, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
        external
        payable
    {
        if (usedelegatecall) {
            assembly {
                
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            
            target.setmessagesender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlytarget {
        require(proxyable(msg.sender) == target, );
        _;
    }

    event targetupdated(proxyable newtarget);
}




pragma solidity 0.4.25;


contract limitedsetup {

    uint setupexpirytime;

    
    constructor(uint setupduration)
        public
    {
        setupexpirytime = now + setupduration;
    }

    modifier onlyduringsetup
    {
        require(now < setupexpirytime, );
        _;
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;


contract exchangerates is selfdestructible {

    using safemath for uint;

    
    mapping(bytes4 => uint) public rates;

    
    mapping(bytes4 => uint) public lastrateupdatetimes;

    
    address public oracle;

    
    uint constant oracle_future_limit = 10 minutes;

    
    uint public ratestaleperiod = 3 hours;

    
    
    
    bytes4[5] public xdrparticipants;

    

    
    constructor(
        
        address _owner,

        
        address _oracle,
        bytes4[] _currencykeys,
        uint[] _newrates
    )
        
        selfdestructible(_owner)
        public
    {
        require(_currencykeys.length == _newrates.length, );

        oracle = _oracle;

        
        rates[] = safedecimalmath.unit();
        lastrateupdatetimes[] = now;

        
        
        
        
        
        
        
        xdrparticipants = [
            bytes4(),
            bytes4(),
            bytes4(),
            bytes4(),
            bytes4()
        ];

        internalupdaterates(_currencykeys, _newrates, now);
    }

    

    
    function updaterates(bytes4[] currencykeys, uint[] newrates, uint timesent)
        external
        onlyoracle
        returns(bool)
    {
        return internalupdaterates(currencykeys, newrates, timesent);
    }

    
    function internalupdaterates(bytes4[] currencykeys, uint[] newrates, uint timesent)
        internal
        returns(bool)
    {
        require(currencykeys.length == newrates.length, );
        require(timesent < (now + oracle_future_limit), );

        
        for (uint i = 0; i < currencykeys.length; i++) {
            
            
            
            require(newrates[i] != 0, );
            require(currencykeys[i] != , );

            
            if (timesent >= lastrateupdatetimes[currencykeys[i]]) {
                
                rates[currencykeys[i]] = newrates[i];
                lastrateupdatetimes[currencykeys[i]] = timesent;
            }
        }

        emit ratesupdated(currencykeys, newrates);

        
        updatexdrrate(timesent);

        return true;
    }

    
    function updatexdrrate(uint timesent)
        internal
    {
        uint total = 0;

        for (uint i = 0; i < xdrparticipants.length; i++) {
            total = rates[xdrparticipants[i]].add(total);
        }

        
        rates[] = total;

        
        lastrateupdatetimes[] = timesent;

        
        
        bytes4[] memory eventcurrencycode = new bytes4[](1);
        eventcurrencycode[0] = ;

        uint[] memory eventrate = new uint[](1);
        eventrate[0] = rates[];

        emit ratesupdated(eventcurrencycode, eventrate);
    }

    
    function deleterate(bytes4 currencykey)
        external
        onlyoracle
    {
        require(rates[currencykey] > 0, );

        delete rates[currencykey];
        delete lastrateupdatetimes[currencykey];

        emit ratedeleted(currencykey);
    }

    
    function setoracle(address _oracle)
        external
        onlyowner
    {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    
    function setratestaleperiod(uint _time)
        external
        onlyowner
    {
        ratestaleperiod = _time;
        emit ratestaleperiodupdated(ratestaleperiod);
    }

    

    
    function rateforcurrency(bytes4 currencykey)
        public
        view
        returns (uint)
    {
        return rates[currencykey];
    }

    
    function ratesforcurrencies(bytes4[] currencykeys)
        public
        view
        returns (uint[])
    {
        uint[] memory _rates = new uint[](currencykeys.length);

        for (uint8 i = 0; i < currencykeys.length; i++) {
            _rates[i] = rates[currencykeys[i]];
        }

        return _rates;
    }

    
    function lastrateupdatetimeforcurrency(bytes4 currencykey)
        public
        view
        returns (uint)
    {
        return lastrateupdatetimes[currencykey];
    }

    
    function lastrateupdatetimesforcurrencies(bytes4[] currencykeys)
        public
        view
        returns (uint[])
    {
        uint[] memory lastupdatetimes = new uint[](currencykeys.length);

        for (uint8 i = 0; i < currencykeys.length; i++) {
            lastupdatetimes[i] = lastrateupdatetimes[currencykeys[i]];
        }

        return lastupdatetimes;
    }

    
    function rateisstale(bytes4 currencykey)
        external
        view
        returns (bool)
    {
        
        if (currencykey == ) return false;

        return lastrateupdatetimes[currencykey].add(ratestaleperiod) < now;
    }

    
    function anyrateisstale(bytes4[] currencykeys)
        external
        view
        returns (bool)
    {
        
        uint256 i = 0;

        while (i < currencykeys.length) {
            
            if (currencykeys[i] !=  && lastrateupdatetimes[currencykeys[i]].add(ratestaleperiod) < now) {
                return true;
            }
            i += 1;
        }

        return false;
    }

    

    modifier onlyoracle
    {
        require(msg.sender == oracle, );
        _;
    }

    

    event oracleupdated(address neworacle);
    event ratestaleperiodupdated(uint ratestaleperiod);
    event ratesupdated(bytes4[] currencykeys, uint[] newrates);
    event ratedeleted(bytes4 currencykey);
}




pragma solidity 0.4.25;

import ;
import ;


contract proxyable is owned {
    
    proxy public proxy;

     
    address messagesender; 

    constructor(address _proxy, address _owner)
        owned(_owner)
        public
    {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setproxy(address _proxy)
        external
        onlyowner
    {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setmessagesender(address sender)
        external
        onlyproxy
    {
        messagesender = sender;
    }

    modifier onlyproxy {
        require(proxy(msg.sender) == proxy, );
        _;
    }

    modifier optionalproxy
    {
        if (proxy(msg.sender) != proxy) {
            messagesender = msg.sender;
        }
        _;
    }

    modifier optionalproxy_onlyowner
    {
        if (proxy(msg.sender) != proxy) {
            messagesender = msg.sender;
        }
        require(messagesender == owner, );
        _;
    }

    event proxyupdated(address proxyaddress);
}



pragma solidity 0.4.25;


import ;


contract tokenstate is state {

    
    mapping(address => uint) public balanceof;
    mapping(address => mapping(address => uint)) public allowance;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {}

    

    
    function setallowance(address tokenowner, address spender, uint value)
        external
        onlyassociatedcontract
    {
        allowance[tokenowner][spender] = value;
    }

    
    function setbalanceof(address account, uint value)
        external
        onlyassociatedcontract
    {
        balanceof[account] = value;
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;

contract feepool is proxyable, selfdestructible {

    using safemath for uint;
    using safedecimalmath for uint;

    synthetix public synthetix;

    
    uint public transferfeerate;

    
    uint constant public max_transfer_fee_rate = safedecimalmath.unit() / 10;

    
    uint public exchangefeerate;

    
    uint constant public max_exchange_fee_rate = safedecimalmath.unit() / 10;

    
    address public feeauthority;

    
    address public constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    
    struct feeperiod {
        uint feeperiodid;
        uint startingdebtindex;
        uint starttime;
        uint feestodistribute;
        uint feesclaimed;
    }

    
    
    
    
    uint8 constant public fee_period_length = 6;
    feeperiod[fee_period_length] public recentfeeperiods;

    
    uint public nextfeeperiodid;

    
    
    
    
    uint public feeperiodduration = 1 weeks;

    
    uint public constant min_fee_period_duration = 1 days;
    uint public constant max_fee_period_duration = 60 days;

    
    mapping(address => uint) public lastfeewithdrawal;

    
    
    uint constant twenty_percent = (20 * safedecimalmath.unit()) / 100;
    uint constant twenty_five_percent = (25 * safedecimalmath.unit()) / 100;
    uint constant thirty_percent = (30 * safedecimalmath.unit()) / 100;
    uint constant fourty_percent = (40 * safedecimalmath.unit()) / 100;
    uint constant fifty_percent = (50 * safedecimalmath.unit()) / 100;
    uint constant seventy_five_percent = (75 * safedecimalmath.unit()) / 100;

    constructor(address _proxy, address _owner, synthetix _synthetix, address _feeauthority, uint _transferfeerate, uint _exchangefeerate)
        selfdestructible(_owner)
        proxyable(_proxy, _owner)
        public
    {
        
        require(_transferfeerate <= max_transfer_fee_rate, );
        require(_exchangefeerate <= max_exchange_fee_rate, );

        synthetix = _synthetix;
        feeauthority = _feeauthority;
        transferfeerate = _transferfeerate;
        exchangefeerate = _exchangefeerate;

        
        recentfeeperiods[0].feeperiodid = 1;
        recentfeeperiods[0].starttime = now;
        
        
        

        
        nextfeeperiodid = 2;
    }

    
    function setexchangefeerate(uint _exchangefeerate)
        external
        optionalproxy_onlyowner
    {
        require(_exchangefeerate <= max_exchange_fee_rate, );

        exchangefeerate = _exchangefeerate;

        emitexchangefeeupdated(_exchangefeerate);
    }

    
    function settransferfeerate(uint _transferfeerate)
        external
        optionalproxy_onlyowner
    {
        require(_transferfeerate <= max_transfer_fee_rate, );

        transferfeerate = _transferfeerate;

        emittransferfeeupdated(_transferfeerate);
    }

    
    function setfeeauthority(address _feeauthority)
        external
        optionalproxy_onlyowner
    {
        feeauthority = _feeauthority;

        emitfeeauthorityupdated(_feeauthority);
    }

    
    function setfeeperiodduration(uint _feeperiodduration)
        external
        optionalproxy_onlyowner
    {
        require(_feeperiodduration >= min_fee_period_duration, );
        require(_feeperiodduration <= max_fee_period_duration, );

        feeperiodduration = _feeperiodduration;

        emitfeeperioddurationupdated(_feeperiodduration);
    }

    
    function setsynthetix(synthetix _synthetix)
        external
        optionalproxy_onlyowner
    {
        require(address(_synthetix) != address(0), );

        synthetix = _synthetix;

        emitsynthetixupdated(_synthetix);
    }

    
    function feepaid(bytes4 currencykey, uint amount)
        external
        onlysynthetix
    {
        uint xdramount = synthetix.effectivevalue(currencykey, amount, );

        
        recentfeeperiods[0].feestodistribute = recentfeeperiods[0].feestodistribute.add(xdramount);
    }

    
    function closecurrentfeeperiod()
        external
        onlyfeeauthority
    {
        require(recentfeeperiods[0].starttime <= (now  feeperiodduration), );

        feeperiod memory secondlastfeeperiod = recentfeeperiods[fee_period_length  2];
        feeperiod memory lastfeeperiod = recentfeeperiods[fee_period_length  1];

        
        
        
        
        
        recentfeeperiods[fee_period_length  2].feestodistribute = lastfeeperiod.feestodistribute
            .sub(lastfeeperiod.feesclaimed)
            .add(secondlastfeeperiod.feestodistribute);

        
        
        
        
        
        for (uint i = fee_period_length  2; i < fee_period_length; i) {
            uint next = i + 1;

            recentfeeperiods[next].feeperiodid = recentfeeperiods[i].feeperiodid;
            recentfeeperiods[next].startingdebtindex = recentfeeperiods[i].startingdebtindex;
            recentfeeperiods[next].starttime = recentfeeperiods[i].starttime;
            recentfeeperiods[next].feestodistribute = recentfeeperiods[i].feestodistribute;
            recentfeeperiods[next].feesclaimed = recentfeeperiods[i].feesclaimed;
        }

        
        delete recentfeeperiods[0];

        
        recentfeeperiods[0].feeperiodid = nextfeeperiodid;
        recentfeeperiods[0].startingdebtindex = synthetix.synthetixstate().debtledgerlength();
        recentfeeperiods[0].starttime = now;

        nextfeeperiodid = nextfeeperiodid.add(1);

        emitfeeperiodclosed(recentfeeperiods[1].feeperiodid);
    }

    
    function claimfees(bytes4 currencykey)
        external
        optionalproxy
        returns (bool)
    {
        uint availablefees = feesavailable(messagesender, );

        require(availablefees > 0, );

        lastfeewithdrawal[messagesender] = recentfeeperiods[1].feeperiodid;

        
        _recordfeepayment(availablefees);

        
        _payfees(messagesender, availablefees, currencykey);

        emitfeesclaimed(messagesender, availablefees);

        return true;
    }

    
    function _recordfeepayment(uint xdramount)
        internal
    {
        
        uint remainingtoallocate = xdramount;

        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint delta = recentfeeperiods[i].feestodistribute.sub(recentfeeperiods[i].feesclaimed);

            if (delta > 0) {
                
                uint amountinperiod = delta < remainingtoallocate ? delta : remainingtoallocate;

                recentfeeperiods[i].feesclaimed = recentfeeperiods[i].feesclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);

                
                if (remainingtoallocate == 0) return;
            }
        }

        
        
        assert(remainingtoallocate == 0);
    }

    
    function _payfees(address account, uint xdramount, bytes4 destinationcurrencykey)
        internal
        notfeeaddress(account)
    {
        require(account != address(0), );
        require(account != address(this), );
        require(account != address(proxy), );
        require(account != address(synthetix), );

        synth xdrsynth = synthetix.synths();
        synth destinationsynth = synthetix.synths(destinationcurrencykey);

        
        

        
        xdrsynth.burn(fee_address, xdramount);

        
        uint destinationamount = synthetix.effectivevalue(, xdramount, destinationcurrencykey);

        

        
        destinationsynth.issue(account, destinationamount);

        

        
        destinationsynth.triggertokenfallbackifneeded(fee_address, account, destinationamount);
    }

    
    function transferfeeincurred(uint value)
        public
        view
        returns (uint)
    {
        return value.multiplydecimal(transferfeerate);

        
        
        
        
        
        
        
    }

    
    function transferredamounttoreceive(uint value)
        external
        view
        returns (uint)
    {
        return value.add(transferfeeincurred(value));
    }

    
    function amountreceivedfromtransfer(uint value)
        external
        view
        returns (uint)
    {
        return value.dividedecimal(transferfeerate.add(safedecimalmath.unit()));
    }

    
    function exchangefeeincurred(uint value)
        public
        view
        returns (uint)
    {
        return value.multiplydecimal(exchangefeerate);

        
        
        
        
        
        
        
    }

    
    function exchangedamounttoreceive(uint value)
        external
        view
        returns (uint)
    {
        return value.add(exchangefeeincurred(value));
    }

    
    function amountreceivedfromexchange(uint value)
        external
        view
        returns (uint)
    {
        return value.dividedecimal(exchangefeerate.add(safedecimalmath.unit()));
    }

    
    function totalfeesavailable(bytes4 currencykey)
        external
        view
        returns (uint)
    {
        uint totalfees = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(recentfeeperiods[i].feestodistribute);
            totalfees = totalfees.sub(recentfeeperiods[i].feesclaimed);
        }

        return synthetix.effectivevalue(, totalfees, currencykey);
    }

    
    function feesavailable(address account, bytes4 currencykey)
        public
        view
        returns (uint)
    {
        
        uint[fee_period_length] memory userfees = feesbyperiod(account);

        uint totalfees = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(userfees[i]);
        }

        
        return synthetix.effectivevalue(, totalfees, currencykey);
    }

    
    function currentpenalty(address account)
        public
        view
        returns (uint)
    {
        uint ratio = synthetix.collateralisationratio(account);

        
        
        
        
        
        if (ratio <= twenty_percent) {
            return 0;
        } else if (ratio > twenty_percent && ratio <= thirty_percent) {
            return twenty_five_percent;
        } else if (ratio > thirty_percent && ratio <= fourty_percent) {
            return fifty_percent;
        }

        return seventy_five_percent;
    }

    
    function feesbyperiod(address account)
        public
        view
        returns (uint[fee_period_length])
    {
        uint[fee_period_length] memory result;

        
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetix.synthetixstate().issuancedata(account);

        
        if (initialdebtownership == 0) return result;

        
        uint totalsynths = synthetix.totalissuedsynths();
        if (totalsynths == 0) return result;

        uint debtbalance = synthetix.debtbalanceof(account, );
        uint userownershippercentage = debtbalance.dividedecimal(totalsynths);
        uint penalty = currentpenalty(account);
        
        
        
        
        for (uint i = 0; i < fee_period_length; i++) {
            
            
            
            if (recentfeeperiods[i].startingdebtindex > debtentryindex &&
                lastfeewithdrawal[account] < recentfeeperiods[i].feeperiodid) {

                
                uint feesfromperiodwithoutpenalty = recentfeeperiods[i].feestodistribute
                    .multiplydecimal(userownershippercentage);

                
                uint penaltyfromperiod = feesfromperiodwithoutpenalty.multiplydecimal(penalty);
                uint feesfromperiod = feesfromperiodwithoutpenalty.sub(penaltyfromperiod);

                result[i] = feesfromperiod;
            }
        }

        return result;
    }

    modifier onlyfeeauthority
    {
        require(msg.sender == feeauthority, );
        _;
    }

    modifier onlysynthetix
    {
        require(msg.sender == address(synthetix), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != fee_address, );
        _;
    }

    event transferfeeupdated(uint newfeerate);
    bytes32 constant transferfeeupdated_sig = keccak256();
    function emittransferfeeupdated(uint newfeerate) internal {
        proxy._emit(abi.encode(newfeerate), 1, transferfeeupdated_sig, 0, 0, 0);
    }

    event exchangefeeupdated(uint newfeerate);
    bytes32 constant exchangefeeupdated_sig = keccak256();
    function emitexchangefeeupdated(uint newfeerate) internal {
        proxy._emit(abi.encode(newfeerate), 1, exchangefeeupdated_sig, 0, 0, 0);
    }

    event feeperioddurationupdated(uint newfeeperiodduration);
    bytes32 constant feeperioddurationupdated_sig = keccak256();
    function emitfeeperioddurationupdated(uint newfeeperiodduration) internal {
        proxy._emit(abi.encode(newfeeperiodduration), 1, feeperioddurationupdated_sig, 0, 0, 0);
    }

    event feeauthorityupdated(address newfeeauthority);
    bytes32 constant feeauthorityupdated_sig = keccak256();
    function emitfeeauthorityupdated(address newfeeauthority) internal {
        proxy._emit(abi.encode(newfeeauthority), 1, feeauthorityupdated_sig, 0, 0, 0);
    }

    event feeperiodclosed(uint feeperiodid);
    bytes32 constant feeperiodclosed_sig = keccak256();
    function emitfeeperiodclosed(uint feeperiodid) internal {
        proxy._emit(abi.encode(feeperiodid), 1, feeperiodclosed_sig, 0, 0, 0);
    }

    event feesclaimed(address account, uint xdramount);
    bytes32 constant feesclaimed_sig = keccak256();
    function emitfeesclaimed(address account, uint xdramount) internal {
        proxy._emit(abi.encode(account, xdramount), 1, feesclaimed_sig, 0, 0, 0);
    }

    event synthetixupdated(address newsynthetix);
    bytes32 constant synthetixupdated_sig = keccak256();
    function emitsynthetixupdated(address newsynthetix) internal {
        proxy._emit(abi.encode(newsynthetix), 1, synthetixupdated_sig, 0, 0, 0);
    }
}



pragma solidity 0.4.25;

contract reentrancypreventer {
    
    bool isinfunctionbody = false;

    modifier preventreentrancy {
        require(!isinfunctionbody, );
        isinfunctionbody = true;
        _;
        isinfunctionbody = false;
    }
}


pragma solidity 0.4.25;


contract owned {
    address public owner;
    address public nominatedowner;

    
    constructor(address _owner)
        public
    {
        require(_owner != address(0), );
        owner = _owner;
        emit ownerchanged(address(0), _owner);
    }

    
    function nominatenewowner(address _owner)
        external
        onlyowner
    {
        nominatedowner = _owner;
        emit ownernominated(_owner);
    }

    
    function acceptownership()
        external
    {
        require(msg.sender == nominatedowner, );
        emit ownerchanged(owner, nominatedowner);
        owner = nominatedowner;
        nominatedowner = address(0);
    }

    modifier onlyowner
    {
        require(msg.sender == owner, );
        _;
    }

    event ownernominated(address newowner);
    event ownerchanged(address oldowner, address newowner);
}


pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;


contract depot is selfdestructible, pausable {
    using safemath for uint;
    using safedecimalmath for uint;

    
    synthetix public synthetix;
    synth public synth;
    feepool public feepool;

    
    
    
    address public fundswallet;

    
    address public oracle;
    
    uint public constant oracle_future_limit = 10 minutes;

    
    uint public pricestaleperiod = 3 hours;

    
    uint public lastpriceupdatetime;
    
    uint public usdtosnxprice;
    
    uint public usdtoethprice;

    
    struct synthdeposit {
        
        address user;
        
        uint amount;
    }

    
    mapping(uint => synthdeposit) public deposits;
    
    uint public depositstartindex;
    
    uint public depositendindex;

    
    uint public totalsellabledeposits;

    
    uint public minimumdepositamount = 50 * safedecimalmath.unit();

    
    
    
    mapping(address => uint) public smalldeposits;


    

    
    constructor(
        
        address _owner,

        
        address _fundswallet,

        
        synthetix _synthetix,
        synth _synth,
		feepool _feepool,

        
        address _oracle,
        uint _usdtoethprice,
        uint _usdtosnxprice
    )
        
        selfdestructible(_owner)
        pausable(_owner)
        public
    {
        fundswallet = _fundswallet;
        synthetix = _synthetix;
        synth = _synth;
        feepool = _feepool;
        oracle = _oracle;
        usdtoethprice = _usdtoethprice;
        usdtosnxprice = _usdtosnxprice;
        lastpriceupdatetime = now;
    }

    

    
    function setfundswallet(address _fundswallet)
        external
        onlyowner
    {
        fundswallet = _fundswallet;
        emit fundswalletupdated(fundswallet);
    }

    
    function setoracle(address _oracle)
        external
        onlyowner
    {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    
    function setsynth(synth _synth)
        external
        onlyowner
    {
        synth = _synth;
        emit synthupdated(_synth);
    }

    
    function setsynthetix(synthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }

    
    function setpricestaleperiod(uint _time)
        external
        onlyowner
    {
        pricestaleperiod = _time;
        emit pricestaleperiodupdated(pricestaleperiod);
    }

    
    function setminimumdepositamount(uint _amount)
        external
        onlyowner
    {
        
        require(_amount > safedecimalmath.unit(), );
        minimumdepositamount = _amount;
        emit minimumdepositamountupdated(minimumdepositamount);
    }

    
    
    function updateprices(uint newethprice, uint newsynthetixprice, uint timesent)
        external
        onlyoracle
    {
        
        require(lastpriceupdatetime < timesent, );
        require(timesent < (now + oracle_future_limit), );

        usdtoethprice = newethprice;
        usdtosnxprice = newsynthetixprice;
        lastpriceupdatetime = timesent;

        emit pricesupdated(usdtoethprice, usdtosnxprice, lastpriceupdatetime);
    }

    
    function ()
        external
        payable
    {
        exchangeetherforsynths();
    }

    
    function exchangeetherforsynths()
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        uint ethtosend;

        
        
        uint requestedtopurchase = msg.value.multiplydecimal(usdtoethprice);
        uint remainingtofulfill = requestedtopurchase;

        
        for (uint i = depositstartindex; remainingtofulfill > 0 && i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            
            
            if (deposit.user == address(0)) {

                depositstartindex = depositstartindex.add(1);
            } else {
                
                
                if (deposit.amount > remainingtofulfill) {

                    
                    
                    
                    uint newamount = deposit.amount.sub(remainingtofulfill);
                    deposits[i] = synthdeposit({ user: deposit.user, amount: newamount});
                    
                    totalsellabledeposits = totalsellabledeposits.sub(remainingtofulfill);

                    
                    
                    
                    
                    
                    ethtosend = remainingtofulfill.dividedecimal(usdtoethprice);

                    
                    
                    
                    
                    if(!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, remainingtofulfill, i);
                    }

                    
                    
                    
                    
                    synth.transfer(msg.sender, remainingtofulfill);

                    
                    remainingtofulfill = 0;
                } else if (deposit.amount <= remainingtofulfill) {
                    
                    
                    
                    delete deposits[i];
                    
                    depositstartindex = depositstartindex.add(1);
                    
                    totalsellabledeposits = totalsellabledeposits.sub(deposit.amount);

                    
                    
                    
                    
                    
                    ethtosend = deposit.amount.dividedecimal(usdtoethprice);

                    
                    
                    
                    
                    if(!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, deposit.amount, i);
                    }

                    
                    
                    
                    
                    synth.transfer(msg.sender, deposit.amount);

                    
                    
                    remainingtofulfill = remainingtofulfill.sub(deposit.amount);
                }
            }
        }

        
        
        if (remainingtofulfill > 0) {
            msg.sender.transfer(remainingtofulfill.dividedecimal(usdtoethprice));
        }

        
        uint fulfilled = requestedtopurchase.sub(remainingtofulfill);

        if (fulfilled > 0) {
            
            emit exchange(, msg.value, , fulfilled);
        }

        return fulfilled;
    }

    
    function exchangeetherforsynthsatrate(uint guaranteedrate)
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedrate == usdtoethprice, );

        return exchangeetherforsynths();
    }


    
    function exchangeetherforsynthetix()
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        
        uint synthetixtosend = synthetixreceivedforether(msg.value);

        
        fundswallet.transfer(msg.value);

        
        synthetix.transfer(msg.sender, synthetixtosend);

        emit exchange(, msg.value, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangeetherforsynthetixatrate(uint guaranteedetherrate, uint guaranteedsynthetixrate)
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedetherrate == usdtoethprice, );
        require(guaranteedsynthetixrate == usdtosnxprice, );

        return exchangeetherforsynthetix();
    }


    
    function exchangesynthsforsynthetix(uint synthamount)
        public
        pricesnotstale
        notpaused
        returns (uint) 
    {
        
        uint synthetixtosend = synthetixreceivedforsynths(synthamount);

        
        
        
        synth.transferfrom(msg.sender, fundswallet, synthamount);

        
        synthetix.transfer(msg.sender, synthetixtosend);

        emit exchange(, synthamount, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangesynthsforsynthetixatrate(uint synthamount, uint guaranteedrate)
        public
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedrate == usdtosnxprice, );

        return exchangesynthsforsynthetix(synthamount);
    }

    
    function withdrawsynthetix(uint amount)
        external
        onlyowner
    {
        synthetix.transfer(owner, amount);

        
        
        
        
    }

    
    function withdrawmydepositedsynths()
        external
    {
        uint synthstosend = 0;

        for (uint i = depositstartindex; i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            if (deposit.user == msg.sender) {
                
                
                synthstosend = synthstosend.add(deposit.amount);
                delete deposits[i];
                
                emit synthdepositremoved(deposit.user, deposit.amount, i);
            }
        }

        
        totalsellabledeposits = totalsellabledeposits.sub(synthstosend);

        
        
        synthstosend = synthstosend.add(smalldeposits[msg.sender]);
        smalldeposits[msg.sender] = 0;

        
        require(synthstosend > 0, );

        
        synth.transfer(msg.sender, synthstosend);

        emit synthwithdrawal(msg.sender, synthstosend);
    }

    
    function depositsynths(uint amount)
        external
    {
        
        synth.transferfrom(msg.sender, this, amount);

        
        
    }

    
    function tokenfallback(address from, uint amount, bytes data)
        external
        onlysynth
        returns (bool)
    {
        
        
        if (amount < minimumdepositamount) {
            
            
            smalldeposits[from] = smalldeposits[from].add(amount);

            emit synthdepositnotaccepted(from, amount, minimumdepositamount);
        } else {
            
            deposits[depositendindex] = synthdeposit({ user: from, amount: amount });
            emit synthdeposit(from, amount, depositendindex);

            
            depositendindex = depositendindex.add(1);

            
            totalsellabledeposits = totalsellabledeposits.add(amount);
        }
    }

    
    
    function pricesarestale()
        public
        view
        returns (bool)
    {
        return lastpriceupdatetime.add(pricestaleperiod) < now;
    }

    
    function synthetixreceivedforsynths(uint amount)
        public
        view
        returns (uint)
    {
        
        uint synthsreceived = feepool.amountreceivedfromtransfer(amount);

        
        return synthsreceived.dividedecimal(usdtosnxprice);
    }

    
    function synthetixreceivedforether(uint amount)
        public
        view
        returns (uint)
    {
        
        uint valuesentinsynths = amount.multiplydecimal(usdtoethprice);

        
        return synthetixreceivedforsynths(valuesentinsynths);
    }

    
    function synthsreceivedforether(uint amount)
        public
        view
        returns (uint)
    {
        
        uint synthstransferred = amount.multiplydecimal(usdtoethprice);

        
        return feepool.amountreceivedfromtransfer(synthstransferred);
    }

    

    modifier onlyoracle
    {
        require(msg.sender == oracle, );
        _;
    }

    modifier onlysynth
    {
        
        require(msg.sender == address(synth), );
        _;
    }

    modifier pricesnotstale
    {
        require(!pricesarestale(), );
        _;
    }

    

    event fundswalletupdated(address newfundswallet);
    event oracleupdated(address neworacle);
    event synthupdated(synth newsynthcontract);
    event synthetixupdated(synthetix newsynthetixcontract);
    event pricestaleperiodupdated(uint pricestaleperiod);
    event pricesupdated(uint newethprice, uint newsynthetixprice, uint timesent);
    event exchange(string fromcurrency, uint fromamount, string tocurrency, uint toamount);
    event synthwithdrawal(address user, uint amount);
    event synthdeposit(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositremoved(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositnotaccepted(address user, uint amount, uint minimum);
    event minimumdepositamountupdated(uint amount);
    event nonpayablecontract(address indexed receiver, uint amount);
    event cleareddeposit(address indexed fromaddress, address indexed toaddress, uint fromethamount, uint toamount, uint indexed depositindex);
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract synthetix is externstatetoken {

    

    
    synth[] public availablesynths;
    mapping(bytes4 => synth) public synths;

    feepool public feepool;
    synthetixescrow public escrow;
    exchangerates public exchangerates;
    synthetixstate public synthetixstate;

    uint constant synthetix_supply = 1e8 * safedecimalmath.unit();
    string constant token_name = ;
    string constant token_symbol = ;
    uint8 constant decimals = 18;

    

    
    constructor(address _proxy, tokenstate _tokenstate, synthetixstate _synthetixstate,
        address _owner, exchangerates _exchangerates, feepool _feepool
    )
        externstatetoken(_proxy, _tokenstate, token_name, token_symbol, synthetix_supply, decimals, _owner)
        public
    {
        synthetixstate = _synthetixstate;
        exchangerates = _exchangerates;
        feepool = _feepool;
    }

    

    
    function addsynth(synth synth)
        external
        optionalproxy_onlyowner
    {
        bytes4 currencykey = synth.currencykey();

        require(synths[currencykey] == synth(0), );

        availablesynths.push(synth);
        synths[currencykey] = synth;

        emitsynthadded(currencykey, synth);
    }

    
    function removesynth(bytes4 currencykey)
        external
        optionalproxy_onlyowner
    {
        require(synths[currencykey] != address(0), );
        require(synths[currencykey].totalsupply() == 0, );
        require(currencykey != , );

        
        address synthtoremove = synths[currencykey];

        
        for (uint8 i = 0; i < availablesynths.length; i++) {
            if (availablesynths[i] == synthtoremove) {
                delete availablesynths[i];

                
                
                
                availablesynths[i] = availablesynths[availablesynths.length  1];

                
                availablesynths.length;

                break;
            }
        }

        
        delete synths[currencykey];

        emitsynthremoved(currencykey, synthtoremove);
    }

    
    function setescrow(synthetixescrow _escrow)
        external
        optionalproxy_onlyowner
    {
        escrow = _escrow;
        
        
        
    }

    
    function setexchangerates(exchangerates _exchangerates)
        external
        optionalproxy_onlyowner
    {
        exchangerates = _exchangerates;
        
        
        
    }

    
    function setsynthetixstate(synthetixstate _synthetixstate)
        external
        optionalproxy_onlyowner
    {
        synthetixstate = _synthetixstate;

        emitstatecontractchanged(_synthetixstate);
    }

    
    function setpreferredcurrency(bytes4 currencykey)
        external
        optionalproxy
    {
        require(currencykey == 0 || !exchangerates.rateisstale(currencykey), );

        synthetixstate.setpreferredcurrency(messagesender, currencykey);

        emitpreferredcurrencychanged(messagesender, currencykey);
    }

    

    
    function effectivevalue(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey)
        public
        view
        ratenotstale(sourcecurrencykey)
        ratenotstale(destinationcurrencykey)
        returns (uint)
    {
        
        if (sourcecurrencykey == destinationcurrencykey) return sourceamount;

        
        return sourceamount.multiplydecimalround(exchangerates.rateforcurrency(sourcecurrencykey))
            .dividedecimalround(exchangerates.rateforcurrency(destinationcurrencykey));
    }

    
    function totalissuedsynths(bytes4 currencykey)
        public
        view
        ratenotstale(currencykey)
        returns (uint)
    {
        uint total = 0;
        uint currencyrate = exchangerates.rateforcurrency(currencykey);

        for (uint8 i = 0; i < availablesynths.length; i++) {
            
            
            
            require(!exchangerates.rateisstale(availablesynths[i].currencykey()), );

            
            
            
            
            uint synthvalue = availablesynths[i].totalsupply()
                .multiplydecimalround(exchangerates.rateforcurrency(availablesynths[i].currencykey()))
                .dividedecimalround(currencyrate);
            total = total.add(synthvalue);
        }

        return total;
    }

    
    function availablesynthcount()
        public
        view
        returns (uint)
    {
        return availablesynths.length;
    }

    

    
    function transfer(address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transfer(to, value, empty);
    }

    
    function transfer(address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        require(value <= transferablesynthetix(messagesender), );

        
        _transfer_byproxy(messagesender, to, value, data);

        return true;
    }

    
    function transferfrom(address from, address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transferfrom(from, to, value, empty);
    }

    
    function transferfrom(address from, address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        require(value <= transferablesynthetix(from), );

        
        
        _transferfrom_byproxy(messagesender, from, to, value, data);

        return true;
    }

    
    function exchange(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey, address destinationaddress)
        external
        optionalproxy
        
        returns (bool)
    {
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        
        return _internalexchange(
            messagesender,
            sourcecurrencykey,
            sourceamount,
            destinationcurrencykey,
            destinationaddress == address(0) ? messagesender : destinationaddress,
            true 
        );
    }

    
    function synthinitiatedexchange(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount,
        bytes4 destinationcurrencykey,
        address destinationaddress
    )
        external
        onlysynth
        returns (bool)
    {
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        
        return _internalexchange(
            from,
            sourcecurrencykey,
            sourceamount,
            destinationcurrencykey,
            destinationaddress,
            false 
        );
    }

    
    function synthinitiatedfeepayment(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount
    )
        external
        onlysynth
        returns (bool)
    {
        require(sourceamount > 0, );

        
        bool result = _internalexchange(
            from,
            sourcecurrencykey,
            sourceamount,
            ,
            feepool.fee_address(),
            false 
        );

        
        feepool.feepaid(sourcecurrencykey, sourceamount);

        return result;
    }

    
    function _internalexchange(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount,
        bytes4 destinationcurrencykey,
        address destinationaddress,
        bool chargefee
    )
        internal
        notfeeaddress(from)
        returns (bool)
    {
        require(destinationaddress != address(0), );
        require(destinationaddress != address(this), );
        require(destinationaddress != address(proxy), );

        
        

        
        synths[sourcecurrencykey].burn(from, sourceamount);

        
        uint destinationamount = effectivevalue(sourcecurrencykey, sourceamount, destinationcurrencykey);

        
        uint amountreceived = destinationamount;
        uint fee = 0;

        if (chargefee) {
            amountreceived = feepool.amountreceivedfromexchange(destinationamount);
            fee = destinationamount.sub(amountreceived);
        }

        
        synths[destinationcurrencykey].issue(destinationaddress, amountreceived);

        
        if (fee > 0) {
            uint xdrfeeamount = effectivevalue(destinationcurrencykey, fee, );
            synths[].issue(feepool.fee_address(), xdrfeeamount);
        }

        

        
        synths[destinationcurrencykey].triggertokenfallbackifneeded(from, destinationaddress, amountreceived);

        
        
        

        return true;
    }

    
    function _addtodebtregister(bytes4 currencykey, uint amount)
        internal
        optionalproxy
    {
        
        uint xdrvalue = effectivevalue(currencykey, amount, );

        
        uint totaldebtissued = totalissuedsynths();

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        
        uint existingdebt = debtbalanceof(messagesender, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (!synthetixstate.hasissued(messagesender)) {
            synthetixstate.incrementtotalissuercount();
        }

        
        synthetixstate.setcurrentissuancedata(messagesender, debtpercentage);

        
        
        if (synthetixstate.debtledgerlength() > 0) {
            synthetixstate.appenddebtledgervalue(
                synthetixstate.lastdebtledgerentry().multiplydecimalroundprecise(delta)
            );
        } else {
            synthetixstate.appenddebtledgervalue(safedecimalmath.preciseunit());
        }
    }

    
    function issuesynths(bytes4 currencykey, uint amount)
        public
        optionalproxy
        nonzeroamount(amount)
        
    {
        require(amount <= remainingissuablesynths(messagesender, currencykey), );

        
        _addtodebtregister(currencykey, amount);

        
        synths[currencykey].issue(messagesender, amount);
    }

    
    function issuemaxsynths(bytes4 currencykey)
        external
        optionalproxy
    {
        
        uint maxissuable = remainingissuablesynths(messagesender, currencykey);

        
        issuesynths(currencykey, maxissuable);
    }

    
    function burnsynths(bytes4 currencykey, uint amount)
        external
        optionalproxy
        
        
    {
        
        uint debt = debtbalanceof(messagesender, currencykey);

        require(debt > 0, );

        
        
        uint amounttoburn = debt < amount ? debt : amount;

        
        _removefromdebtregister(currencykey, amounttoburn);

        
        synths[currencykey].burn(messagesender, amounttoburn);
    }

    
    function _removefromdebtregister(bytes4 currencykey, uint amount)
        internal
    {
        
        uint debttoremove = effectivevalue(currencykey, amount, );

        
        uint existingdebt = debtbalanceof(messagesender, );

        
        uint totaldebtissued = totalissuedsynths();
        uint debtpercentage = debttoremove.dividedecimalroundprecise(totaldebtissued);

        
        
        
        uint delta = safedecimalmath.preciseunit().add(debtpercentage);

        
        if (debttoremove == existingdebt) {
            synthetixstate.clearissuancedata(messagesender);
            synthetixstate.decrementtotalissuercount();
        } else {
            
            uint newdebt = existingdebt.sub(debttoremove);
            uint newtotaldebtissued = totaldebtissued.sub(debttoremove);
            uint newdebtpercentage = newdebt.dividedecimalroundprecise(newtotaldebtissued);

            
            synthetixstate.setcurrentissuancedata(messagesender, newdebtpercentage);
        }

        
        synthetixstate.appenddebtledgervalue(
            synthetixstate.lastdebtledgerentry().multiplydecimalroundprecise(delta)
        );
    }

    

    
    function maxissuablesynths(address issuer, bytes4 currencykey)
        public
        view
        
        returns (uint)
    {
        
        uint destinationvalue = effectivevalue(, collateral(issuer), currencykey);

        
        return destinationvalue.multiplydecimal(synthetixstate.issuanceratio());
    }

    
    function collateralisationratio(address issuer)
        public
        view
        returns (uint)
    {
        uint totalownedsynthetix = collateral(issuer);
        if (totalownedsynthetix == 0) return 0;

        uint debtbalance = debtbalanceof(issuer, );
        return debtbalance.dividedecimalround(totalownedsynthetix);
    }


    function debtbalanceof(address issuer, bytes4 currencykey)
        public
        view
        
        returns (uint)
    {
        
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetixstate.issuancedata(issuer);

        
        if (initialdebtownership == 0) return 0;

        
        
        uint currentdebtownership = synthetixstate.lastdebtledgerentry()
            .dividedecimalroundprecise(synthetixstate.debtledger(debtentryindex))
            .multiplydecimalroundprecise(initialdebtownership);

        
        uint totalsystemvalue = totalissuedsynths(currencykey);

        
        uint highprecisionbalance = totalsystemvalue.decimaltoprecisedecimal()
            .multiplydecimalroundprecise(currentdebtownership);

        return highprecisionbalance.precisedecimaltodecimal();
    }

    
    function remainingissuablesynths(address issuer, bytes4 currencykey)
        public
        view
        
        returns (uint)
    {
        uint alreadyissued = debtbalanceof(issuer, currencykey);
        uint max = maxissuablesynths(issuer, currencykey);

        if (alreadyissued >= max) {
            return 0;
        } else {
            return max.sub(alreadyissued);
        }
    }

    
    function collateral(address account)
        public
        view
        returns (uint)
    {
        uint balance = tokenstate.balanceof(account);

        if (escrow != address(0)) {
            balance = balance.add(escrow.balanceof(account));
        }

        return balance;
    }

    
    function transferablesynthetix(address account)
        public
        view
        ratenotstale()
        returns (uint)
    {
        
        
        
        uint balance = tokenstate.balanceof(account);

        
        
        
        
        uint lockedsynthetixvalue = debtbalanceof(account, ).dividedecimalround(synthetixstate.issuanceratio());

        
        if (lockedsynthetixvalue >= balance) {
            return 0;
        } else {
            return balance.sub(lockedsynthetixvalue);
        }
    }

    

    modifier ratenotstale(bytes4 currencykey) {
        require(!exchangerates.rateisstale(currencykey), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != feepool.fee_address(), );
        _;
    }

    modifier onlysynth() {
        bool issynth = false;

        
        for (uint8 i = 0; i < availablesynths.length; i++) {
            if (availablesynths[i] == msg.sender) {
                issynth = true;
                break;
            }
        }

        require(issynth, );
        _;
    }

    modifier nonzeroamount(uint _amount) {
        require(_amount > 0, );
        _;
    }

    

    event preferredcurrencychanged(address indexed account, bytes4 newpreferredcurrency);
    bytes32 constant preferredcurrencychanged_sig = keccak256();
    function emitpreferredcurrencychanged(address account, bytes4 newpreferredcurrency) internal {
        proxy._emit(abi.encode(newpreferredcurrency), 2, preferredcurrencychanged_sig, bytes32(account), 0, 0);
    }

    event statecontractchanged(address statecontract);
    bytes32 constant statecontractchanged_sig = keccak256();
    function emitstatecontractchanged(address statecontract) internal {
        proxy._emit(abi.encode(statecontract), 1, statecontractchanged_sig, 0, 0, 0);
    }

    event synthadded(bytes4 currencykey, address newsynth);
    bytes32 constant synthadded_sig = keccak256();
    function emitsynthadded(bytes4 currencykey, address newsynth) internal {
        proxy._emit(abi.encode(currencykey, newsynth), 1, synthadded_sig, 0, 0, 0);
    }

    event synthremoved(bytes4 currencykey, address removedsynth);
    bytes32 constant synthremoved_sig = keccak256();
    function emitsynthremoved(bytes4 currencykey, address removedsynth) internal {
        proxy._emit(abi.encode(currencykey, removedsynth), 1, synthremoved_sig, 0, 0, 0);
    }
}


pragma solidity 0.4.25;

import ;

contract publicsafedecimalmath {
    using safedecimalmath for uint;
    
    function unit()
        public
        pure
        returns (uint)
    {
        return safedecimalmath.unit();
    }

    function preciseunit()
        public
        pure
        returns (uint)
    {
        return safedecimalmath.preciseunit();
    }

    function multiplydecimal(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimal(y);
    }

    function multiplydecimalround(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimalround(y);
    }

    function multiplydecimalroundprecise(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimalroundprecise(y);
    }

    function dividedecimal(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimal(y);
    }

    function dividedecimalround(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimalround(y);
    }

    function dividedecimalroundprecise(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimalroundprecise(y);
    }

    function decimaltoprecisedecimal(uint i)
        public
        pure
        returns (uint)
    {
        return i.decimaltoprecisedecimal();
    }

    function precisedecimaltodecimal(uint i)
        public
        pure
        returns (uint)
    {
        return i.precisedecimaltodecimal();
    }
}

pragma solidity ^0.4.24;

import ;

contract reentranttokenrecipient {
    event tokenfallbackcalled(address from, uint value, bytes data);

    function tokenfallback(address from, uint value, bytes data) public {
        emit tokenfallbackcalled(from, value, data);

        publicest(msg.sender).transferfrom(from, this, value);
    }
}
pragma solidity ^0.4.23;


import ;


contract oneweeksetup is limitedsetup(1 weeks) {
	function testfunc() 
		public
		onlyduringsetup
		returns (bool)
	{
		return true;
	}

	function publicsetupexpirytime()
		public
		returns (uint)
	{
		return setupexpirytime;
	}
}

pragma solidity ^0.4.23;


import ;


contract payablesd is selfdestructible {

    constructor(address _owner)
        selfdestructible(_owner) public {}

    function () public payable {}
}


pragma solidity ^0.4.23;


import ;
import ;

contract publichavvenescrow is havvenescrow {
    using safemath for uint;

    constructor(address _owner, havven _havven)
		havvenescrow(_owner, _havven)
		public 
	{
		
        setupexpirytime = now + 50000 weeks;
    }

    function addregularvestingschedule(address account, uint conclusiontime, uint totalquantity, uint vestingperiods)
        external
        onlyowner
        onlyduringsetup
    {
        
        uint totalduration = conclusiontime.sub(now);

        
        uint periodquantity = totalquantity.div(vestingperiods);
        uint periodduration = totalduration.div(vestingperiods);

        
        for (uint i = 1; i < vestingperiods; i++) {
            uint periodconclusiontime = now.add(i.mul(periodduration));
            appendvestingentry(account, periodconclusiontime, periodquantity);
        }

        
        uint finalperiodquantity = totalquantity.sub(periodquantity.mul(vestingperiods  1));
        appendvestingentry(account, conclusiontime, finalperiodquantity);
    }
}

pragma solidity ^0.4.24;

contract tokenrecipient {
    event tokenfallbackcalled(address from, uint value, bytes data);

    function tokenfallback(address from, uint value, bytes data) public {
        emit tokenfallbackcalled(from, value, data);
    }
}
pragma solidity 0.4.25;

import ;


contract testablepausable is pausable {

    uint public somevalue;

    constructor(address _owner)
        pausable(_owner)
        public
    {}

    function setsomevalue(uint _value)
        external
        notpaused
    {
        somevalue = _value;
    }

}


pragma solidity ^0.4.24;

contract emptytokenrecipient {}
pragma solidity ^0.4.23;

import ;

contract publicest is externstatetoken {
    uint constant decimals = 18;

    constructor(address _proxy, tokenstate _tokenstate,
                string _name, string _symbol, uint _totalsupply,
                address _owner)
        externstatetoken(_proxy, _tokenstate, _name, _symbol, _totalsupply, decimals, _owner)
        public
    {}

    function transfer(address to, uint value)
        optionalproxy
        external
        returns (bool)
    {
        bytes memory empty;
        return _transfer_byproxy(messagesender, to, value, empty);
    }

    function transfer(address to, uint value, bytes data)
        optionalproxy
        external
        returns (bool)
    {
        return _transfer_byproxy(messagesender, to, value, data);
    }

    function transferfrom(address from, address to, uint value)
        optionalproxy
        external
        returns (bool)
    {
        bytes memory empty;
        return _transferfrom_byproxy(messagesender, from, to, value, empty);
    }

    function transferfrom(address from, address to, uint value, bytes data)
        optionalproxy
        external
        returns (bool)
    {
        return _transferfrom_byproxy(messagesender, from, to, value, data);
    }
}

