pragma solidity ^0.4.24;

import ;

contract reentranttokenrecipient {
    event tokenfallbackcalled(address from, uint value, bytes data);

    function tokenfallback(address from, uint value, bytes data) public {
        emit tokenfallbackcalled(from, value, data);

        publicest(msg.sender).transferfrom(from, this, value);
    }
}
pragma solidity ^0.4.23;


import ;


contract oneweeksetup is limitedsetup(1 weeks) {
	function testfunc() 
		public
		onlyduringsetup
		returns (bool)
	{
		return true;
	}

	function publicsetupexpirytime()
		public
		returns (uint)
	{
		return setupexpirytime;
	}
}

pragma solidity ^0.4.23;


import ;


contract payablesd is selfdestructible {

    constructor(address _owner)
        selfdestructible(_owner) public {}

    function () public payable {}
}


pragma solidity ^0.4.23;


import ;
import ;

contract publichavvenescrow is havvenescrow {
    using safemath for uint;

    constructor(address _owner, havven _havven)
		havvenescrow(_owner, _havven)
		public 
	{
		
        setupexpirytime = now + 50000 weeks;
    }

    function addregularvestingschedule(address account, uint conclusiontime, uint totalquantity, uint vestingperiods)
        external
        onlyowner
        onlyduringsetup
    {
        
        uint totalduration = conclusiontime.sub(now);

        
        uint periodquantity = totalquantity.div(vestingperiods);
        uint periodduration = totalduration.div(vestingperiods);

        
        for (uint i = 1; i < vestingperiods; i++) {
            uint periodconclusiontime = now.add(i.mul(periodduration));
            appendvestingentry(account, periodconclusiontime, periodquantity);
        }

        
        uint finalperiodquantity = totalquantity.sub(periodquantity.mul(vestingperiods  1));
        appendvestingentry(account, conclusiontime, finalperiodquantity);
    }
}

pragma solidity ^0.4.24;

contract tokenrecipient {
    event tokenfallbackcalled(address from, uint value, bytes data);

    function tokenfallback(address from, uint value, bytes data) public {
        emit tokenfallbackcalled(from, value, data);
    }
}
pragma solidity 0.4.25;

import ;


contract testablepausable is pausable {

    uint public somevalue;

    constructor(address _owner)
        pausable(_owner)
        public
    {}

    function setsomevalue(uint _value)
        external
        notpaused
    {
        somevalue = _value;
    }

}


pragma solidity ^0.4.24;

contract emptytokenrecipient {}
pragma solidity ^0.4.23;

import ;

contract publicest is externstatetoken {
    uint constant decimals = 18;

    constructor(address _proxy, tokenstate _tokenstate,
                string _name, string _symbol, uint _totalsupply,
                address _owner)
        externstatetoken(_proxy, _tokenstate, _name, _symbol, _totalsupply, decimals, _owner)
        public
    {}

    function transfer(address to, uint value)
        optionalproxy
        external
        returns (bool)
    {
        bytes memory empty;
        return _transfer_byproxy(messagesender, to, value, empty);
    }

    function transfer(address to, uint value, bytes data)
        optionalproxy
        external
        returns (bool)
    {
        return _transfer_byproxy(messagesender, to, value, data);
    }

    function transferfrom(address from, address to, uint value)
        optionalproxy
        external
        returns (bool)
    {
        bytes memory empty;
        return _transferfrom_byproxy(messagesender, from, to, value, empty);
    }

    function transferfrom(address from, address to, uint value, bytes data)
        optionalproxy
        external
        returns (bool)
    {
        return _transferfrom_byproxy(messagesender, from, to, value, data);
    }
}




pragma solidity 0.4.25;


import ;


contract state is owned {
    
    
    address public associatedcontract;


    constructor(address _owner, address _associatedcontract)
        owned(_owner)
        public
    {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    
    function setassociatedcontract(address _associatedcontract)
        external
        onlyowner
    {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    modifier onlyassociatedcontract
    {
        require(msg.sender == associatedcontract, );
        _;
    }

    

    event associatedcontractupdated(address associatedcontract);
}



pragma solidity 0.4.25;
import ;


contract eternalstorage is state {

    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {
    }

    
    mapping(bytes32 => uint) uintstorage;
    mapping(bytes32 => string) stringstorage;
    mapping(bytes32 => address) addressstorage;
    mapping(bytes32 => bytes) bytesstorage;
    mapping(bytes32 => bytes32) bytes32storage;
    mapping(bytes32 => bool) booleanstorage;
    mapping(bytes32 => int) intstorage;

    
    function getuintvalue(bytes32 record) external view returns (uint){
        return uintstorage[record];
    }

    function setuintvalue(bytes32 record, uint value) external
        onlyassociatedcontract
    {
        uintstorage[record] = value;
    }

    function deleteuintvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete uintstorage[record];
    }

    
    function getstringvalue(bytes32 record) external view returns (string memory){
        return stringstorage[record];
    }

    function setstringvalue(bytes32 record, string value) external
        onlyassociatedcontract
    {
        stringstorage[record] = value;
    }

    function deletestringvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete stringstorage[record];
    }

    
    function getaddressvalue(bytes32 record) external view returns (address){
        return addressstorage[record];
    }

    function setaddressvalue(bytes32 record, address value) external
        onlyassociatedcontract
    {
        addressstorage[record] = value;
    }

    function deleteaddressvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete addressstorage[record];
    }


    
    function getbytesvalue(bytes32 record) external view returns
    (bytes memory){
        return bytesstorage[record];
    }

    function setbytesvalue(bytes32 record, bytes value) external
        onlyassociatedcontract
    {
        bytesstorage[record] = value;
    }

    function deletebytesvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete bytesstorage[record];
    }

    
    function getbytes32value(bytes32 record) external view returns (bytes32)
    {
        return bytes32storage[record];
    }

    function setbytes32value(bytes32 record, bytes32 value) external
        onlyassociatedcontract
    {
        bytes32storage[record] = value;
    }

    function deletebytes32value(bytes32 record) external
        onlyassociatedcontract
    {
        delete bytes32storage[record];
    }

    
    function getbooleanvalue(bytes32 record) external view returns (bool)
    {
        return booleanstorage[record];
    }

    function setbooleanvalue(bytes32 record, bool value) external
        onlyassociatedcontract
    {
        booleanstorage[record] = value;
    }

    function deletebooleanvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete booleanstorage[record];
    }

    
    function getintvalue(bytes32 record) external view returns (int){
        return intstorage[record];
    }

    function setintvalue(bytes32 record, int value) external
        onlyassociatedcontract
    {
        intstorage[record] = value;
    }

    function deleteintvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete intstorage[record];
    }
}

pragma solidity 0.4.25;


import ;

contract delegateapprovals is state {

    
    
    mapping(address => mapping(address => bool)) public approval;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {}

    function setapproval(address authoriser, address delegate)
        external
        onlyassociatedcontract
    {
        approval[authoriser][delegate] = true;
        emit approval(authoriser, delegate);
    }

    function withdrawapproval(address authoriser, address delegate)
        external
        onlyassociatedcontract
    {
        delete approval[authoriser][delegate];
        emit withdrawapproval(authoriser, delegate);
    }

     

    event approval(address indexed authoriser, address delegate);
    event withdrawapproval(address indexed authoriser, address delegate);
}




pragma solidity 0.4.25;

import ;
import ;
import ;
import ;


contract purgeablesynth is synth {

    using safedecimalmath for uint;

    
    uint public maxsupplytopurgeinusd = 100000 * safedecimalmath.unit(); 

    
    exchangerates public exchangerates;

    

    constructor(address _proxy, tokenstate _tokenstate, address _synthetixproxy, ifeepool _feepool,
        string _tokenname, string _tokensymbol, address _owner, bytes32 _currencykey, exchangerates _exchangerates, uint _totalsupply
    )
        synth(_proxy, _tokenstate, _synthetixproxy, _feepool, _tokenname, _tokensymbol, _owner, _currencykey, _totalsupply)
        public
    {
        exchangerates = _exchangerates;
    }

    

    
    function purge(address[] addresses)
        external
        optionalproxy_onlyowner
    {
        uint maxsupplytopurge = exchangerates.effectivevalue(, maxsupplytopurgeinusd, currencykey);

        
        require(
            totalsupply <= maxsupplytopurge || exchangerates.rateisfrozen(currencykey),
            
        );

        for (uint i = 0; i < addresses.length; i++) {
            address holder = addresses[i];

            uint amountheld = balanceof(holder);

            if (amountheld > 0) {
                isynthetix(synthetixproxy).synthinitiatedexchange(holder, currencykey, amountheld, , holder);
                emitpurged(holder, amountheld);
            }

        }

    }

    

    function setexchangerates(exchangerates _exchangerates)
        external
        optionalproxy_onlyowner
    {
        exchangerates = _exchangerates;
    }

    

    event purged(address indexed account, uint value);
    bytes32 constant purged_sig = keccak256();
    function emitpurged(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, purged_sig, bytes32(account), 0, 0);
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract synth is externstatetoken {

    

    
    address public feepoolproxy;
    
    address public synthetixproxy;

    
    bytes32 public currencykey;

    uint8 constant decimals = 18;

    

    constructor(address _proxy, tokenstate _tokenstate, address _synthetixproxy, address _feepoolproxy,
        string _tokenname, string _tokensymbol, address _owner, bytes32 _currencykey, uint _totalsupply
    )
        externstatetoken(_proxy, _tokenstate, _tokenname, _tokensymbol, _totalsupply, decimals, _owner)
        public
    {
        require(_proxy != address(0), );
        require(_synthetixproxy != address(0), );
        require(_feepoolproxy != address(0), );
        require(_owner != 0, );
        require(isynthetix(_synthetixproxy).synths(_currencykey) == synth(0), );

        feepoolproxy = _feepoolproxy;
        synthetixproxy = _synthetixproxy;
        currencykey = _currencykey;
    }

    

    
    function setsynthetixproxy(isynthetix _synthetixproxy)
        external
        optionalproxy_onlyowner
    {
        synthetixproxy = _synthetixproxy;
        emitsynthetixupdated(_synthetixproxy);
    }

    
    function setfeepoolproxy(address _feepoolproxy)
        external
        optionalproxy_onlyowner
    {
        feepoolproxy = _feepoolproxy;
        emitfeepoolupdated(_feepoolproxy);
    }

    

    
    function transfer(address to, uint value)
        public
        optionalproxy
        returns (bool)
    {
        bytes memory empty;
        return super._internaltransfer(messagesender, to, value, empty);
    }

    
    function transfer(address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        return super._internaltransfer(messagesender, to, value, data);
    }

    
    function transferfrom(address from, address to, uint value)
        public
        optionalproxy
        returns (bool)
    {
        require(from != 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef, );
        
        if (tokenstate.allowance(from, messagesender) != uint(1)) {
            
            
            tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));
        }

        bytes memory empty;
        return super._internaltransfer(from, to, value, empty);
    }

    
    function transferfrom(address from, address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        require(from != 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef, );

        
        if (tokenstate.allowance(from, messagesender) != uint(1)) {
            
            
            tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));
        }

        return super._internaltransfer(from, to, value, data);
    }

    
    function issue(address account, uint amount)
        external
        onlysynthetixorfeepool
    {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).add(amount));
        totalsupply = totalsupply.add(amount);
        emittransfer(address(0), account, amount);
        emitissued(account, amount);
    }

    
    function burn(address account, uint amount)
        external
        onlysynthetixorfeepool
    {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).sub(amount));
        totalsupply = totalsupply.sub(amount);
        emittransfer(account, address(0), amount);
        emitburned(account, amount);
    }

    
    function settotalsupply(uint amount)
        external
        optionalproxy_onlyowner
    {
        totalsupply = amount;
    }

    
    
    function triggertokenfallbackifneeded(address sender, address recipient, uint amount)
        external
        onlysynthetixorfeepool
    {
        bytes memory empty;
        calltokenfallbackifneeded(sender, recipient, amount, empty);
    }

    

    modifier onlysynthetixorfeepool() {
        bool issynthetix = msg.sender == address(proxy(synthetixproxy).target());
        bool isfeepool = msg.sender == address(proxy(feepoolproxy).target());

        require(issynthetix || isfeepool, );
        _;
    }

    

    event synthetixupdated(address newsynthetix);
    bytes32 constant synthetixupdated_sig = keccak256();
    function emitsynthetixupdated(address newsynthetix) internal {
        proxy._emit(abi.encode(newsynthetix), 1, synthetixupdated_sig, 0, 0, 0);
    }

    event feepoolupdated(address newfeepool);
    bytes32 constant feepoolupdated_sig = keccak256();
    function emitfeepoolupdated(address newfeepool) internal {
        proxy._emit(abi.encode(newfeepool), 1, feepoolupdated_sig, 0, 0, 0);
    }

    event issued(address indexed account, uint value);
    bytes32 constant issued_sig = keccak256();
    function emitissued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, issued_sig, bytes32(account), 0, 0);
    }

    event burned(address indexed account, uint value);
    bytes32 constant burned_sig = keccak256();
    function emitburned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, burned_sig, bytes32(account), 0, 0);
    }
}



pragma solidity 0.4.25;

import ;

contract tokenfallbackcaller is reentrancyguard {
    uint constant max_gas_sub_call = 100000;
    function calltokenfallbackifneeded(address sender, address recipient, uint amount, bytes data)
        internal
        nonreentrant
    {
        

        
        uint length;

        
        assembly {
            
            length := extcodesize(recipient)
        }

        
        if (length > 0) {
            
            uint gaslimit = gasleft() < max_gas_sub_call ? gasleft() : max_gas_sub_call;
            
            
            
            recipient.call.gas(gaslimit)(abi.encodewithsignature(, sender, amount, data));

            
        }
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;


contract externstatetoken is selfdestructible, proxyable, tokenfallbackcaller {

    using safemath for uint;
    using safedecimalmath for uint;

    

    
    tokenstate public tokenstate;

    
    string public name;
    string public symbol;
    uint public totalsupply;
    uint8 public decimals;

    
    constructor(address _proxy, tokenstate _tokenstate,
                string _name, string _symbol, uint _totalsupply,
                uint8 _decimals, address _owner)
        selfdestructible(_owner)
        proxyable(_proxy, _owner)
        public
    {
        tokenstate = _tokenstate;

        name = _name;
        symbol = _symbol;
        totalsupply = _totalsupply;
        decimals = _decimals;
    }

    

    
    function allowance(address owner, address spender)
        public
        view
        returns (uint)
    {
        return tokenstate.allowance(owner, spender);
    }

    
    function balanceof(address account)
        public
        view
        returns (uint)
    {
        return tokenstate.balanceof(account);
    }

    

    
    function settokenstate(tokenstate _tokenstate)
        external
        optionalproxy_onlyowner
    {
        tokenstate = _tokenstate;
        emittokenstateupdated(_tokenstate);
    }

    function _internaltransfer(address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        
        require(to != address(0), );
        require(to != address(this), );
        require(to != address(proxy), );

        
        tokenstate.setbalanceof(from, tokenstate.balanceof(from).sub(value));
        tokenstate.setbalanceof(to, tokenstate.balanceof(to).add(value));

        
        emittransfer(from, to, value);

        
        
        
        calltokenfallbackifneeded(from, to, value, data);
        
        return true;
    }

    
    function _transfer_byproxy(address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        return _internaltransfer(from, to, value, data);
    }

    
    function _transferfrom_byproxy(address sender, address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        
        tokenstate.setallowance(from, sender, tokenstate.allowance(from, sender).sub(value));
        return _internaltransfer(from, to, value, data);
    }

    
    function approve(address spender, uint value)
        public
        optionalproxy
        returns (bool)
    {
        address sender = messagesender;

        tokenstate.setallowance(sender, spender, value);
        emitapproval(sender, spender, value);
        return true;
    }

    

    event transfer(address indexed from, address indexed to, uint value);
    bytes32 constant transfer_sig = keccak256();
    function emittransfer(address from, address to, uint value) internal {
        proxy._emit(abi.encode(value), 3, transfer_sig, bytes32(from), bytes32(to), 0);
    }

    event approval(address indexed owner, address indexed spender, uint value);
    bytes32 constant approval_sig = keccak256();
    function emitapproval(address owner, address spender, uint value) internal {
        proxy._emit(abi.encode(value), 3, approval_sig, bytes32(owner), bytes32(spender), 0);
    }

    event tokenstateupdated(address newtokenstate);
    bytes32 constant tokenstateupdated_sig = keccak256();
    function emittokenstateupdated(address newtokenstate) internal {
        proxy._emit(abi.encode(newtokenstate), 1, tokenstateupdated_sig, 0, 0, 0);
    }
}

pragma solidity 0.4.25;

import ;


contract dappmaintenance is owned  {
    bool public ispausedmintr = false;
    bool public ispausedsx = false;

    
    constructor(address _owner)
        owned(_owner)
        public
    {}

    function setmaintenancemodeall(bool ispaused)
        external
        onlyowner
    {
        ispausedmintr = ispaused;
        ispausedsx = ispaused;
        emit mintrmaintenance(ispaused);
        emit sxmaintenance(ispaused);
    }

    function setmaintenancemodemintr(bool ispaused)
        external
        onlyowner
    {
        ispausedmintr = ispaused;
        emit mintrmaintenance(ispausedmintr);
    }

    function setmaintenancemodesx(bool ispaused)
        external
        onlyowner
    {
        ispausedsx = ispaused;
        emit sxmaintenance(ispausedsx);
    }

    event mintrmaintenance(bool ispaused);
    event sxmaintenance(bool ispaused);
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;


contract synthetixescrow is owned, limitedsetup(8 weeks) {

    using safemath for uint;

    
    isynthetix public synthetix;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalvestedbalance;

    uint constant time_index = 0;
    uint constant quantity_index = 1;

    
    uint constant max_vesting_entries = 20;


    

    constructor(address _owner, isynthetix _synthetix)
        owned(_owner)
        public
    {
        synthetix = _synthetix;
    }


    

    function setsynthetix(isynthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }


    

    
    function balanceof(address account)
        public
        view
        returns (uint)
    {
        return totalvestedaccountbalance[account];
    }

    
    function numvestingentries(address account)
        public
        view
        returns (uint)
    {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index)
        public
        view
        returns (uint[2])
    {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index)
        public
        view
        returns (uint)
    {
        return getvestingscheduleentry(account,index)[time_index];
    }

    
    function getvestingquantity(address account, uint index)
        public
        view
        returns (uint)
    {
        return getvestingscheduleentry(account,index)[quantity_index];
    }

    
    function getnextvestingindex(address account)
        public
        view
        returns (uint)
    {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account)
        public
        view
        returns (uint[2])
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account)
        external
        view
        returns (uint)
    {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account)
        external
        view
        returns (uint)
    {
        return getnextvestingentry(account)[quantity_index];
    }


    

    
    function withdrawsynthetix(uint quantity)
        external
        onlyowner
        onlyduringsetup
    {
        synthetix.transfer(synthetix, quantity);
    }

    
    function purgeaccount(address account)
        external
        onlyowner
        onlyduringsetup
    {
        delete vestingschedules[account];
        totalvestedbalance = totalvestedbalance.sub(totalvestedaccountbalance[account]);
        delete totalvestedaccountbalance[account];
    }

    
    function appendvestingentry(address account, uint time, uint quantity)
        public
        onlyowner
        onlyduringsetup
    {
        
        require(now < time, );
        require(quantity != 0, );

        
        totalvestedbalance = totalvestedbalance.add(quantity);
        require(totalvestedbalance <= synthetix.balanceof(this), );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        if (schedulelength == 0) {
            totalvestedaccountbalance[account] = quantity;
        } else {
            
            require(getvestingtime(account, numvestingentries(account)  1) < time, );
            totalvestedaccountbalance[account] = totalvestedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);
    }

    
    function addvestingschedule(address account, uint[] times, uint[] quantities)
        external
        onlyowner
        onlyduringsetup
    {
        for (uint i = 0; i < times.length; i++) {
            appendvestingentry(account, times[i], quantities[i]);
        }

    }

    
    function vest()
        external
    {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalvestedbalance = totalvestedbalance.sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].sub(total);
            synthetix.transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }


    

    event synthetixupdated(address newsynthetix);

    event vested(address indexed beneficiary, uint time, uint value);
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;


contract rewardescrow is owned {

    using safemath for uint;

    
    isynthetix public synthetix;

    ifeepool public feepool;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalescrowedaccountbalance;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalescrowedbalance;

    uint constant time_index = 0;
    uint constant quantity_index = 1;

    
    uint constant public max_vesting_entries = 52*5;


    

    constructor(address _owner, isynthetix _synthetix, ifeepool _feepool)
    owned(_owner)
    public
    {
        synthetix = _synthetix;
        feepool = _feepool;
    }


    

    
    function setsynthetix(isynthetix _synthetix)
    external
    onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }

    
    function setfeepool(ifeepool _feepool)
        external
        onlyowner
    {
        feepool = _feepool;
        emit feepoolupdated(_feepool);
    }


    

    
    function balanceof(address account)
    public
    view
    returns (uint)
    {
        return totalescrowedaccountbalance[account];
    }

    
    function numvestingentries(address account)
    public
    view
    returns (uint)
    {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index)
    public
    view
    returns (uint[2])
    {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index)
    public
    view
    returns (uint)
    {
        return getvestingscheduleentry(account,index)[time_index];
    }

    
    function getvestingquantity(address account, uint index)
    public
    view
    returns (uint)
    {
        return getvestingscheduleentry(account,index)[quantity_index];
    }

    
    function getnextvestingindex(address account)
    public
    view
    returns (uint)
    {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account)
    public
    view
    returns (uint[2])
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account)
    external
    view
    returns (uint)
    {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account)
    external
    view
    returns (uint)
    {
        return getnextvestingentry(account)[quantity_index];
    }

    
    function checkaccountschedule(address account)
        public
        view
        returns (uint[520])
    {
        uint[520] memory _result;
        uint schedules = numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = getvestingscheduleentry(account, i);
            _result[i*2] = pair[0];
            _result[i*2 + 1] = pair[1];
        }
        return _result;
    }


    

    
    function appendvestingentry(address account, uint quantity)
    public
    onlyfeepool
    {
        
        require(quantity != 0, );

        
        totalescrowedbalance = totalescrowedbalance.add(quantity);
        require(totalescrowedbalance <= synthetix.balanceof(this), );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        
        uint time = now + 52 weeks;

        if (schedulelength == 0) {
            totalescrowedaccountbalance[account] = quantity;
        } else {
            
            require(getvestingtime(account, schedulelength  1) < time, );
            totalescrowedaccountbalance[account] = totalescrowedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);

        emit vestingentrycreated(account, now, quantity);
    }

    
    function vest()
    external
    {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalescrowedbalance = totalescrowedbalance.sub(total);
            totalescrowedaccountbalance[msg.sender] = totalescrowedaccountbalance[msg.sender].sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].add(total);
            synthetix.transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }

    

    modifier onlyfeepool() {
        bool isfeepool = msg.sender == address(feepool);

        require(isfeepool, );
        _;
    }


    

    event synthetixupdated(address newsynthetix);

    event feepoolupdated(address newfeepool);

    event vested(address indexed beneficiary, uint time, uint value);

    event vestingentrycreated(address indexed beneficiary, uint time, uint value);

}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;


contract synthetixstate is state, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    
    mapping(address => issuancedata) public issuancedata;

    
    uint public totalissuercount;

    
    uint[] public debtledger;

    
    uint public importedxdramount;

    
    
    uint public issuanceratio = safedecimalmath.unit() / 5;
    
    uint constant max_issuance_ratio = safedecimalmath.unit();

    
    
    mapping(address => bytes4) public preferredcurrency;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        limitedsetup(1 weeks)
        public
    {}

    

    
    function setcurrentissuancedata(address account, uint initialdebtownership)
        external
        onlyassociatedcontract
    {
        issuancedata[account].initialdebtownership = initialdebtownership;
        issuancedata[account].debtentryindex = debtledger.length;
    }

    
    function clearissuancedata(address account)
        external
        onlyassociatedcontract
    {
        delete issuancedata[account];
    }

    
    function incrementtotalissuercount()
        external
        onlyassociatedcontract
    {
        totalissuercount = totalissuercount.add(1);
    }

    
    function decrementtotalissuercount()
        external
        onlyassociatedcontract
    {
        totalissuercount = totalissuercount.sub(1);
    }

    
    function appenddebtledgervalue(uint value)
        external
        onlyassociatedcontract
    {
        debtledger.push(value);
    }

    
    function setpreferredcurrency(address account, bytes4 currencykey)
        external
        onlyassociatedcontract
    {
        preferredcurrency[account] = currencykey;
    }

    
    function setissuanceratio(uint _issuanceratio)
        external
        onlyowner
    {
        require(_issuanceratio <= max_issuance_ratio, );
        issuanceratio = _issuanceratio;
        emit issuanceratioupdated(_issuanceratio);
    }

    
    function importissuerdata(address[] accounts, uint[] susdamounts)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == susdamounts.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            _addtodebtregister(accounts[i], susdamounts[i]);
        }
    }

    
    function _addtodebtregister(address account, uint amount)
        internal
    {
        
        
        synthetix synthetix = synthetix(associatedcontract);

        
        uint xdrvalue = synthetix.effectivevalue(, amount, );

        
        uint totaldebtissued = importedxdramount;

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        importedxdramount = newtotaldebtissued;

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        uint existingdebt = synthetix.debtbalanceof(account, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (issuancedata[account].initialdebtownership == 0) {
            totalissuercount = totalissuercount.add(1);
        }

        
        issuancedata[account].initialdebtownership = debtpercentage;
        issuancedata[account].debtentryindex = debtledger.length;

        
        
        if (debtledger.length > 0) {
            debtledger.push(
                debtledger[debtledger.length  1].multiplydecimalroundprecise(delta)
            );
        } else {
            debtledger.push(safedecimalmath.preciseunit());
        }
    }

    

    
    function debtledgerlength()
        external
        view
        returns (uint)
    {
        return debtledger.length;
    }

    
    function lastdebtledgerentry()
        external
        view
        returns (uint)
    {
        return debtledger[debtledger.length  1];
    }

    
    function hasissued(address account)
        external
        view
        returns (bool)
    {
        return issuancedata[account].initialdebtownership > 0;
    }

    event issuanceratioupdated(uint newratio);
}
pragma solidity 0.4.25;

import ;

contract math {
    using safemath for uint;
    using safedecimalmath for uint;

    
    function powdecimal(uint x, uint n)
        internal
        pure
        returns (uint)
    {
        
        
        
        
        
        
        
        
        
        
        
        

        uint result = safedecimalmath.unit();
        while (n > 0) {
            if (n % 2 != 0) {
                result = result.multiplydecimal(x);
            }
            x = x.multiplydecimal(x);
            n /= 2;
        }
        return result;
    }
}
    


pragma solidity 0.4.25;


import ;



contract selfdestructible is owned {
    
    uint public initiationtime;
    bool public selfdestructinitiated;
    address public selfdestructbeneficiary;
    uint public constant selfdestruct_delay = 4 weeks;

    
    constructor(address _owner)
        owned(_owner)
        public
    {
        require(_owner != address(0), );
        selfdestructbeneficiary = _owner;
        emit selfdestructbeneficiaryupdated(_owner);
    }

    
    function setselfdestructbeneficiary(address _beneficiary)
        external
        onlyowner
    {
        require(_beneficiary != address(0), );
        selfdestructbeneficiary = _beneficiary;
        emit selfdestructbeneficiaryupdated(_beneficiary);
    }

    
    function initiateselfdestruct()
        external
        onlyowner
    {
        initiationtime = now;
        selfdestructinitiated = true;
        emit selfdestructinitiated(selfdestruct_delay);
    }

    
    function terminateselfdestruct()
        external
        onlyowner
    {
        initiationtime = 0;
        selfdestructinitiated = false;
        emit selfdestructterminated();
    }

    
    function selfdestruct()
        external
        onlyowner
    {
        require(selfdestructinitiated, );
        require(initiationtime + selfdestruct_delay < now, );
        address beneficiary = selfdestructbeneficiary;
        emit selfdestructed(beneficiary);
        selfdestruct(beneficiary);
    }

    event selfdestructterminated();
    event selfdestructed(address beneficiary);
    event selfdestructinitiated(uint selfdestructdelay);
    event selfdestructbeneficiaryupdated(address newbeneficiary);
}


pragma solidity 0.4.25;

import ;
import ;

contract synthetixairdropper is owned {
    

    
    constructor (address _owner)
        owned(_owner)
        public
    {}

    
    function multisend(address _tokenaddress, address[] _destinations, uint256[] _values)
        external
        onlyowner
    {
        
        require(_destinations.length == _values.length, );

        
        uint256 i = 0;
        while (i < _destinations.length) {
            isynthetix(_tokenaddress).transfer(_destinations[i], _values[i]);
            i += 1;
        }
    }

    
    function ()
        external
        payable
    {
        owner.transfer(msg.value);
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract feepoolstate is selfdestructible, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    

    uint8 constant public fee_period_length = 6;

    address public feepool;

    
    struct issuancedata {
        uint debtpercentage;
        uint debtentryindex;
    }

    
    mapping(address => issuancedata[fee_period_length]) public accountissuanceledger;

    
    constructor(address _owner, ifeepool _feepool)
        selfdestructible(_owner)
        limitedsetup(6 weeks)
        public
    {
        feepool = _feepool;
    }

    

    
    function setfeepool(ifeepool _feepool)
        external
        onlyowner
    {
        feepool = _feepool;
    }

    

    
    function getaccountsdebtentry(address account, uint index)
        public
        view
        returns (uint debtpercentage, uint debtentryindex)
    {
        require(index < fee_period_length, );

        debtpercentage = accountissuanceledger[account][index].debtpercentage;
        debtentryindex = accountissuanceledger[account][index].debtentryindex;
    }

    
    function applicableissuancedata(address account, uint closingdebtindex)
        external
        view
        returns (uint, uint)
    {
        issuancedata[fee_period_length] memory issuancedata = accountissuanceledger[account];
        
        
        
        for (uint i = 0; i < fee_period_length; i++) {
            if (closingdebtindex >= issuancedata[i].debtentryindex) {
                return (issuancedata[i].debtpercentage, issuancedata[i].debtentryindex);
            }
        }
    }

    

    
    function appendaccountissuancerecord(address account, uint debtratio, uint debtentryindex, uint currentperiodstartdebtindex)
        external
        onlyfeepool
    {
        
        if (accountissuanceledger[account][0].debtentryindex < currentperiodstartdebtindex) {
             
            issuancedataindexorder(account);
        }
        
        
        accountissuanceledger[account][0].debtpercentage = debtratio;
        accountissuanceledger[account][0].debtentryindex = debtentryindex;
    }

    
    function issuancedataindexorder(address account)
        private
    {
        for (uint i = fee_period_length  2; i < fee_period_length; i) {
            uint next = i + 1;
            accountissuanceledger[account][next].debtpercentage = accountissuanceledger[account][i].debtpercentage;
            accountissuanceledger[account][next].debtentryindex = accountissuanceledger[account][i].debtentryindex;
        }
    }

    
    function importissuerdata(address[] accounts, uint[] ratios, uint periodtoinsert, uint feeperiodcloseindex)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == ratios.length, );

        for (uint i = 0; i < accounts.length; i++) {
            accountissuanceledger[accounts[i]][periodtoinsert].debtpercentage = ratios[i];
            accountissuanceledger[accounts[i]][periodtoinsert].debtentryindex = feeperiodcloseindex;
            emit issuancedebtratioentry(accounts[i], ratios[i], feeperiodcloseindex);
        }
    }

    

    modifier onlyfeepool
    {
        require(msg.sender == address(feepool), );
        _;
    }

    
    event issuancedebtratioentry(address indexed account, uint debtratio, uint feeperiodcloseindex);
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;


contract supplyschedule is owned, math {
    using safemath for uint;
    using safedecimalmath for uint;

    
    uint public lastmintevent;

    
    uint public weekcounter;

    
    uint public minterreward = 200 * safedecimalmath.unit();

    
    
    uint public constant initial_weekly_supply = 1442307692307692307692307;    

    
    address public synthetixproxy;

    
    uint public constant max_minter_reward = 200 * safedecimalmath.unit();

    
    uint public constant mint_period_duration = 1 weeks;

    uint public constant inflation_start_date = 1551830400; 
    uint8 public constant supply_decay_start = 40; 
    uint8 public constant supply_decay_end = 234; 
    
    
    uint public constant decay_rate = 12500000000000000; 

    
    uint public constant terminal_supply_rate_annual = 25000000000000000; 
    
    constructor(
        address _owner,
        uint _lastmintevent,
        uint _currentweek)
        owned(_owner)
        public
    {
        lastmintevent = _lastmintevent;
        weekcounter = _currentweek;
    }

    
    
    
    function mintablesupply()
        external
        view
        returns (uint)
    {
        uint totalamount;

        if (!ismintable()) {
            return totalamount;
        }
        
        uint remainingweekstomint = weekssincelastissuance();
          
        uint currentweek = weekcounter;
        
        
        
        while (remainingweekstomint > 0) {
            currentweek++;            
            
            
            if (currentweek < supply_decay_start) {
                totalamount = totalamount.add(initial_weekly_supply);
                remainingweekstomint;
            }
            
            else if (currentweek <= supply_decay_end) {
                
                
                uint decaycount = currentweek.sub(supply_decay_start 1);
                
                totalamount = totalamount.add(tokendecaysupplyforweek(decaycount));
                remainingweekstomint;
            } 
            
            
            else {
                uint totalsupply = isynthetix(synthetixproxy).totalsupply();
                uint currenttotalsupply = totalsupply.add(totalamount);

                totalamount = totalamount.add(terminalinflationsupply(currenttotalsupply, remainingweekstomint));
                remainingweekstomint = 0;
            }
        }
        
        return totalamount;
    }

    
    function tokendecaysupplyforweek(uint counter)
        public 
        view
        returns (uint)
    {   
        
        
        uint effectivedecay = powdecimal(safedecimalmath.unit().sub(decay_rate), counter);
        uint supplyforweek = initial_weekly_supply.multiplydecimal(effectivedecay);

        return supplyforweek;
    }    
    
    
    function terminalinflationsupply(uint totalsupply, uint numofweeks)
        public
        pure
        returns (uint)
    {   
        
        uint effectivecompoundrate = powdecimal(safedecimalmath.unit().add(terminal_supply_rate_annual.div(52)), numofweeks);

        
        return totalsupply.multiplydecimal(effectivecompoundrate.sub(safedecimalmath.unit()));
    }

    
    function weekssincelastissuance()
        public
        view
        returns (uint)
    {
        
        
        uint timediff = lastmintevent > 0 ? now.sub(lastmintevent) : now.sub(inflation_start_date);
        return timediff.div(mint_period_duration);
    }

    
    function ismintable()
        public
        view
        returns (bool)
    {
        if (now  lastmintevent > mint_period_duration)
        {
            return true;
        }
        return false;
    }

    

    
    function recordmintevent(uint supplyminted)
        external
        onlysynthetix
        returns (bool)
    {
        uint numberofweeksissued = weekssincelastissuance();

        
        weekcounter = weekcounter.add(numberofweeksissued);

        
        lastmintevent = now;

        emit supplyminted(supplyminted, numberofweeksissued, now);
        return true;
    }

    
    function setminterreward(uint amount)
        external
        onlyowner
    {
        require(amount <= max_minter_reward, );
        minterreward = amount;
        emit minterrewardupdated(minterreward);
    }

    

    
    function setsynthetixproxy(isynthetix _synthetixproxy)
        external
        onlyowner
    {
        synthetixproxy = _synthetixproxy;
    }

    

    
    modifier onlysynthetix() {
        require(msg.sender == address(proxy(synthetixproxy).target()), );
        _;
    }

    
    
    event supplyminted(uint supplyminted, uint numberofweeksissued, uint timestamp);

    
    event minterrewardupdated(uint newrewardamount);
}

pragma solidity 0.4.25;

contract migrations {
    address public owner;
    uint public last_completed_migration;

    constructor() public {
        owner = msg.sender;
    }

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function setcompleted(uint completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        migrations upgraded = migrations(new_address);
        upgraded.setcompleted(last_completed_migration);
    }
}

pragma solidity 0.4.25;

contract synthetixescrow {
    function numvestingentries(address account) public returns (uint);
    function getvestingscheduleentry(address account, uint index) public returns (uint[2]);
}

contract escrowchecker {
    synthetixescrow public synthetix_escrow;
    constructor(synthetixescrow _esc) public {
        synthetix_escrow = _esc;
    }

    function checkaccountschedule(address account)
        public
        view
        returns (uint[16])
    {
        uint[16] memory _result;
        uint schedules = synthetix_escrow.numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = synthetix_escrow.getvestingscheduleentry(account, i);
            _result[i*2] = pair[0];
            _result[i*2 + 1] = pair[1];
        }
        return _result;
    }
}



pragma solidity 0.4.25;


import ;



contract pausable is owned {
    
    uint public lastpausetime;
    bool public paused;

    
    constructor(address _owner)
        owned(_owner)
        public
    {
        
    }

    
    function setpaused(bool _paused)
        external
        onlyowner
    {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;
        
        
        if (paused) {
            lastpausetime = now;
        }

        
        emit pausechanged(paused);
    }

    event pausechanged(bool ispaused);

    modifier notpaused {
        require(!paused, );
        _;
    }
}



pragma solidity 0.4.25;

import ;


library safedecimalmath {

    using safemath for uint;

    
    uint8 public constant decimals = 18;
    uint8 public constant highprecisiondecimals = 27;

    
    uint public constant unit = 10 ** uint(decimals);

    
    uint public constant precise_unit = 10 ** uint(highprecisiondecimals);
    uint private constant unit_to_high_precision_conversion_factor = 10 ** uint(highprecisiondecimals  decimals);

    
    function unit()
        external
        pure
        returns (uint)
    {
        return unit;
    }

    
    function preciseunit()
        external
        pure 
        returns (uint)
    {
        return precise_unit;
    }

    
    function multiplydecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        
        return x.mul(y) / unit;
    }

    
    function _multiplydecimalround(uint x, uint y, uint precisionunit)
        private
        pure
        returns (uint)
    {
        
        uint quotienttimesten = x.mul(y) / (precisionunit / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

    
    function multiplydecimalroundprecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplydecimalround(x, y, precise_unit);
    }

    
    function multiplydecimalround(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplydecimalround(x, y, unit);
    }

    
    function dividedecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        
        return x.mul(unit).div(y);
    }

    
    function _dividedecimalround(uint x, uint y, uint precisionunit)
        private
        pure
        returns (uint)
    {
        uint resulttimesten = x.mul(precisionunit * 10).div(y);

        if (resulttimesten % 10 >= 5) {
            resulttimesten += 10;
        }

        return resulttimesten / 10;
    }

    
    function dividedecimalround(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _dividedecimalround(x, y, unit);
    }

    
    function dividedecimalroundprecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _dividedecimalround(x, y, precise_unit);
    }

    
    function decimaltoprecisedecimal(uint i)
        internal
        pure
        returns (uint)
    {
        return i.mul(unit_to_high_precision_conversion_factor);
    }

    
    function precisedecimaltodecimal(uint i)
        internal
        pure
        returns (uint)
    {
        uint quotienttimesten = i / (unit_to_high_precision_conversion_factor / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

}




pragma solidity 0.4.25;


import ;
import ;


contract proxy is owned {

    proxyable public target;
    bool public usedelegatecall;

    constructor(address _owner)
        owned(_owner)
        public
    {}

    function settarget(proxyable _target)
        external
        onlyowner
    {
        target = _target;
        emit targetupdated(_target);
    }

    function setusedelegatecall(bool value) 
        external
        onlyowner
    {
        usedelegatecall = value;
    }

    function _emit(bytes calldata, uint numtopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlytarget
    {
        uint size = calldata.length;
        bytes memory _calldata = calldata;

        assembly {
            
            switch numtopics
            case 0 {
                log0(add(_calldata, 32), size)
            } 
            case 1 {
                log1(add(_calldata, 32), size, topic1)
            }
            case 2 {
                log2(add(_calldata, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_calldata, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_calldata, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
        external
        payable
    {
        if (usedelegatecall) {
            assembly {
                
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            
            target.setmessagesender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlytarget {
        require(proxyable(msg.sender) == target, );
        _;
    }

    event targetupdated(proxyable newtarget);
}




pragma solidity 0.4.25;


contract limitedsetup {

    uint setupexpirytime;

    
    constructor(uint setupduration)
        public
    {
        setupexpirytime = now + setupduration;
    }

    modifier onlyduringsetup
    {
        require(now < setupexpirytime, );
        _;
    }
}

pragma solidity 0.4.25;

import ;
import ;
import ;


import ;



contract exchangerates is selfdestructible {


    using safemath for uint;
    using safedecimalmath for uint;

    struct rateandupdatedtime {
        uint216 rate;
        uint40 time;
    }

    
    mapping(bytes32 => rateandupdatedtime) private _rates;

    
    address public oracle;

    
    mapping(bytes32 => aggregatorinterface) public aggregators;

    
    bytes32[] public aggregatorkeys;

    
    uint constant oracle_future_limit = 10 minutes;

    
    uint public ratestaleperiod = 3 hours;


    
    
    
    bytes32[5] public xdrparticipants;

    
    mapping(bytes32 => bool) public isxdrparticipant;

    
    struct inversepricing {
        uint entrypoint;
        uint upperlimit;
        uint lowerlimit;
        bool frozen;
    }
    mapping(bytes32 => inversepricing) public inversepricing;
    bytes32[] public invertedkeys;

    

    
    constructor(
        
        address _owner,

        
        address _oracle,
        bytes32[] _currencykeys,
        uint[] _newrates
    )
        
        selfdestructible(_owner)
        public
    {
        require(_currencykeys.length == _newrates.length, );

        oracle = _oracle;

        
        _setrate(, safedecimalmath.unit(), now);

        
        
        
        
        
        
        
        xdrparticipants = [
            bytes32(),
            bytes32(),
            bytes32(),
            bytes32(),
            bytes32()
        ];

        
        isxdrparticipant[bytes32()] = true;
        isxdrparticipant[bytes32()] = true;
        isxdrparticipant[bytes32()] = true;
        isxdrparticipant[bytes32()] = true;
        isxdrparticipant[bytes32()] = true;

        internalupdaterates(_currencykeys, _newrates, now);
    }

    function getrateandupdatedtime(bytes32 code) internal view returns (rateandupdatedtime) {
        if (aggregators[code] != address(0)) {
            return rateandupdatedtime({
                rate: uint216(aggregators[code].latestanswer() * 1e10),
                time: uint40(aggregators[code].latesttimestamp())
            });
        } else {
            return _rates[code];
        }
    }
    
    function rates(bytes32 code) public view returns(uint256) {
        return getrateandupdatedtime(code).rate;
    }

    
    function lastrateupdatetimes(bytes32 code) public view returns(uint256) {
        return getrateandupdatedtime(code).time;
    }

    
    function lastrateupdatetimesforcurrencies(bytes32[] currencykeys)
        public
        view
        returns (uint[])
    {
        uint[] memory lastupdatetimes = new uint[](currencykeys.length);

        for (uint i = 0; i < currencykeys.length; i++) {
            lastupdatetimes[i] = lastrateupdatetimes(currencykeys[i]);
        }

        return lastupdatetimes;
    }

    function _setrate(bytes32 code, uint256 rate, uint256 time) internal {
        _rates[code] = rateandupdatedtime({
            rate: uint216(rate),
            time: uint40(time)
        });
    }

    

    
    function updaterates(bytes32[] currencykeys, uint[] newrates, uint timesent)
        external
        onlyoracle
        returns(bool)
    {
        return internalupdaterates(currencykeys, newrates, timesent);
    }

    
    function internalupdaterates(bytes32[] currencykeys, uint[] newrates, uint timesent)
        internal
        returns(bool)
    {
        require(currencykeys.length == newrates.length, );
        require(timesent < (now + oracle_future_limit), );

        bool recomputexdrrate = false;

        
        for (uint i = 0; i < currencykeys.length; i++) {
            bytes32 currencykey = currencykeys[i];

            
            
            
            require(newrates[i] != 0, );
            require(currencykey != , );

            
            if (timesent < lastrateupdatetimes(currencykey)) {
                continue;
            }

            newrates[i] = rateorinverted(currencykey, newrates[i]);

            
            _setrate(currencykey, newrates[i], timesent);

            
            if (!recomputexdrrate && isxdrparticipant[currencykey]) {
                recomputexdrrate = true;
            }
        }

        emit ratesupdated(currencykeys, newrates);

        if (recomputexdrrate) {
            
            updatexdrrate(timesent);
        }

        return true;
    }

    
    function rateorinverted(bytes32 currencykey, uint rate) internal returns (uint) {
        
        inversepricing storage inverse = inversepricing[currencykey];
        if (inverse.entrypoint <= 0) {
            return rate;
        }

        
        uint newinverserate = rates(currencykey);

        
        if (!inverse.frozen) {
            uint doubleentrypoint = inverse.entrypoint.mul(2);
            if (doubleentrypoint <= rate) {
                
                
                
                newinverserate = 0;
            } else {
                newinverserate = doubleentrypoint.sub(rate);
            }

            
            if (newinverserate >= inverse.upperlimit) {
                newinverserate = inverse.upperlimit;
            } else if (newinverserate <= inverse.lowerlimit) {
                newinverserate = inverse.lowerlimit;
            }

            if (newinverserate == inverse.upperlimit || newinverserate == inverse.lowerlimit) {
                inverse.frozen = true;
                emit inversepricefrozen(currencykey);
            }
        }

        return newinverserate;
    }

    
    function updatexdrrate(uint timesent)
        internal
    {
        uint total = 0;

        for (uint i = 0; i < xdrparticipants.length; i++) {
            total = rates(xdrparticipants[i]).add(total);
        }

        
        _setrate(, total, timesent);

        
        
        bytes32[] memory eventcurrencycode = new bytes32[](1);
        eventcurrencycode[0] = ;

        uint[] memory eventrate = new uint[](1);
        eventrate[0] = rates();

        emit ratesupdated(eventcurrencycode, eventrate);
    }

    
    function deleterate(bytes32 currencykey)
        external
        onlyoracle
    {
        require(rates(currencykey) > 0, );

        delete _rates[currencykey];

        emit ratedeleted(currencykey);
    }

    
    function setoracle(address _oracle)
        external
        onlyowner
    {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    
    function setratestaleperiod(uint _time)
        external
        onlyowner
    {
        ratestaleperiod = _time;
        emit ratestaleperiodupdated(ratestaleperiod);
    }

    
    function setinversepricing(bytes32 currencykey, uint entrypoint, uint upperlimit, uint lowerlimit, bool freeze, bool freezeatupperlimit)
        external onlyowner
    {
        require(entrypoint > 0, );
        require(lowerlimit > 0, );
        require(upperlimit > entrypoint, );
        require(upperlimit < entrypoint.mul(2), );
        require(lowerlimit < entrypoint, );

        if (inversepricing[currencykey].entrypoint <= 0) {
            
            invertedkeys.push(currencykey);
        }
        inversepricing[currencykey].entrypoint = entrypoint;
        inversepricing[currencykey].upperlimit = upperlimit;
        inversepricing[currencykey].lowerlimit = lowerlimit;
        inversepricing[currencykey].frozen = freeze;

        emit inversepriceconfigured(currencykey, entrypoint, upperlimit, lowerlimit);

        
        
        
        if (freeze) {
            emit inversepricefrozen(currencykey);

            _setrate(currencykey, freezeatupperlimit ? upperlimit : lowerlimit, now);
        }
    }

    
    function removeinversepricing(bytes32 currencykey) external onlyowner
    {
        require(inversepricing[currencykey].entrypoint > 0, );

        inversepricing[currencykey].entrypoint = 0;
        inversepricing[currencykey].upperlimit = 0;
        inversepricing[currencykey].lowerlimit = 0;
        inversepricing[currencykey].frozen = false;

        
        bool wasremoved = removefromarray(currencykey, invertedkeys);

        if (wasremoved) {
            emit inversepriceconfigured(currencykey, 0, 0, 0);
        }
    }

    
    function addaggregator(bytes32 currencykey, address aggregatoraddress) external onlyowner {
        aggregatorinterface aggregator = aggregatorinterface(aggregatoraddress);
        require(aggregator.latesttimestamp() >= 0, );
        if (aggregators[currencykey] == address(0)) {
            aggregatorkeys.push(currencykey);
        }
        aggregators[currencykey] = aggregator;
        emit aggregatoradded(currencykey, aggregator);
    }

    
    function removefromarray(bytes32 entry, bytes32[] storage array) internal returns (bool) {
        for (uint i = 0; i < array.length; i++) {
            if (array[i] == entry) {
                delete array[i];

                
                
                
                array[i] = array[array.length  1];

                
                array.length;

                return true;
            }
        }
        return false;
    }
    
    function removeaggregator(bytes32 currencykey) external onlyowner {
        address aggregator = aggregators[currencykey];
        require(aggregator != address(0), );
        delete aggregators[currencykey];

        bool wasremoved = removefromarray(currencykey, aggregatorkeys);

        if (wasremoved) {
            emit aggregatorremoved(currencykey, aggregator);
        }
    }

    

    
    function effectivevalue(bytes32 sourcecurrencykey, uint sourceamount, bytes32 destinationcurrencykey)
        public
        view
        ratenotstale(sourcecurrencykey)
        ratenotstale(destinationcurrencykey)
        returns (uint)
    {
        
        if (sourcecurrencykey == destinationcurrencykey) return sourceamount;

        
        return sourceamount.multiplydecimalround(rateforcurrency(sourcecurrencykey))
            .dividedecimalround(rateforcurrency(destinationcurrencykey));
    }

    
    function rateforcurrency(bytes32 currencykey)
        public
        view
        returns (uint)
    {
        return rates(currencykey);
    }

    
    function ratesforcurrencies(bytes32[] currencykeys)
        public
        view
        returns (uint[])
    {
        uint[] memory _localrates = new uint[](currencykeys.length);

        for (uint i = 0; i < currencykeys.length; i++) {
            _localrates[i] = rates(currencykeys[i]);
        }

        return _localrates;
    }

    
    function ratesandstaleforcurrencies(bytes32[] currencykeys)
        public
        view
        returns (uint[], bool)
    {
        uint[] memory _localrates = new uint[](currencykeys.length);

        bool anyratestale = false;
        uint period = ratestaleperiod;
        for (uint i = 0; i < currencykeys.length; i++) {
            rateandupdatedtime memory rateandupdatetime = getrateandupdatedtime(currencykeys[i]);
            _localrates[i] = uint256(rateandupdatetime.rate);
            if (!anyratestale) {
                anyratestale = (currencykeys[i] !=  && uint256(rateandupdatetime.time).add(period) < now);
            }
        }

        return (_localrates, anyratestale);
    }

    
    function rateisstale(bytes32 currencykey)
        public
        view
        returns (bool)
    {
        
        if (currencykey == ) return false;

        return lastrateupdatetimes(currencykey).add(ratestaleperiod) < now;
    }

    
    function rateisfrozen(bytes32 currencykey)
        external
        view
        returns (bool)
    {
        return inversepricing[currencykey].frozen;
    }


    
    function anyrateisstale(bytes32[] currencykeys)
        external
        view
        returns (bool)
    {
        
        uint256 i = 0;

        while (i < currencykeys.length) {
            
            if (currencykeys[i] !=  && lastrateupdatetimes(currencykeys[i]).add(ratestaleperiod) < now) {
                return true;
            }
            i += 1;
        }

        return false;
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!rateisstale(currencykey), );
        _;
    }

    modifier onlyoracle
    {
        require(msg.sender == oracle, );
        _;
    }

    

    event oracleupdated(address neworacle);
    event ratestaleperiodupdated(uint ratestaleperiod);
    event ratesupdated(bytes32[] currencykeys, uint[] newrates);
    event ratedeleted(bytes32 currencykey);
    event inversepriceconfigured(bytes32 currencykey, uint entrypoint, uint upperlimit, uint lowerlimit);
    event inversepricefrozen(bytes32 currencykey);
    event aggregatoradded(bytes32 currencykey, address aggregator);
    event aggregatorremoved(bytes32 currencykey, address aggregator);
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract proxyerc20 is proxy, ierc20 {

    constructor(address _owner)
        proxy(_owner)
        public
    {}

    

    function name() public view returns (string){
        
        return ierc20(target).name();
    }

    function symbol() public view returns (string){
         
        return ierc20(target).symbol();
    }

    function decimals() public view returns (uint8){
         
        return ierc20(target).decimals();
    }

    

    
    function totalsupply() public view returns (uint256) {
        
        return ierc20(target).totalsupply();
    }

    
    function balanceof(address account) public view returns (uint256) {
        
        return ierc20(target).balanceof(account);
    }

    
    function allowance(
        address owner,
        address spender
    )
        public
        view
        returns (uint256)
    {
        
        return ierc20(target).allowance(owner, spender);
    }

    
    function transfer(address to, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).transfer(to, value);

        
        return true;
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).approve(spender, value);

        
        return true;
    }

    
    function transferfrom(
        address from,
        address to,
        uint256 value
    )
        public
        returns (bool)
    {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).transferfrom(from, to, value);

        
        return true;
    }
}




pragma solidity 0.4.25;

import ;
import ;


contract proxyable is owned {
    
    proxy public proxy;
    proxy public integrationproxy;

    
    address public messagesender;

    constructor(address _proxy, address _owner)
        owned(_owner)
        public
    {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setproxy(address _proxy)
        external
        onlyowner
    {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setintegrationproxy(address _integrationproxy)
        external
        onlyowner
    {
        integrationproxy = proxy(_integrationproxy);
    }

    function setmessagesender(address sender)
        external
        onlyproxy
    {
        messagesender = sender;
    }

    modifier onlyproxy {
        require(proxy(msg.sender) == proxy || proxy(msg.sender) == integrationproxy, );
        _;
    }

    modifier optionalproxy
    {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy && messagesender != msg.sender) {
            messagesender = msg.sender;
        }
        _;
    }

    modifier optionalproxy_onlyowner
    {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy && messagesender != msg.sender) {
            messagesender = msg.sender;
        }
        require(messagesender == owner, );
        _;
    }

    event proxyupdated(address proxyaddress);
}



pragma solidity 0.4.25;


import ;


contract tokenstate is state {

    
    mapping(address => uint) public balanceof;
    mapping(address => mapping(address => uint)) public allowance;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {}

    

    
    function setallowance(address tokenowner, address spender, uint value)
        external
        onlyassociatedcontract
    {
        allowance[tokenowner][spender] = value;
    }

    
    function setbalanceof(address account, uint value)
        external
        onlyassociatedcontract
    {
        balanceof[account] = value;
    }
}

pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;

contract feepool is proxyable, selfdestructible, limitedsetup {

    using safemath for uint;
    using safedecimalmath for uint;

    synthetix public synthetix;
    isynthetixstate public synthetixstate;
    isynthetixescrow public rewardescrow;
    feepooleternalstorage public feepooleternalstorage;

    
    uint public exchangefeerate;

    
    uint constant public max_exchange_fee_rate = safedecimalmath.unit() / 10;

    
    address public rewardsauthority;

    
    feepoolstate public feepoolstate;

    
    delegateapprovals public delegates;

    
    address public constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    
    struct feeperiod {
        uint64 feeperiodid;
        uint64 startingdebtindex;
        uint64 starttime;
        uint feestodistribute;
        uint feesclaimed;
        uint rewardstodistribute;
        uint rewardsclaimed;
    }

    
    
    
    
    
    
    uint8 constant public fee_period_length = 3;

    feeperiod[fee_period_length] private _recentfeeperiods;
    uint256 private _currentfeeperiod;

    
    
    
    
    uint public feeperiodduration = 1 weeks;
    
    uint public constant min_fee_period_duration = 1 days;
    uint public constant max_fee_period_duration = 60 days;

    
    uint public targetthreshold = (10 * safedecimalmath.unit()) / 100;

    

    bytes32 constant last_fee_withdrawal = ;

    constructor(
        address _proxy,
        address _owner,
        synthetix _synthetix,
        feepoolstate _feepoolstate,
        feepooleternalstorage _feepooleternalstorage,
        isynthetixstate _synthetixstate,
        isynthetixescrow _rewardescrow,
        address _rewardsauthority,
        uint _exchangefeerate)
        selfdestructible(_owner)
        proxyable(_proxy, _owner)
        limitedsetup(3 weeks)
        public
    {
        
        require(_exchangefeerate <= max_exchange_fee_rate, );

        synthetix = _synthetix;
        feepoolstate = _feepoolstate;
        feepooleternalstorage = _feepooleternalstorage;
        rewardescrow = _rewardescrow;
        synthetixstate = _synthetixstate;
        rewardsauthority = _rewardsauthority;
        exchangefeerate = _exchangefeerate;

        
        _recentfeeperiodsstorage(0).feeperiodid = 1;
        _recentfeeperiodsstorage(0).starttime = uint64(now);
    }

    function recentfeeperiods(uint index) external view
        returns(
            uint64 feeperiodid,
            uint64 startingdebtindex,
            uint64 starttime,
            uint feestodistribute,
            uint feesclaimed,
            uint rewardstodistribute,
            uint rewardsclaimed
        )
    {
        feeperiod memory feeperiod = _recentfeeperiodsstorage(index);
        return (
            feeperiod.feeperiodid,
            feeperiod.startingdebtindex,
            feeperiod.starttime,
            feeperiod.feestodistribute,
            feeperiod.feesclaimed,
            feeperiod.rewardstodistribute,
            feeperiod.rewardsclaimed
        );
    }

    function _recentfeeperiodsstorage(uint index) internal view returns(feeperiod storage) {
        return _recentfeeperiods[(_currentfeeperiod + index) % fee_period_length];
    }

    
    function appendaccountissuancerecord(address account, uint debtratio, uint debtentryindex)
        external
        onlysynthetix
    {
        feepoolstate.appendaccountissuancerecord(account, debtratio, debtentryindex, _recentfeeperiodsstorage(0).startingdebtindex);

        emitissuancedebtratioentry(account, debtratio, debtentryindex, _recentfeeperiodsstorage(0).startingdebtindex);
    }

    
    function setexchangefeerate(uint _exchangefeerate)
        external
        optionalproxy_onlyowner
    {
        require(_exchangefeerate < max_exchange_fee_rate, );
        exchangefeerate = _exchangefeerate;
    }

    
    function setrewardsauthority(address _rewardsauthority)
        external
        optionalproxy_onlyowner
    {
        rewardsauthority = _rewardsauthority;
    }

    
    function setfeepoolstate(feepoolstate _feepoolstate)
        external
        optionalproxy_onlyowner
    {
        feepoolstate = _feepoolstate;
    }

    
    function setdelegateapprovals(delegateapprovals _delegates)
        external
        optionalproxy_onlyowner
    {
        delegates = _delegates;
    }

    
    function setfeeperiodduration(uint _feeperiodduration)
        external
        optionalproxy_onlyowner
    {
        require(_feeperiodduration >= min_fee_period_duration, );
        require(_feeperiodduration <= max_fee_period_duration, );

        feeperiodduration = _feeperiodduration;

        emitfeeperioddurationupdated(_feeperiodduration);
    }

    
    function setsynthetix(synthetix _synthetix)
        external
        optionalproxy_onlyowner
    {
        require(address(_synthetix) != address(0), );

        synthetix = _synthetix;
    }

    function settargetthreshold(uint _percent)
        external
        optionalproxy_onlyowner
    {
        require(_percent >= 0, );
        require(_percent <= 50, );
        targetthreshold = _percent.mul(safedecimalmath.unit()).div(100);
    }

    
    function recordfeepaid(uint xdramount)
        external
        onlysynthetix
    {
        
        _recentfeeperiodsstorage(0).feestodistribute = _recentfeeperiodsstorage(0).feestodistribute.add(xdramount);
    }

    
    function setrewardstodistribute(uint amount)
        external
    {
        require(messagesender == rewardsauthority || msg.sender == rewardsauthority, );
        
        _recentfeeperiodsstorage(0).rewardstodistribute = _recentfeeperiodsstorage(0).rewardstodistribute.add(amount);
    }

    
    function closecurrentfeeperiod()
        external
    {
        require(_recentfeeperiodsstorage(0).starttime <= (now  feeperiodduration), );

        feeperiod storage secondlastfeeperiod = _recentfeeperiodsstorage(fee_period_length  2);
        feeperiod storage lastfeeperiod = _recentfeeperiodsstorage(fee_period_length  1);

        
        
        
        
        
        _recentfeeperiodsstorage(fee_period_length  2).feestodistribute = lastfeeperiod.feestodistribute
            .sub(lastfeeperiod.feesclaimed)
            .add(secondlastfeeperiod.feestodistribute);
        _recentfeeperiodsstorage(fee_period_length  2).rewardstodistribute = lastfeeperiod.rewardstodistribute
            .sub(lastfeeperiod.rewardsclaimed)
            .add(secondlastfeeperiod.rewardstodistribute);

        
        _currentfeeperiod = _currentfeeperiod.add(fee_period_length).sub(1).mod(fee_period_length);

        
        delete _recentfeeperiods[_currentfeeperiod];

        
        
        _recentfeeperiodsstorage(0).feeperiodid = uint64(uint256(_recentfeeperiodsstorage(1).feeperiodid).add(1));
        _recentfeeperiodsstorage(0).startingdebtindex = uint64(synthetixstate.debtledgerlength());
        _recentfeeperiodsstorage(0).starttime = uint64(now);

        emitfeeperiodclosed(_recentfeeperiodsstorage(1).feeperiodid);
    }

    
    function claimfees()
        external
        optionalproxy
        returns (bool)
    {
        bytes32 currencykey = ;

        return _claimfees(messagesender, currencykey);
    }

    
    function claimonbehalf(address claimingforaddress)
        external
        optionalproxy
        returns (bool)
    {
        require(delegates.approval(claimingforaddress, messagesender), );

        bytes32 currencykey = ;

        return _claimfees(claimingforaddress, currencykey);
    }

    function _claimfees(address claimingaddress, bytes32 currencykey)
        internal
        returns (bool)
    {
        uint rewardspaid = 0;
        uint feespaid = 0;
        uint availablefees;
        uint availablerewards;

        
        
        require(isfeesclaimable(claimingaddress), );

        
        (availablefees, availablerewards) = feesavailable(claimingaddress, );

        require(availablefees > 0 || availablerewards > 0, );

        
        _setlastfeewithdrawal(claimingaddress, _recentfeeperiodsstorage(1).feeperiodid);

        if (availablefees > 0) {
            
            feespaid = _recordfeepayment(availablefees);

            
            _payfees(claimingaddress, feespaid, currencykey);
        }

        if (availablerewards > 0) {
            
            rewardspaid = _recordrewardpayment(availablerewards);

            
            _payrewards(claimingaddress, rewardspaid);
        }

        emitfeesclaimed(claimingaddress, feespaid, rewardspaid);

        return true;
    }

    
    function importfeeperiod(
        uint feeperiodindex, uint feeperiodid, uint startingdebtindex, uint starttime,
        uint feestodistribute, uint feesclaimed, uint rewardstodistribute, uint rewardsclaimed)
        public
        optionalproxy_onlyowner
        onlyduringsetup
    {
        require (startingdebtindex <= synthetixstate.debtledgerlength(), );

        _recentfeeperiods[_currentfeeperiod.add(feeperiodindex).mod(fee_period_length)] = feeperiod({
            feeperiodid: uint64(feeperiodid),
            startingdebtindex: uint64(startingdebtindex),
            starttime: uint64(starttime),
            feestodistribute: feestodistribute,
            feesclaimed: feesclaimed,
            rewardstodistribute: rewardstodistribute,
            rewardsclaimed: rewardsclaimed
        });
    }

    
    function appendvestingentry(address account, uint quantity)
        public
        optionalproxy_onlyowner
    {
        
        synthetix.transferfrom(messagesender, rewardescrow, quantity);

        
        rewardescrow.appendvestingentry(account, quantity);
    }

    
    function approveclaimonbehalf(address account)
        public
        optionalproxy
    {
        require(account != address(0), );
        delegates.setapproval(messagesender, account);
    }

    
    function removeclaimonbehalf(address account)
        public
        optionalproxy
    {
        delegates.withdrawapproval(messagesender, account);
    }

    
    function _recordfeepayment(uint xdramount)
        internal
        returns (uint)
    {
        
        uint remainingtoallocate = xdramount;

        uint feespaid;
        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint feesalreadyclaimed = _recentfeeperiodsstorage(i).feesclaimed;
            uint delta = _recentfeeperiodsstorage(i).feestodistribute.sub(feesalreadyclaimed);

            if (delta > 0) {
                
                uint amountinperiod = delta < remainingtoallocate ? delta : remainingtoallocate;

                _recentfeeperiodsstorage(i).feesclaimed = feesalreadyclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);
                feespaid = feespaid.add(amountinperiod);

                
                if (remainingtoallocate == 0) return feespaid;

                
                
                if (i == 0 && remainingtoallocate > 0) {
                    remainingtoallocate = 0;
                }
            }
        }

        return feespaid;
    }

    
    function _recordrewardpayment(uint snxamount)
        internal
        returns (uint)
    {
        
        uint remainingtoallocate = snxamount;

        uint rewardpaid;

        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint todistribute = _recentfeeperiodsstorage(i).rewardstodistribute.sub(_recentfeeperiodsstorage(i).rewardsclaimed);

            if (todistribute > 0) {
                
                uint amountinperiod = todistribute < remainingtoallocate ? todistribute : remainingtoallocate;

                _recentfeeperiodsstorage(i).rewardsclaimed = _recentfeeperiodsstorage(i).rewardsclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);
                rewardpaid = rewardpaid.add(amountinperiod);

                
                if (remainingtoallocate == 0) return rewardpaid;

                
                
                
                if (i == 0 && remainingtoallocate > 0) {
                    remainingtoallocate = 0;
                }
            }
        }
        return rewardpaid;
    }

    
    function _payfees(address account, uint xdramount, bytes32 destinationcurrencykey)
        internal
        notfeeaddress(account)
    {
        require(account != address(0), );
        require(account != address(this), );
        require(account != address(proxy), );
        require(account != address(synthetix), );

        synth xdrsynth = synthetix.synths(); 
        synth destinationsynth = synthetix.synths(destinationcurrencykey);

        
        

        
        xdrsynth.burn(fee_address, xdramount);

        
        uint destinationamount = synthetix.effectivevalue(, xdramount, destinationcurrencykey);

        

        
        destinationsynth.issue(account, destinationamount);

        

        
        destinationsynth.triggertokenfallbackifneeded(fee_address, account, destinationamount);
    }

    
    function _payrewards(address account, uint snxamount)
        internal
        notfeeaddress(account)
    {
        require(account != address(0), );
        require(account != address(this), );
        require(account != address(proxy), );
        require(account != address(synthetix), );

        
        
        rewardescrow.appendvestingentry(account, snxamount);
    }

    
    function amountreceivedfromtransfer(uint value)
        external
        pure
        returns (uint)
    {
        return value;
    }

    
    function exchangefeeincurred(uint value)
        public
        view
        returns (uint)
    {
        return value.multiplydecimal(exchangefeerate);

        
        
        
        
        
        
        
    }

    
    function amountreceivedfromexchange(uint value)
        external
        view
        returns (uint)
    {
        return value.multiplydecimal(safedecimalmath.unit().sub(exchangefeerate));
    }

    
    function totalfeesavailable(bytes32 currencykey)
        external
        view
        returns (uint)
    {
        uint totalfees = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(_recentfeeperiodsstorage(i).feestodistribute);
            totalfees = totalfees.sub(_recentfeeperiodsstorage(i).feesclaimed);
        }

        return synthetix.effectivevalue(, totalfees, currencykey);
    }

    
    function totalrewardsavailable()
        external
        view
        returns (uint)
    {
        uint totalrewards = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalrewards = totalrewards.add(_recentfeeperiodsstorage(i).rewardstodistribute);
            totalrewards = totalrewards.sub(_recentfeeperiodsstorage(i).rewardsclaimed);
        }

        return totalrewards;
    }

    
    function feesavailable(address account, bytes32 currencykey)
        public
        view
        returns (uint, uint)
    {
        
        uint[2][fee_period_length] memory userfees = feesbyperiod(account);

        uint totalfees = 0;
        uint totalrewards = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(userfees[i][0]);
            totalrewards = totalrewards.add(userfees[i][1]);
        }

        
        
        return (
            synthetix.effectivevalue(, totalfees, currencykey),
            totalrewards
        );
    }

    
    function isfeesclaimable(address account)
        public
        view
        returns (bool)
    {
        
        
        
        uint ratio = synthetix.collateralisationratio(account);
        uint targetratio = synthetixstate.issuanceratio();

        
        if (ratio < targetratio) {
            return true;
        }

        
        uint ratio_threshold = targetratio.multiplydecimal(safedecimalmath.unit().add(targetthreshold));

        
        if (ratio > ratio_threshold) {
            return false;
        }

        return true;
    }

    
    function feesbyperiod(address account)
        public
        view
        returns (uint[2][fee_period_length] memory results)
    {
        
        uint userownershippercentage;
        uint debtentryindex;
        (userownershippercentage, debtentryindex) = feepoolstate.getaccountsdebtentry(account, 0);

        
        
        
        if (debtentryindex == 0 && userownershippercentage == 0) return;

        
        
        uint feesfromperiod;
        uint rewardsfromperiod;
        (feesfromperiod, rewardsfromperiod) = _feesandrewardsfromperiod(0, userownershippercentage, debtentryindex);

        results[0][0] = feesfromperiod;
        results[0][1] = rewardsfromperiod;

        
        uint lastfeewithdrawal = getlastfeewithdrawal(account);

        
        
        for (uint i = fee_period_length  1; i > 0; i) {
            uint next = i  1;
            uint nextperiodstartingdebtindex = _recentfeeperiodsstorage(next).startingdebtindex;

            
            if (nextperiodstartingdebtindex > 0 &&
            lastfeewithdrawal < _recentfeeperiodsstorage(i).feeperiodid) {

                
                
                
                uint closingdebtindex = uint256(nextperiodstartingdebtindex).sub(1);

                
                
                
                (userownershippercentage, debtentryindex) = feepoolstate.applicableissuancedata(account, closingdebtindex);

                (feesfromperiod, rewardsfromperiod) = _feesandrewardsfromperiod(i, userownershippercentage, debtentryindex);

                results[i][0] = feesfromperiod;
                results[i][1] = rewardsfromperiod;
            }
        }
    }

    
    function _feesandrewardsfromperiod(uint period, uint ownershippercentage, uint debtentryindex)
        view
        internal
        returns (uint, uint)
    {
        
        if (ownershippercentage == 0) return (0, 0);

        uint debtownershipforperiod = ownershippercentage;

        
        if (period > 0) {
            uint closingdebtindex = uint256(_recentfeeperiodsstorage(period  1).startingdebtindex).sub(1);
            debtownershipforperiod = _effectivedebtratioforperiod(closingdebtindex, ownershippercentage, debtentryindex);
        }

        
        
        uint feesfromperiod = _recentfeeperiodsstorage(period).feestodistribute
            .multiplydecimal(debtownershipforperiod);

        uint rewardsfromperiod = _recentfeeperiodsstorage(period).rewardstodistribute
            .multiplydecimal(debtownershipforperiod);

        return (
            feesfromperiod.precisedecimaltodecimal(),
            rewardsfromperiod.precisedecimaltodecimal()
        );
    }

    function _effectivedebtratioforperiod(uint closingdebtindex, uint ownershippercentage, uint debtentryindex)
        internal
        view
        returns (uint)
    {
        
        
        uint feeperioddebtownership = synthetixstate.debtledger(closingdebtindex)
            .dividedecimalroundprecise(synthetixstate.debtledger(debtentryindex))
            .multiplydecimalroundprecise(ownershippercentage);

        return feeperioddebtownership;
    }

    function effectivedebtratioforperiod(address account, uint period)
        external
        view
        returns (uint)
    {
        require(period != 0, );
        require(period < fee_period_length, );

        
        if (_recentfeeperiodsstorage(period  1).startingdebtindex == 0) return 0;

        uint closingdebtindex = uint256(_recentfeeperiodsstorage(period  1).startingdebtindex).sub(1);

        uint ownershippercentage;
        uint debtentryindex;
        (ownershippercentage, debtentryindex) = feepoolstate.applicableissuancedata(account, closingdebtindex);

        
        return _effectivedebtratioforperiod(closingdebtindex, ownershippercentage, debtentryindex);
    }

    
    function getlastfeewithdrawal(address _claimingaddress)
        public
        view
        returns (uint)
    {
        return feepooleternalstorage.getuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, _claimingaddress)));
    }

    
    function getpenaltythresholdratio()
        public
        view
        returns (uint)
    {
        uint targetratio = synthetixstate.issuanceratio();

        return targetratio.multiplydecimal(safedecimalmath.unit().add(targetthreshold));
    }

    
    function _setlastfeewithdrawal(address _claimingaddress, uint _feeperiodid)
        internal
    {
        feepooleternalstorage.setuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, _claimingaddress)), _feeperiodid);
    }

    

    modifier onlysynthetix
    {
        require(msg.sender == address(synthetix), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != fee_address, );
        _;
    }

    

    event issuancedebtratioentry(address indexed account, uint debtratio, uint debtentryindex, uint feeperiodstartingdebtindex);
    bytes32 constant issuancedebtratioentry_sig = keccak256();
    function emitissuancedebtratioentry(address account, uint debtratio, uint debtentryindex, uint feeperiodstartingdebtindex) internal {
        proxy._emit(abi.encode(debtratio, debtentryindex, feeperiodstartingdebtindex), 2, issuancedebtratioentry_sig, bytes32(account), 0, 0);
    }

    event exchangefeeupdated(uint newfeerate);
    bytes32 constant exchangefeeupdated_sig = keccak256();
    function emitexchangefeeupdated(uint newfeerate) internal {
        proxy._emit(abi.encode(newfeerate), 1, exchangefeeupdated_sig, 0, 0, 0);
    }

    event feeperioddurationupdated(uint newfeeperiodduration);
    bytes32 constant feeperioddurationupdated_sig = keccak256();
    function emitfeeperioddurationupdated(uint newfeeperiodduration) internal {
        proxy._emit(abi.encode(newfeeperiodduration), 1, feeperioddurationupdated_sig, 0, 0, 0);
    }

    event feeperiodclosed(uint feeperiodid);
    bytes32 constant feeperiodclosed_sig = keccak256();
    function emitfeeperiodclosed(uint feeperiodid) internal {
        proxy._emit(abi.encode(feeperiodid), 1, feeperiodclosed_sig, 0, 0, 0);
    }

    event feesclaimed(address account, uint xdramount, uint snxrewards);
    bytes32 constant feesclaimed_sig = keccak256();
    function emitfeesclaimed(address account, uint xdramount, uint snxrewards) internal {
        proxy._emit(abi.encode(account, xdramount, snxrewards), 1, feesclaimed_sig, 0, 0, 0);
    }
}



pragma solidity 0.4.25;

import ;
import ;

contract feepooleternalstorage is eternalstorage, limitedsetup {

    bytes32 constant last_fee_withdrawal = ;

    
    constructor(address _owner, address _feepool)
        eternalstorage(_owner, _feepool)
        limitedsetup(6 weeks)
        public
    {
    }

    
    function importfeewithdrawaldata(address[] accounts, uint[] feeperiodids)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == feeperiodids.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            this.setuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, accounts[i])), feeperiodids[i]);
        }
    }
}

pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;

contract arbrewarder is selfdestructible, pausable {

    using safemath for uint;
    using safedecimalmath for uint;

    
    uint off_peg_min = 100;

    
    uint acceptable_slippage = 100;

    
    uint max_delay = 600;

    
    uint constant divisor = 10000;

    
    address public uniswapaddress = 0xe9cf7887b93150d4f2da7dfc6d502b216438f244;
    address public synthetixproxy = 0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f;

    iexchangerates public exchangerates = iexchangerates(0x99a46c42689720d9118ff7af7ce80c2a92fc4f97);
    iuniswapexchange public uniswapexchange = iuniswapexchange(uniswapaddress);

    ierc20 public synth = ierc20(0x5e74c9036fb86bd7ecdcb084a0673efc32ea31cb);
    ierc20 public synthetix = ierc20(synthetixproxy);

    
    

    
    constructor(address _owner)
        
        selfdestructible(_owner)
        pausable(_owner)
        public
    {}

    

    function setparams(uint _acceptable_slippage, uint _max_delay, uint _off_peg_min) external onlyowner {
        require(_off_peg_min < divisor, );
        require(_acceptable_slippage < divisor, );
        acceptable_slippage = _acceptable_slippage;
        max_delay = _max_delay;
        off_peg_min = _off_peg_min;
    }

    function setsynthetix(address _address) external onlyowner {
        synthetixproxy = _address;
        synthetix = ierc20(synthetixproxy);
    }

    function setsynthaddress(address _synthaddress) external onlyowner {
        synth = ierc20(_synthaddress);
        synth.approve(uniswapaddress, uint(1));
    }

    function setuniswapexchange(address _uniswapaddress) external onlyowner {
        uniswapaddress = _uniswapaddress;
        uniswapexchange = iuniswapexchange(uniswapaddress);
        synth.approve(uniswapaddress, uint(1));
    }

    function setexchangerates(address _exchangeratesaddress) external onlyowner {
        exchangerates = iexchangerates(_exchangeratesaddress);
    }

    

    function recovereth(address to_addr) external onlyowner {
        to_addr.transfer(address(this).balance);
    }

    function recovererc20(address erc20_addr, address to_addr) external onlyowner {
        ierc20 erc20_interface = ierc20(erc20_addr);
        erc20_interface.transfer(to_addr, erc20_interface.balanceof(address(this)));
    }

    

    
    function arbsynthrate() public payable
        ratenotstale()
        ratenotstale()
        notpaused
        returns (uint reward_tokens)
    {
        
        uint seth_in_uniswap = synth.balanceof(uniswapaddress);
        uint eth_in_uniswap = uniswapaddress.balance;
        require(eth_in_uniswap.dividedecimal(seth_in_uniswap) < uint(divisoroff_peg_min).dividedecimal(divisor), );

        
        uint max_eth_to_convert = maxconvert(eth_in_uniswap, seth_in_uniswap, divisor, divisoroff_peg_min);
        uint eth_to_convert = min(msg.value, max_eth_to_convert);
        uint unspent_input = msg.value  eth_to_convert;

        
        uint min_seth_bought = expectedoutput(uniswapexchange, eth_to_convert);
        uint tokens_bought = uniswapexchange.ethtotokenswapinput.value(eth_to_convert)(min_seth_bought, now + max_delay);

        
        reward_tokens = rewardcaller(tokens_bought, unspent_input);
    }

    function isarbable()
        public
        returns (bool)
    {
        uint seth_in_uniswap = synth.balanceof(uniswapaddress);
        uint eth_in_uniswap = uniswapaddress.balance;
        return eth_in_uniswap.dividedecimal(seth_in_uniswap) < uint(divisoroff_peg_min).dividedecimal(divisor);
    }

    

    function rewardcaller(uint bought, uint unspent_input)
        private
        returns
        (uint reward_tokens)
    {
        uint snx_rate = exchangerates.rateforcurrency();
        uint eth_rate = exchangerates.rateforcurrency();

        reward_tokens = eth_rate.multiplydecimal(bought).dividedecimal(snx_rate);
        synthetix.transfer(msg.sender, reward_tokens);

        if(unspent_input > 0) {
            msg.sender.transfer(unspent_input);
        }
    }

    function expectedoutput(iuniswapexchange exchange, uint input) private view returns (uint output) {
        output = exchange.gettokentoethinputprice(input);
        output = applyslippage(output);
    }

    function applyslippage(uint input) private view returns (uint output) {
        output = input  (input * (acceptable_slippage / divisor));
    }

    
    function maxconvert(uint a, uint b, uint n, uint d) private pure returns (uint result) {
        result = (sqrt((a * (9*a*n + 3988000*b*d)) / n)  1997*a) / 1994;
    }

    function sqrt(uint x) private pure returns (uint y) {
        uint z = (x + 1) / 2;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }

    function min(uint a, uint b) private pure returns (uint result) {
        result = a > b ? b : a;
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!exchangerates.rateisstale(currencykey), );
        _;
    }
}

contract iuniswapexchange {
    
    function tokenaddress() external view returns (address token);
    
    function factoryaddress() external view returns (address factory);
    
    function addliquidity(uint256 min_liquidity, uint256 max_tokens, uint256 deadline) external payable returns (uint256);
    function removeliquidity(uint256 amount, uint256 min_eth, uint256 min_tokens, uint256 deadline) external returns (uint256, uint256);
    
    function getethtotokeninputprice(uint256 eth_sold) external view returns (uint256 tokens_bought);
    function getethtotokenoutputprice(uint256 tokens_bought) external view returns (uint256 eth_sold);
    function gettokentoethinputprice(uint256 tokens_sold) external view returns (uint256 eth_bought);
    function gettokentoethoutputprice(uint256 eth_bought) external view returns (uint256 tokens_sold);
    
    function ethtotokenswapinput(uint256 min_tokens, uint256 deadline) external payable returns (uint256  tokens_bought);
    function ethtotokentransferinput(uint256 min_tokens, uint256 deadline, address recipient) external payable returns (uint256  tokens_bought);
    function ethtotokenswapoutput(uint256 tokens_bought, uint256 deadline) external payable returns (uint256  eth_sold);
    function ethtotokentransferoutput(uint256 tokens_bought, uint256 deadline, address recipient) external payable returns (uint256  eth_sold);
    
    function tokentoethswapinput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256  eth_bought);
    function tokentoethtransferinput(uint256 tokens_sold, uint256 min_eth, uint256 deadline, address recipient) external returns (uint256  eth_bought);
    function tokentoethswapoutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline) external returns (uint256  tokens_sold);
    function tokentoethtransferoutput(uint256 eth_bought, uint256 max_tokens, uint256 deadline, address recipient) external returns (uint256  tokens_sold);
    
    function tokentotokenswapinput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address token_addr) external returns (uint256  tokens_bought);
    function tokentotokentransferinput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_bought);
    function tokentotokenswapoutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address token_addr) external returns (uint256  tokens_sold);
    function tokentotokentransferoutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address token_addr) external returns (uint256  tokens_sold);
    
    function tokentoexchangeswapinput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address exchange_addr) external returns (uint256  tokens_bought);
    function tokentoexchangetransferinput(uint256 tokens_sold, uint256 min_tokens_bought, uint256 min_eth_bought, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_bought);
    function tokentoexchangeswapoutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address exchange_addr) external returns (uint256  tokens_sold);
    function tokentoexchangetransferoutput(uint256 tokens_bought, uint256 max_tokens_sold, uint256 max_eth_sold, uint256 deadline, address recipient, address exchange_addr) external returns (uint256  tokens_sold);
    
    bytes32 public name;
    bytes32 public symbol;
    uint256 public decimals;
    function transfer(address _to, uint256 _value) external returns (bool);
    function transferfrom(address _from, address _to, uint256 value) external returns (bool);
    function approve(address _spender, uint256 _value) external returns (bool);
    function allowance(address _owner, address _spender) external view returns (uint256);
    function balanceof(address _owner) external view returns (uint256);
    function totalsupply() external view returns (uint256);
    
    function setup(address token_addr) external;
}



pragma solidity 0.4.25;


contract owned {
    address public owner;
    address public nominatedowner;

    
    constructor(address _owner)
        public
    {
        require(_owner != address(0), );
        owner = _owner;
        emit ownerchanged(address(0), _owner);
    }

    
    function nominatenewowner(address _owner)
        external
        onlyowner
    {
        nominatedowner = _owner;
        emit ownernominated(_owner);
    }

    
    function acceptownership()
        external
    {
        require(msg.sender == nominatedowner, );
        emit ownerchanged(owner, nominatedowner);
        owner = nominatedowner;
        nominatedowner = address(0);
    }

    modifier onlyowner
    {
        require(msg.sender == owner, );
        _;
    }

    event ownernominated(address newowner);
    event ownerchanged(address oldowner, address newowner);
}


pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;


contract depot is selfdestructible, pausable {
    using safemath for uint;
    using safedecimalmath for uint;

    
    isynthetix public synthetix;
    isynth public synth;
    ifeepool public feepool;

    
    
    
    address public fundswallet;

    
    address public oracle;
    
    uint public constant oracle_future_limit = 10 minutes;

    
    uint public pricestaleperiod = 3 hours;

    
    uint public lastpriceupdatetime;
    
    uint public usdtosnxprice;
    
    uint public usdtoethprice;

    
    struct synthdeposit {
        
        address user;
        
        uint amount;
    }

    
    mapping(uint => synthdeposit) public deposits;
    
    uint public depositstartindex;
    
    uint public depositendindex;

    
    uint public totalsellabledeposits;

    
    uint public minimumdepositamount = 50 * safedecimalmath.unit();

    
    
    
    mapping(address => uint) public smalldeposits;


    

    
    constructor(
        
        address _owner,

        
        address _fundswallet,

        
        isynthetix _synthetix,
        isynth _synth,
        ifeepool _feepool,

        
        address _oracle,
        uint _usdtoethprice,
        uint _usdtosnxprice
    )
        
        selfdestructible(_owner)
        pausable(_owner)
        public
    {
        fundswallet = _fundswallet;
        synthetix = _synthetix;
        synth = _synth;
        feepool = _feepool;
        oracle = _oracle;
        usdtoethprice = _usdtoethprice;
        usdtosnxprice = _usdtosnxprice;
        lastpriceupdatetime = now;
    }

    

    
    function setfundswallet(address _fundswallet)
        external
        onlyowner
    {
        fundswallet = _fundswallet;
        emit fundswalletupdated(fundswallet);
    }

    
    function setoracle(address _oracle)
        external
        onlyowner
    {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    
    function setsynth(isynth _synth)
        external
        onlyowner
    {
        synth = _synth;
        emit synthupdated(_synth);
    }

    
    function setsynthetix(isynthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }

    
    function setpricestaleperiod(uint _time)
        external
        onlyowner
    {
        pricestaleperiod = _time;
        emit pricestaleperiodupdated(pricestaleperiod);
    }

    
    function setminimumdepositamount(uint _amount)
        external
        onlyowner
    {
        
        require(_amount > safedecimalmath.unit(), );
        minimumdepositamount = _amount;
        emit minimumdepositamountupdated(minimumdepositamount);
    }

    
    
    function updateprices(uint newethprice, uint newsynthetixprice, uint timesent)
        external
        onlyoracle
    {
        
        require(lastpriceupdatetime < timesent, );
        require(timesent < (now + oracle_future_limit), );

        usdtoethprice = newethprice;
        usdtosnxprice = newsynthetixprice;
        lastpriceupdatetime = timesent;

        emit pricesupdated(usdtoethprice, usdtosnxprice, lastpriceupdatetime);
    }

    
    function ()
        external
        payable
    {
        exchangeetherforsynths();
    }

    
    function exchangeetherforsynths()
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        uint ethtosend;

        
        
        uint requestedtopurchase = msg.value.multiplydecimal(usdtoethprice);
        uint remainingtofulfill = requestedtopurchase;

        
        for (uint i = depositstartindex; remainingtofulfill > 0 && i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            
            
            if (deposit.user == address(0)) {

                depositstartindex = depositstartindex.add(1);
            } else {
                
                
                if (deposit.amount > remainingtofulfill) {

                    
                    
                    
                    uint newamount = deposit.amount.sub(remainingtofulfill);
                    deposits[i] = synthdeposit({ user: deposit.user, amount: newamount});

                    totalsellabledeposits = totalsellabledeposits.sub(remainingtofulfill);

                    
                    
                    
                    
                    
                    ethtosend = remainingtofulfill.dividedecimal(usdtoethprice);

                    
                    
                    
                    
                    if(!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, remainingtofulfill, i);
                    }

                    
                    
                    
                    
                    synth.transfer(msg.sender, remainingtofulfill);

                    
                    remainingtofulfill = 0;
                } else if (deposit.amount <= remainingtofulfill) {
                    
                    
                    
                    delete deposits[i];
                    
                    depositstartindex = depositstartindex.add(1);
                    
                    totalsellabledeposits = totalsellabledeposits.sub(deposit.amount);

                    
                    
                    
                    
                    
                    ethtosend = deposit.amount.dividedecimal(usdtoethprice);

                    
                    
                    
                    
                    if(!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, deposit.amount, i);
                    }

                    
                    
                    
                    
                    synth.transfer(msg.sender, deposit.amount);

                    
                    
                    remainingtofulfill = remainingtofulfill.sub(deposit.amount);
                }
            }
        }

        
        
        if (remainingtofulfill > 0) {
            msg.sender.transfer(remainingtofulfill.dividedecimal(usdtoethprice));
        }

        
        uint fulfilled = requestedtopurchase.sub(remainingtofulfill);

        if (fulfilled > 0) {
            
            emit exchange(, msg.value, , fulfilled);
        }

        return fulfilled;
    }

    
    function exchangeetherforsynthsatrate(uint guaranteedrate)
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedrate == usdtoethprice, );

        return exchangeetherforsynths();
    }


    
    function exchangeetherforsynthetix()
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        
        uint synthetixtosend = synthetixreceivedforether(msg.value);

        
        fundswallet.transfer(msg.value);

        
        synthetix.transfer(msg.sender, synthetixtosend);

        emit exchange(, msg.value, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangeetherforsynthetixatrate(uint guaranteedetherrate, uint guaranteedsynthetixrate)
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedetherrate == usdtoethprice, );
        require(guaranteedsynthetixrate == usdtosnxprice, );

        return exchangeetherforsynthetix();
    }


    
    function exchangesynthsforsynthetix(uint synthamount)
        public
        pricesnotstale
        notpaused
        returns (uint) 
    {
        
        uint synthetixtosend = synthetixreceivedforsynths(synthamount);

        
        
        
        synth.transferfrom(msg.sender, fundswallet, synthamount);

        
        synthetix.transfer(msg.sender, synthetixtosend);

        emit exchange(, synthamount, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangesynthsforsynthetixatrate(uint synthamount, uint guaranteedrate)
        public
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedrate == usdtosnxprice, );

        return exchangesynthsforsynthetix(synthamount);
    }

    
    function withdrawsynthetix(uint amount)
        external
        onlyowner
    {
        synthetix.transfer(owner, amount);

        
        
        
        
    }

    
    function withdrawmydepositedsynths()
        external
    {
        uint synthstosend = 0;

        for (uint i = depositstartindex; i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            if (deposit.user == msg.sender) {
                
                
                synthstosend = synthstosend.add(deposit.amount);
                delete deposits[i];
                
                emit synthdepositremoved(deposit.user, deposit.amount, i);
            }
        }

        
        totalsellabledeposits = totalsellabledeposits.sub(synthstosend);

        
        
        synthstosend = synthstosend.add(smalldeposits[msg.sender]);
        smalldeposits[msg.sender] = 0;

        
        require(synthstosend > 0, );

        
        synth.transfer(msg.sender, synthstosend);

        emit synthwithdrawal(msg.sender, synthstosend);
    }

    
    function depositsynths(uint amount)
        external
    {
        
        synth.transferfrom(msg.sender, this, amount);

        
        
    }

    
    function tokenfallback(address from, uint amount, bytes data)
        external
        onlysynth
        returns (bool)
    {
        
        
        if (amount < minimumdepositamount) {
            
            
            smalldeposits[from] = smalldeposits[from].add(amount);

            emit synthdepositnotaccepted(from, amount, minimumdepositamount);
        } else {
            
            deposits[depositendindex] = synthdeposit({ user: from, amount: amount });
            emit synthdeposit(from, amount, depositendindex);

            
            depositendindex = depositendindex.add(1);

            
            totalsellabledeposits = totalsellabledeposits.add(amount);
        }
    }

    
    
    function pricesarestale()
        public
        view
        returns (bool)
    {
        return lastpriceupdatetime.add(pricestaleperiod) < now;
    }

    
    function synthetixreceivedforsynths(uint amount)
        public
        view
        returns (uint)
    {
        
        uint synthsreceived = feepool.amountreceivedfromtransfer(amount);

        
        return synthsreceived.dividedecimal(usdtosnxprice);
    }

    
    function synthetixreceivedforether(uint amount)
        public
        view
        returns (uint)
    {
        
        uint valuesentinsynths = amount.multiplydecimal(usdtoethprice);

        
        return synthetixreceivedforsynths(valuesentinsynths);
    }

    
    function synthsreceivedforether(uint amount)
        public
        view
        returns (uint)
    {
        
        uint synthstransferred = amount.multiplydecimal(usdtoethprice);

        
        return feepool.amountreceivedfromtransfer(synthstransferred);
    }

    

    modifier onlyoracle
    {
        require(msg.sender == oracle, );
        _;
    }

    modifier onlysynth
    {
        
        require(msg.sender == address(synth), );
        _;
    }

    modifier pricesnotstale
    {
        require(!pricesarestale(), );
        _;
    }

    

    event fundswalletupdated(address newfundswallet);
    event oracleupdated(address neworacle);
    event synthupdated(isynth newsynthcontract);
    event synthetixupdated(isynthetix newsynthetixcontract);
    event pricestaleperiodupdated(uint pricestaleperiod);
    event pricesupdated(uint newethprice, uint newsynthetixprice, uint timesent);
    event exchange(string fromcurrency, uint fromamount, string tocurrency, uint toamount);
    event synthwithdrawal(address user, uint amount);
    event synthdeposit(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositremoved(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositnotaccepted(address user, uint amount, uint minimum);
    event minimumdepositamountupdated(uint amount);
    event nonpayablecontract(address indexed receiver, uint amount);
    event cleareddeposit(address indexed fromaddress, address indexed toaddress, uint fromethamount, uint toamount, uint indexed depositindex);
}

pragma solidity 0.4.25;


import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract synthetix is externstatetoken {

    

    
    synth[] public availablesynths;
    mapping(bytes32 => synth) public synths;
    mapping(address => bytes32) public synthsbyaddress;

    ifeepool public feepool;
    isynthetixescrow public escrow;
    isynthetixescrow public rewardescrow;
    exchangerates public exchangerates;
    synthetixstate public synthetixstate;
    supplyschedule public supplyschedule;
    irewardsdistribution public rewardsdistribution;

    bool private protectioncircuit = false;

    string constant token_name = ;
    string constant token_symbol = ;
    uint8 constant decimals = 18;
    bool public exchangeenabled = true;
    uint public gaspricelimit;

    address public gaslimitoracle;
    

    
    constructor(address _proxy, tokenstate _tokenstate, synthetixstate _synthetixstate,
        address _owner, exchangerates _exchangerates, ifeepool _feepool, supplyschedule _supplyschedule,
        isynthetixescrow _rewardescrow, isynthetixescrow _escrow, irewardsdistribution _rewardsdistribution, uint _totalsupply
    )
        externstatetoken(_proxy, _tokenstate, token_name, token_symbol, _totalsupply, decimals, _owner)
        public
    {
        synthetixstate = _synthetixstate;
        exchangerates = _exchangerates;
        feepool = _feepool;
        supplyschedule = _supplyschedule;
        rewardescrow = _rewardescrow;
        escrow = _escrow;
        rewardsdistribution = _rewardsdistribution;
    }
    

    function setfeepool(ifeepool _feepool)
        external
        optionalproxy_onlyowner
    {
        feepool = _feepool;
    }

    function setexchangerates(exchangerates _exchangerates)
        external
        optionalproxy_onlyowner
    {
        exchangerates = _exchangerates;
    }

    function setprotectioncircuit(bool _protectioncircuitisactivated)
        external
        onlyoracle
    {
        protectioncircuit = _protectioncircuitisactivated;
    }

    function setexchangeenabled(bool _exchangeenabled)
        external
        optionalproxy_onlyowner
    {
        exchangeenabled = _exchangeenabled;
    }

    function setgaslimitoracle(address _gaslimitoracle)
        external
        optionalproxy_onlyowner
    {
        gaslimitoracle = _gaslimitoracle;
    }

    function setgaspricelimit(uint _gaspricelimit)
        external
    {
        require(msg.sender == gaslimitoracle, );
        require(_gaspricelimit > 0, );
        gaspricelimit = _gaspricelimit;
    }

    
    function addsynth(synth synth)
        external
        optionalproxy_onlyowner
    {
        bytes32 currencykey = synth.currencykey();

        require(synths[currencykey] == synth(0), );
        require(synthsbyaddress[synth] == bytes32(0), );

        availablesynths.push(synth);
        synths[currencykey] = synth;
        synthsbyaddress[synth] = currencykey;
    }

    
    function removesynth(bytes32 currencykey)
        external
        optionalproxy_onlyowner
    {
        require(synths[currencykey] != address(0), );
        require(synths[currencykey].totalsupply() == 0, );
        require(currencykey != , );
        require(currencykey != , );

        
        address synthtoremove = synths[currencykey];

        
        for (uint i = 0; i < availablesynths.length; i++) {
            if (availablesynths[i] == synthtoremove) {
                delete availablesynths[i];

                
                
                
                availablesynths[i] = availablesynths[availablesynths.length  1];

                
                availablesynths.length;

                break;
            }
        }

        
        delete synthsbyaddress[synths[currencykey]];
        delete synths[currencykey];

        
        
        
    }

    

    
    function effectivevalue(bytes32 sourcecurrencykey, uint sourceamount, bytes32 destinationcurrencykey)
        public
        view
        returns (uint)
    {
        return exchangerates.effectivevalue(sourcecurrencykey, sourceamount, destinationcurrencykey);
    }

    
    function totalissuedsynths(bytes32 currencykey)
        public
        view
        returns (uint)
    {
        uint total = 0;
        uint currencyrate = exchangerates.rateforcurrency(currencykey);

        (uint[] memory rates, bool anyratestale) = exchangerates.ratesandstaleforcurrencies(availablecurrencykeys());
        require(!anyratestale, );

        for (uint i = 0; i < availablesynths.length; i++) {
            
            
            
            
            uint synthvalue = availablesynths[i].totalsupply()
                .multiplydecimalround(rates[i]);
            total = total.add(synthvalue);
        }

        return total.dividedecimalround(currencyrate);
    }

    
    function availablecurrencykeys()
        public
        view
        returns (bytes32[])
    {
        bytes32[] memory currencykeys = new bytes32[](availablesynths.length);

        for (uint i = 0; i < availablesynths.length; i++) {
            currencykeys[i] = synthsbyaddress[availablesynths[i]];
        }

        return currencykeys;
    }

    
    function availablesynthcount()
        public
        view
        returns (uint)
    {
        return availablesynths.length;
    }

    
    function feerateforexchange(bytes32 sourcecurrencykey, bytes32 destinationcurrencykey)
        public
        view
        returns (uint)
    {
        
        uint exchangefeerate = feepool.exchangefeerate();

        uint multiplier = 1;

        
        
        if (
            (sourcecurrencykey[0] == 0x73 && sourcecurrencykey !=  && destinationcurrencykey[0] == 0x69) ||
            (sourcecurrencykey[0] == 0x69 && destinationcurrencykey !=  && destinationcurrencykey[0] == 0x73)
        ) {
            
            multiplier = 2;
        }

        return exchangefeerate.mul(multiplier);
    }
    

    
    function transfer(address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transfer(to, value, empty);
    }

    
    function transfer(address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        require(value <= transferablesynthetix(messagesender), );

        
        _transfer_byproxy(messagesender, to, value, data);

        return true;
    }

    
    function transferfrom(address from, address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transferfrom(from, to, value, empty);
    }

    
    function transferfrom(address from, address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        require(value <= transferablesynthetix(from), );

        
        
        _transferfrom_byproxy(messagesender, from, to, value, data);

        return true;
    }

    
    function exchange(bytes32 sourcecurrencykey, uint sourceamount, bytes32 destinationcurrencykey)
        external
        optionalproxy
        
        returns (bool)
    {
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        
        validategasprice(tx.gasprice);

        
        if (protectioncircuit) {
            synths[sourcecurrencykey].burn(messagesender, sourceamount);
            return true;
        } else {
            
            return _internalexchange(
                messagesender,
                sourcecurrencykey,
                sourceamount,
                destinationcurrencykey,
                messagesender,
                true 
            );
        }
    }

    
    function validategasprice(uint _givengasprice)
        public
        view
    {
        require(_givengasprice <= gaspricelimit, );
    }

    
    function synthinitiatedexchange(
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        address destinationaddress
    )
        external
        optionalproxy
        returns (bool)
    {
        require(synthsbyaddress[messagesender] != bytes32(0), );
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        
        return _internalexchange(
            from,
            sourcecurrencykey,
            sourceamount,
            destinationcurrencykey,
            destinationaddress,
            false
        );
    }

    
    function _internalexchange(
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        address destinationaddress,
        bool chargefee
    )
        internal
        notfeeaddress(from)
        returns (bool)
    {
        require(exchangeenabled, );

        
        

        
        synths[sourcecurrencykey].burn(from, sourceamount);

        
        uint destinationamount = effectivevalue(sourcecurrencykey, sourceamount, destinationcurrencykey);

        
        uint amountreceived = destinationamount;
        uint fee = 0;

        if (chargefee) {
            
            uint exchangefeerate = feerateforexchange(sourcecurrencykey, destinationcurrencykey);

            amountreceived = destinationamount.multiplydecimal(safedecimalmath.unit().sub(exchangefeerate));

            fee = destinationamount.sub(amountreceived);
        }

        
        synths[destinationcurrencykey].issue(destinationaddress, amountreceived);

        
        if (fee > 0) {
            uint xdrfeeamount = effectivevalue(destinationcurrencykey, fee, );
            synths[].issue(feepool.fee_address(), xdrfeeamount);
            
            feepool.recordfeepaid(xdrfeeamount);
        }

        

        
        synths[destinationcurrencykey].triggertokenfallbackifneeded(from, destinationaddress, amountreceived);

        
        emitsynthexchange(from, sourcecurrencykey, sourceamount, destinationcurrencykey, amountreceived, destinationaddress);

        return true;
    }

    
    function _addtodebtregister(bytes32 currencykey, uint amount)
        internal
    {
        
        uint xdrvalue = effectivevalue(currencykey, amount, );

        
        uint totaldebtissued = totalissuedsynths();

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        
        uint existingdebt = debtbalanceof(messagesender, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (existingdebt == 0) {
            synthetixstate.incrementtotalissuercount();
        }

        
        synthetixstate.setcurrentissuancedata(messagesender, debtpercentage);

        
        
        if (synthetixstate.debtledgerlength() > 0) {
            synthetixstate.appenddebtledgervalue(
                synthetixstate.lastdebtledgerentry().multiplydecimalroundprecise(delta)
            );
        } else {
            synthetixstate.appenddebtledgervalue(safedecimalmath.preciseunit());
        }
    }

    
    function issuesynths(uint amount)
        public
        optionalproxy
        
    {
        bytes32 currencykey = ;

        require(amount <= remainingissuablesynths(messagesender, currencykey), );

        
        _addtodebtregister(currencykey, amount);

        
        synths[currencykey].issue(messagesender, amount);

        
        _appendaccountissuancerecord();
    }

    
    function issuemaxsynths()
        external
        optionalproxy
    {
        bytes32 currencykey = ;

        
        uint maxissuable = remainingissuablesynths(messagesender, currencykey);

        
        _addtodebtregister(currencykey, maxissuable);

        
        synths[currencykey].issue(messagesender, maxissuable);

        
        _appendaccountissuancerecord();
    }

    
    function burnsynths(uint amount)
        external
        optionalproxy
        
    {
        bytes32 currencykey = ;

        
        uint debttoremove = effectivevalue(currencykey, amount, );
        uint existingdebt = debtbalanceof(messagesender, );

        uint debtincurrencykey = debtbalanceof(messagesender, currencykey);

        require(existingdebt > 0, );

        
        
        uint amounttoremove = existingdebt < debttoremove ? existingdebt : debttoremove;

        
        _removefromdebtregister(amounttoremove, existingdebt);

        uint amounttoburn = debtincurrencykey < amount ? debtincurrencykey : amount;

        
        synths[currencykey].burn(messagesender, amounttoburn);

        
        _appendaccountissuancerecord();
    }

    
    function _appendaccountissuancerecord()
        internal
    {
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetixstate.issuancedata(messagesender);

        feepool.appendaccountissuancerecord(
            messagesender,
            initialdebtownership,
            debtentryindex
        );
    }

    
    function _removefromdebtregister(uint amount, uint existingdebt)
        internal
    {
        uint debttoremove = amount;

        
        uint totaldebtissued = totalissuedsynths();

        
        uint newtotaldebtissued = totaldebtissued.sub(debttoremove);

        uint delta = 0;

        
        
        if (newtotaldebtissued > 0) {

            
            uint debtpercentage = debttoremove.dividedecimalroundprecise(newtotaldebtissued);

            
            
            
            delta = safedecimalmath.preciseunit().add(debtpercentage);
        }

        
        if (debttoremove == existingdebt) {
            synthetixstate.setcurrentissuancedata(messagesender, 0);
            synthetixstate.decrementtotalissuercount();
        } else {
            
            uint newdebt = existingdebt.sub(debttoremove);
            uint newdebtpercentage = newdebt.dividedecimalroundprecise(newtotaldebtissued);

            
            synthetixstate.setcurrentissuancedata(messagesender, newdebtpercentage);
        }

        
        synthetixstate.appenddebtledgervalue(
            synthetixstate.lastdebtledgerentry().multiplydecimalroundprecise(delta)
        );
    }

    

    
    function maxissuablesynths(address issuer, bytes32 currencykey)
        public
        view
        
        returns (uint)
    {
        
        uint destinationvalue = effectivevalue(, collateral(issuer), currencykey);

        
        return destinationvalue.multiplydecimal(synthetixstate.issuanceratio());
    }

    
    function collateralisationratio(address issuer)
        public
        view
        returns (uint)
    {
        uint totalownedsynthetix = collateral(issuer);
        if (totalownedsynthetix == 0) return 0;

        uint debtbalance = debtbalanceof(issuer, );
        return debtbalance.dividedecimalround(totalownedsynthetix);
    }

    
    function debtbalanceof(address issuer, bytes32 currencykey)
        public
        view
        
        returns (uint)
    {
        
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetixstate.issuancedata(issuer);

        
        if (initialdebtownership == 0) return 0;

        
        
        uint currentdebtownership = synthetixstate.lastdebtledgerentry()
            .dividedecimalroundprecise(synthetixstate.debtledger(debtentryindex))
            .multiplydecimalroundprecise(initialdebtownership);

        
        uint totalsystemvalue = totalissuedsynths(currencykey);

        
        uint highprecisionbalance = totalsystemvalue.decimaltoprecisedecimal()
            .multiplydecimalroundprecise(currentdebtownership);

        return highprecisionbalance.precisedecimaltodecimal();
    }

    
    function remainingissuablesynths(address issuer, bytes32 currencykey)
        public
        view
        
        returns (uint)
    {
        uint alreadyissued = debtbalanceof(issuer, currencykey);
        uint max = maxissuablesynths(issuer, currencykey);

        if (alreadyissued >= max) {
            return 0;
        } else {
            return max.sub(alreadyissued);
        }
    }

    
    function collateral(address account)
        public
        view
        returns (uint)
    {
        uint balance = tokenstate.balanceof(account);

        if (escrow != address(0)) {
            balance = balance.add(escrow.balanceof(account));
        }

        if (rewardescrow != address(0)) {
            balance = balance.add(rewardescrow.balanceof(account));
        }

        return balance;
    }

    
    function transferablesynthetix(address account)
        public
        view
        ratenotstale() 
        returns (uint)
    {
        
        
        
        uint balance = tokenstate.balanceof(account);

        
        
        
        
        uint lockedsynthetixvalue = debtbalanceof(account, ).dividedecimalround(synthetixstate.issuanceratio());

        
        if (lockedsynthetixvalue >= balance) {
            return 0;
        } else {
            return balance.sub(lockedsynthetixvalue);
        }
    }

    
    function mint()
        external
        returns (bool)
    {
        require(rewardsdistribution != address(0), );

        uint supplytomint = supplyschedule.mintablesupply();
        require(supplytomint > 0, );

        
        supplyschedule.recordmintevent(supplytomint);

        
        
        uint minterreward = supplyschedule.minterreward();
        
        uint amounttodistribute = supplytomint.sub(minterreward);

        
        tokenstate.setbalanceof(rewardsdistribution, tokenstate.balanceof(rewardsdistribution).add(amounttodistribute));
        emittransfer(this, rewardsdistribution, amounttodistribute);

        
        rewardsdistribution.distributerewards(amounttodistribute);

        
        tokenstate.setbalanceof(msg.sender, tokenstate.balanceof(msg.sender).add(minterreward));
        emittransfer(this, msg.sender, minterreward);

        totalsupply = totalsupply.add(supplytomint);

        return true;
    }

    

    modifier ratenotstale(bytes32 currencykey) {
        require(!exchangerates.rateisstale(currencykey), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != feepool.fee_address(), );
        _;
    }

    modifier onlyoracle
    {
        require(msg.sender == exchangerates.oracle(), );
        _;
    }

    
    
    event synthexchange(address indexed account, bytes32 fromcurrencykey, uint256 fromamount, bytes32 tocurrencykey,  uint256 toamount, address toaddress);
    bytes32 constant synthexchange_sig = keccak256();
    function emitsynthexchange(address account, bytes32 fromcurrencykey, uint256 fromamount, bytes32 tocurrencykey, uint256 toamount, address toaddress) internal {
        proxy._emit(abi.encode(fromcurrencykey, fromamount, tocurrencykey, toamount, toaddress), 2, synthexchange_sig, bytes32(account), 0, 0);
    }
    
}




pragma solidity 0.4.25;


import ;
import ;
import ;
import ;

contract rewardsdistribution is owned {
    using safemath for uint;
    using safedecimalmath for uint;

    
    address public authority;

    
    address public synthetixproxy;
    
    
    address public rewardescrow;

    
    address public feepoolproxy;

    
    struct distributiondata {
        address destination;
        uint amount;
    }

    
    distributiondata[] public distributions;

    
    constructor(address _owner, address _authority, address _synthetixproxy, address _rewardescrow, address _feepoolproxy)
        owned(_owner)
        public
    {
        authority = _authority;
        synthetixproxy = _synthetixproxy;
        rewardescrow = _rewardescrow;
        feepoolproxy = _feepoolproxy;
    }

    

    function setsynthetixproxy(address _synthetixproxy)
        external
        onlyowner
    {
        synthetixproxy = _synthetixproxy;
    }

    function setrewardescrow(address _rewardescrow)
        external
        onlyowner
    {
        rewardescrow = _rewardescrow;
    }

    function setfeepoolproxy(address _feepoolproxy)
        external
        onlyowner
    {
        feepoolproxy = _feepoolproxy;
    }

    
    function setauthority(address _authority)
        external
        onlyowner
    {
        authority = _authority;
    }

    

    
    function addrewarddistribution(address destination, uint amount)
        external
        onlyowner
        returns (bool)
    {
        require(destination != address(0), );
        require(amount != 0, );

        distributiondata memory rewardsdistribution = distributiondata(destination, amount);
        distributions.push(rewardsdistribution);

        emit rewarddistributionadded(distributions.length  1, destination, amount);
        return true;
    }

    
    function removerewarddistribution(uint index)
        external
        onlyowner
    {
        require(index <= distributions.length  1, );

        
        for (uint i = index; i < distributions.length  1; i++) {
            distributions[i] = distributions[i+1];
        }
        distributions.length;

        
        
        
        
    }

     
    function editrewarddistribution(uint index, address destination, uint amount)
        external
        onlyowner
        returns (bool)
    {
        require(index <= distributions.length  1, );

        distributions[index].destination = destination;
        distributions[index].amount = amount;

        return true;
    }

    
    function distributerewards(uint amount)
        external
        returns (bool)
    {
        require(msg.sender == authority, );
        require(rewardescrow != address(0), );
        require(synthetixproxy != address(0), );
        require(feepoolproxy != address(0), );
        require(amount > 0, );
        require(ierc20(synthetixproxy).balanceof(this) >= amount, );
                
        uint remainder = amount;

        
        for (uint i = 0; i < distributions.length; i++) {
            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {
                remainder = remainder.sub(distributions[i].amount);
                ierc20(synthetixproxy).transfer(distributions[i].destination, distributions[i].amount);
            }
        }

        
        ierc20(synthetixproxy).transfer(rewardescrow, remainder);

        
        ifeepool(feepoolproxy).setrewardstodistribute(remainder);

        emit rewardsdistributed(amount);
        return true;
    }

    

    
    function distributionslength()
        external
        view
        returns (uint)
    {
        return distributions.length;
    }

    

    event rewarddistributionadded(uint index, address destination, uint amount);
    event rewardsdistributed(uint amount);
}

pragma solidity 0.4.25;


import ;
import ;
import ;
import ;
import ;
import ;

contract isynthetix {

    

    ifeepool public feepool;
    isynthetixescrow public escrow;
    isynthetixescrow public rewardescrow;
    isynthetixstate public synthetixstate;
    iexchangerates public exchangerates;

    uint public totalsupply;
        
    mapping(bytes32 => synth) public synths;

    

    function balanceof(address account) public view returns (uint);
    function transfer(address to, uint value) public returns (bool);
    function effectivevalue(bytes32 sourcecurrencykey, uint sourceamount, bytes32 destinationcurrencykey) public view returns (uint);

    function synthinitiatedexchange(
        address from,
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey,
        address destinationaddress) external returns (bool);
    function exchange(
        bytes32 sourcecurrencykey,
        uint sourceamount,
        bytes32 destinationcurrencykey) external returns (bool);
    function collateralisationratio(address issuer) public view returns (uint);
    function totalissuedsynths(bytes32 currencykey)
        public
        view
        returns (uint);
    function getsynth(bytes32 currencykey) public view returns (isynth);
    function debtbalanceof(address issuer, bytes32 currencykey) public view returns (uint);
}

pragma solidity 0.4.25;


contract isynthetixstate {
    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    uint[] public debtledger;
    uint public issuanceratio;
    mapping(address => issuancedata) public issuancedata;

    function debtledgerlength() external view returns (uint);
    function hasissued(address account) external view returns (bool);
    function incrementtotalissuercount() external;
    function decrementtotalissuercount() external;
    function setcurrentissuancedata(address account, uint initialdebtownership) external;
    function lastdebtledgerentry() external view returns (uint);
    function appenddebtledgervalue(uint value) external;
    function clearissuancedata(address account) external;
}

pragma solidity 0.4.25;


contract ifeepool {
    address public fee_address;
    uint public exchangefeerate;
    function amountreceivedfromexchange(uint value) external view returns (uint);
    function amountreceivedfromtransfer(uint value) external view returns (uint);
    function recordfeepaid(uint xdramount) external;
    function appendaccountissuancerecord(address account, uint lockedamount, uint debtentryindex) external;
    function setrewardstodistribute(uint amount) external;
}

pragma solidity 0.4.25;


interface isynthetixescrow {
    function balanceof(address account) public view returns (uint);
    function appendvestingentry(address account, uint quantity) public;
}

pragma solidity 0.4.25;


interface irewardsdistribution {
    function distributerewards(uint amount) external;
}

pragma solidity 0.4.25;

interface isynth {
    function burn(address account, uint amount) external;
    function issue(address account, uint amount) external;
    function transfer(address to, uint value) public returns (bool);
    function triggertokenfallbackifneeded(address sender, address recipient, uint amount) external;
    function transferfrom(address from, address to, uint value) public returns (bool);
}

pragma solidity 0.4.25;


interface iexchangerates {
    function effectivevalue(bytes32 sourcecurrencykey, uint sourceamount, bytes32 destinationcurrencykey) external view returns (uint);

    function rateforcurrency(bytes32 currencykey) external view returns (uint);
    function ratesforcurrencies(bytes32[] currencykeys) external view returns (uint[] memory);

    function rateisstale(bytes32 currencykey) external view returns (bool);
    function anyrateisstale(bytes32[] currencykeys) external view returns (bool);
}

pragma solidity 0.4.25;


contract ierc20 {
    function totalsupply() public view returns (uint);

    function balanceof(address owner) public view returns (uint);

    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);

    function approve(address spender, uint value) public returns (bool);

    function transferfrom(address from, address to, uint value) public returns (bool);

    
    function name() public view returns (string);
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);

    event transfer(
        address indexed from,
        address indexed to,
        uint value
    );

    event approval(
        address indexed owner,
        address indexed spender,
        uint value
    );
}


pragma solidity 0.4.25;

interface aggregatorinterface {
    function latestanswer() external view returns (int256);
    function latesttimestamp() external view returns (uint256);
    
    
    

    
    
}

contract mockaggregator is aggregatorinterface {

    int256 private _latestanswer;
    uint256 private _latesttimestamp;

    constructor () public { }

    
    function setlatestanswer(int256 answer, uint256 timestamp) external {
        _latestanswer = answer;
        _latesttimestamp = timestamp;
    }

    function latestanswer() external view returns (int256) {
        return _latestanswer;
    }

    function latesttimestamp() external view returns (uint256) {
        return _latesttimestamp;
    }
}


pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract tokenexchanger is owned {

    address public integrationproxy;
    address public synthetix;

    constructor(address _owner, address _integrationproxy)
        owned(_owner)
        public
    {
        integrationproxy = _integrationproxy;
    }

    function setsynthetixproxy(address _integrationproxy)
        external
        onlyowner
    {
        integrationproxy = _integrationproxy;
    }

    function setsynthetix(address _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
    }

    function checkbalance(address account)
        public
        view
        synthetixproxyisset
        returns (uint)
    {
        return ierc20(integrationproxy).balanceof(account);
    }

    function checkallowance(address tokenowner, address spender)
        public
        view
        synthetixproxyisset
        returns (uint)
    {
        return ierc20(integrationproxy).allowance(tokenowner, spender);
    }

    function checkbalancesnxdirect(address account)
        public
        view
        synthetixproxyisset
        returns (uint)
    {
        return ierc20(synthetix).balanceof(account);
    }

    function getdecimals(address tokenaddress)
        public
        view
        returns (uint)
    {
        return ierc20(tokenaddress).decimals();
    }

    function dotokenspend(address fromaccount, address toaccount, uint amount)
        public
        synthetixproxyisset
        returns (bool)
    {
        
        require(checkbalance(fromaccount) >= amount, );

        
        require(checkallowance(fromaccount, address(this)) >= amount, );

        
        return ierc20(integrationproxy).transferfrom(fromaccount, toaccount, amount);
    }

    modifier synthetixproxyisset {
        require(integrationproxy != address(0), );
        _;
    }

    event logstring(string name, string value);
    event logint(string name, uint value);
    event logaddress(string name, address value);
    event logbytes(string name, bytes4 value);
}


pragma solidity 0.4.25;

import ;

contract publicsafedecimalmath {
    using safedecimalmath for uint;
    
    function unit()
        public
        pure
        returns (uint)
    {
        return safedecimalmath.unit();
    }

    function preciseunit()
        public
        pure
        returns (uint)
    {
        return safedecimalmath.preciseunit();
    }

    function multiplydecimal(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimal(y);
    }

    function multiplydecimalround(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimalround(y);
    }

    function multiplydecimalroundprecise(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimalroundprecise(y);
    }

    function dividedecimal(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimal(y);
    }

    function dividedecimalround(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimalround(y);
    }

    function dividedecimalroundprecise(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimalroundprecise(y);
    }

    function decimaltoprecisedecimal(uint i)
        public
        pure
        returns (uint)
    {
        return i.decimaltoprecisedecimal();
    }

    function precisedecimaltodecimal(uint i)
        public
        pure
        returns (uint)
    {
        return i.precisedecimaltodecimal();
    }
}

