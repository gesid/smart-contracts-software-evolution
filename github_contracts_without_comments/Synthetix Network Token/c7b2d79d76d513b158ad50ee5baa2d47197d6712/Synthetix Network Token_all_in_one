


pragma solidity 0.4.25;


import ;


contract state is owned {
    
    
    address public associatedcontract;


    constructor(address _owner, address _associatedcontract)
        owned(_owner)
        public
    {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    
    function setassociatedcontract(address _associatedcontract)
        external
        onlyowner
    {
        associatedcontract = _associatedcontract;
        emit associatedcontractupdated(_associatedcontract);
    }

    

    modifier onlyassociatedcontract
    {
        require(msg.sender == associatedcontract, );
        _;
    }

    

    event associatedcontractupdated(address associatedcontract);
}



pragma solidity 0.4.25;
import ;


contract eternalstorage is state {

    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {
    }

    
    mapping(bytes32 => uint) uintstorage;
    mapping(bytes32 => string) stringstorage;
    mapping(bytes32 => address) addressstorage;
    mapping(bytes32 => bytes) bytesstorage;
    mapping(bytes32 => bytes32) bytes32storage;
    mapping(bytes32 => bool) booleanstorage;
    mapping(bytes32 => int) intstorage;

    
    function getuintvalue(bytes32 record) external view returns (uint){
        return uintstorage[record];
    }

    function setuintvalue(bytes32 record, uint value) external
        onlyassociatedcontract
    {
        uintstorage[record] = value;
    }

    function deleteuintvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete uintstorage[record];
    }

    
    function getstringvalue(bytes32 record) external view returns (string memory){
        return stringstorage[record];
    }

    function setstringvalue(bytes32 record, string value) external
        onlyassociatedcontract
    {
        stringstorage[record] = value;
    }

    function deletestringvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete stringstorage[record];
    }

    
    function getaddressvalue(bytes32 record) external view returns (address){
        return addressstorage[record];
    }

    function setaddressvalue(bytes32 record, address value) external
        onlyassociatedcontract
    {
        addressstorage[record] = value;
    }

    function deleteaddressvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete addressstorage[record];
    }


    
    function getbytesvalue(bytes32 record) external view returns
    (bytes memory){
        return bytesstorage[record];
    }

    function setbytesvalue(bytes32 record, bytes value) external
        onlyassociatedcontract
    {
        bytesstorage[record] = value;
    }

    function deletebytesvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete bytesstorage[record];
    }

    
    function getbytes32value(bytes32 record) external view returns (bytes32)
    {
        return bytes32storage[record];
    }

    function setbytes32value(bytes32 record, bytes32 value) external
        onlyassociatedcontract
    {
        bytes32storage[record] = value;
    }

    function deletebytes32value(bytes32 record) external
        onlyassociatedcontract
    {
        delete bytes32storage[record];
    }

    
    function getbooleanvalue(bytes32 record) external view returns (bool)
    {
        return booleanstorage[record];
    }

    function setbooleanvalue(bytes32 record, bool value) external
        onlyassociatedcontract
    {
        booleanstorage[record] = value;
    }

    function deletebooleanvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete booleanstorage[record];
    }

    
    function getintvalue(bytes32 record) external view returns (int){
        return intstorage[record];
    }

    function setintvalue(bytes32 record, int value) external
        onlyassociatedcontract
    {
        intstorage[record] = value;
    }

    function deleteintvalue(bytes32 record) external
        onlyassociatedcontract
    {
        delete intstorage[record];
    }
}

pragma solidity 0.4.25;


import ;

contract delegateapprovals is state {

    
    
    mapping(address => mapping(address => bool)) public approval;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {}

    function setapproval(address authoriser, address delegate)
        external
        onlyassociatedcontract
    {
        approval[authoriser][delegate] = true;
        emit approval(authoriser, delegate);
    }

    function withdrawapproval(address authoriser, address delegate)
        external
        onlyassociatedcontract
    {
        delete approval[authoriser][delegate];
        emit withdrawapproval(authoriser, delegate);
    }

     

    event approval(address indexed authoriser, address delegate);
    event withdrawapproval(address indexed authoriser, address delegate);
}




pragma solidity 0.4.25;

import ;
import ;
import ;


contract purgeablesynth is synth {

    using safedecimalmath for uint;

    
    uint public maxsupplytopurgeinusd = 100000 * safedecimalmath.unit(); 

    
    exchangerates public exchangerates;

    

    constructor(address _proxy, tokenstate _tokenstate, synthetix _synthetix, ifeepool _feepool,
        string _tokenname, string _tokensymbol, address _owner, bytes4 _currencykey, exchangerates _exchangerates
    )
        synth(_proxy, _tokenstate, _synthetix, _feepool, _tokenname, _tokensymbol, _owner, _currencykey)
        public
    {
        exchangerates = _exchangerates;
    }

    

    
    function purge(address[] addresses)
        external
        optionalproxy_onlyowner
    {
        uint maxsupplytopurge = exchangerates.effectivevalue(, maxsupplytopurgeinusd, currencykey);

        
        require(
            totalsupply <= maxsupplytopurge || exchangerates.rateisfrozen(currencykey),
            
        );

        for (uint8 i = 0; i < addresses.length; i++) {
            address holder = addresses[i];

            uint amountheld = balanceof(holder);

            if (amountheld > 0) {
                synthetix.synthinitiatedexchange(holder, currencykey, amountheld, , holder);
                emitpurged(holder, amountheld);
            }

        }

    }

    

    function setexchangerates(exchangerates _exchangerates)
        external
        optionalproxy_onlyowner
    {
        exchangerates = _exchangerates;
    }

    

    event purged(address indexed account, uint value);
    bytes32 constant purged_sig = keccak256();
    function emitpurged(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, purged_sig, bytes32(account), 0, 0);
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;

contract synth is externstatetoken {

    

    ifeepool public feepool;
    synthetix public synthetix;

    
    bytes4 public currencykey;

    uint8 constant decimals = 18;

    

    constructor(address _proxy, tokenstate _tokenstate, synthetix _synthetix, ifeepool _feepool,
        string _tokenname, string _tokensymbol, address _owner, bytes4 _currencykey
    )
        externstatetoken(_proxy, _tokenstate, _tokenname, _tokensymbol, 0, decimals, _owner)
        public
    {
        require(_proxy != 0, );
        require(address(_synthetix) != 0, );
        require(address(_feepool) != 0, );
        require(_owner != 0, );
        require(_synthetix.synths(_currencykey) == synth(0), );

        feepool = _feepool;
        synthetix = _synthetix;
        currencykey = _currencykey;
    }

    

    function setsynthetix(synthetix _synthetix)
        external
        optionalproxy_onlyowner
    {
        synthetix = _synthetix;
        emitsynthetixupdated(_synthetix);
    }

    function setfeepool(ifeepool _feepool)
        external
        optionalproxy_onlyowner
    {
        feepool = _feepool;
        emitfeepoolupdated(_feepool);
    }

    

    
    function transfer(address to, uint value)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        bytes memory empty;
        return _internaltransfer(messagesender, to, amountreceived, empty);
    }

    
    function transfer(address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        return _internaltransfer(messagesender, to, amountreceived, data);
    }

    
    function transferfrom(address from, address to, uint value)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        bytes memory empty;
        return _internaltransfer(from, to, amountreceived, empty);
    }

    
    function transferfrom(address from, address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        
        uint amountreceived = feepool.amountreceivedfromtransfer(value);
        uint fee = value.sub(amountreceived);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        return _internaltransfer(from, to, amountreceived, data);
    }

    
    function transfersenderpaysfee(address to, uint value)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        bytes memory empty;
        return _internaltransfer(messagesender, to, value, empty);
    }

    
    function transfersenderpaysfee(address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(messagesender)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        synthetix.synthinitiatedfeepayment(messagesender, currencykey, fee);

        
        return _internaltransfer(messagesender, to, value, data);
    }

    
    function transferfromsenderpaysfee(address from, address to, uint value)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value.add(fee)));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        bytes memory empty;
        return _internaltransfer(from, to, value, empty);
    }

    
    function transferfromsenderpaysfee(address from, address to, uint value, bytes data)
        public
        optionalproxy
        notfeeaddress(from)
        returns (bool)
    {
        uint fee = feepool.transferfeeincurred(value);

        
        
        tokenstate.setallowance(from, messagesender, tokenstate.allowance(from, messagesender).sub(value.add(fee)));

        
        synthetix.synthinitiatedfeepayment(from, currencykey, fee);

        return _internaltransfer(from, to, value, data);
    }

    
    function _internaltransfer(address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        bytes4 preferredcurrencykey = synthetix.synthetixstate().preferredcurrency(to);

        
        if (preferredcurrencykey != 0 && preferredcurrencykey != currencykey) {
            return synthetix.synthinitiatedexchange(from, currencykey, value, preferredcurrencykey, to);
        } else {
            
            return super._internaltransfer(from, to, value, data);
        }
    }

    
    function issue(address account, uint amount)
        external
        onlysynthetixorfeepool
    {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).add(amount));
        totalsupply = totalsupply.add(amount);
        emittransfer(address(0), account, amount);
        emitissued(account, amount);
    }

    
    function burn(address account, uint amount)
        external
        onlysynthetixorfeepool
    {
        tokenstate.setbalanceof(account, tokenstate.balanceof(account).sub(amount));
        totalsupply = totalsupply.sub(amount);
        emittransfer(account, address(0), amount);
        emitburned(account, amount);
    }

    
    function settotalsupply(uint amount)
        external
        optionalproxy_onlyowner
    {
        totalsupply = amount;
    }

    
    
    function triggertokenfallbackifneeded(address sender, address recipient, uint amount)
        external
        onlysynthetixorfeepool
    {
        bytes memory empty;
        calltokenfallbackifneeded(sender, recipient, amount, empty);
    }

    

    modifier onlysynthetixorfeepool() {
        bool issynthetix = msg.sender == address(synthetix);
        bool isfeepool = msg.sender == address(feepool);

        require(issynthetix || isfeepool, );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != feepool.fee_address(), );
        _;
    }

    

    event synthetixupdated(address newsynthetix);
    bytes32 constant synthetixupdated_sig = keccak256();
    function emitsynthetixupdated(address newsynthetix) internal {
        proxy._emit(abi.encode(newsynthetix), 1, synthetixupdated_sig, 0, 0, 0);
    }

    event feepoolupdated(address newfeepool);
    bytes32 constant feepoolupdated_sig = keccak256();
    function emitfeepoolupdated(address newfeepool) internal {
        proxy._emit(abi.encode(newfeepool), 1, feepoolupdated_sig, 0, 0, 0);
    }

    event issued(address indexed account, uint value);
    bytes32 constant issued_sig = keccak256();
    function emitissued(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, issued_sig, bytes32(account), 0, 0);
    }

    event burned(address indexed account, uint value);
    bytes32 constant burned_sig = keccak256();
    function emitburned(address account, uint value) internal {
        proxy._emit(abi.encode(value), 2, burned_sig, bytes32(account), 0, 0);
    }
}


pragma solidity 0.4.25;

import ;

contract tokenfallbackcaller is reentrancypreventer {
    function calltokenfallbackifneeded(address sender, address recipient, uint amount, bytes data)
        internal
        preventreentrancy
    {
        

        
        uint length;

        
        assembly {
            
            length := extcodesize(recipient)
        }

        
        if (length > 0) {
            
            

            
            recipient.call(abi.encodewithsignature(, sender, amount, data));

            
        }
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;


contract externstatetoken is selfdestructible, proxyable, tokenfallbackcaller {

    using safemath for uint;
    using safedecimalmath for uint;

    

    
    tokenstate public tokenstate;

    
    string public name;
    string public symbol;
    uint public totalsupply;
    uint8 public decimals;

    
    constructor(address _proxy, tokenstate _tokenstate,
                string _name, string _symbol, uint _totalsupply,
                uint8 _decimals, address _owner)
        selfdestructible(_owner)
        proxyable(_proxy, _owner)
        public
    {
        tokenstate = _tokenstate;

        name = _name;
        symbol = _symbol;
        totalsupply = _totalsupply;
        decimals = _decimals;
    }

    

    
    function allowance(address owner, address spender)
        public
        view
        returns (uint)
    {
        return tokenstate.allowance(owner, spender);
    }

    
    function balanceof(address account)
        public
        view
        returns (uint)
    {
        return tokenstate.balanceof(account);
    }

    

     
    function settokenstate(tokenstate _tokenstate)
        external
        optionalproxy_onlyowner
    {
        tokenstate = _tokenstate;
        emittokenstateupdated(_tokenstate);
    }

    function _internaltransfer(address from, address to, uint value, bytes data) 
        internal
        returns (bool)
    { 
        
        require(to != address(0), );
        require(to != address(this), );
        require(to != address(proxy), );

        
        tokenstate.setbalanceof(from, tokenstate.balanceof(from).sub(value));
        tokenstate.setbalanceof(to, tokenstate.balanceof(to).add(value));

        
        
        
        calltokenfallbackifneeded(from, to, value, data);
        
        
        emittransfer(from, to, value);

        return true;
    }

    
    function _transfer_byproxy(address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        return _internaltransfer(from, to, value, data);
    }

    
    function _transferfrom_byproxy(address sender, address from, address to, uint value, bytes data)
        internal
        returns (bool)
    {
        
        tokenstate.setallowance(from, sender, tokenstate.allowance(from, sender).sub(value));
        return _internaltransfer(from, to, value, data);
    }

    
    function approve(address spender, uint value)
        public
        optionalproxy
        returns (bool)
    {
        address sender = messagesender;

        tokenstate.setallowance(sender, spender, value);
        emitapproval(sender, spender, value);
        return true;
    }

    

    event transfer(address indexed from, address indexed to, uint value);
    bytes32 constant transfer_sig = keccak256();
    function emittransfer(address from, address to, uint value) internal {
        proxy._emit(abi.encode(value), 3, transfer_sig, bytes32(from), bytes32(to), 0);
    }

    event approval(address indexed owner, address indexed spender, uint value);
    bytes32 constant approval_sig = keccak256();
    function emitapproval(address owner, address spender, uint value) internal {
        proxy._emit(abi.encode(value), 3, approval_sig, bytes32(owner), bytes32(spender), 0);
    }

    event tokenstateupdated(address newtokenstate);
    bytes32 constant tokenstateupdated_sig = keccak256();
    function emittokenstateupdated(address newtokenstate) internal {
        proxy._emit(abi.encode(newtokenstate), 1, tokenstateupdated_sig, 0, 0, 0);
    }
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;


contract synthetixescrow is owned, limitedsetup(8 weeks) {

    using safemath for uint;

    
    isynthetix public synthetix;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalvestedbalance;

    uint constant time_index = 0;
    uint constant quantity_index = 1;

    
    uint constant max_vesting_entries = 20;


    

    constructor(address _owner, isynthetix _synthetix)
        owned(_owner)
        public
    {
        synthetix = _synthetix;
    }


    

    function setsynthetix(isynthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }


    

    
    function balanceof(address account)
        public
        view
        returns (uint)
    {
        return totalvestedaccountbalance[account];
    }

    
    function numvestingentries(address account)
        public
        view
        returns (uint)
    {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index)
        public
        view
        returns (uint[2])
    {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index)
        public
        view
        returns (uint)
    {
        return getvestingscheduleentry(account,index)[time_index];
    }

    
    function getvestingquantity(address account, uint index)
        public
        view
        returns (uint)
    {
        return getvestingscheduleentry(account,index)[quantity_index];
    }

    
    function getnextvestingindex(address account)
        public
        view
        returns (uint)
    {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account)
        public
        view
        returns (uint[2])
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account)
        external
        view
        returns (uint)
    {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account)
        external
        view
        returns (uint)
    {
        return getnextvestingentry(account)[quantity_index];
    }


    

    
    function withdrawsynthetix(uint quantity)
        external
        onlyowner
        onlyduringsetup
    {
        synthetix.transfer(synthetix, quantity);
    }

    
    function purgeaccount(address account)
        external
        onlyowner
        onlyduringsetup
    {
        delete vestingschedules[account];
        totalvestedbalance = totalvestedbalance.sub(totalvestedaccountbalance[account]);
        delete totalvestedaccountbalance[account];
    }

    
    function appendvestingentry(address account, uint time, uint quantity)
        public
        onlyowner
        onlyduringsetup
    {
        
        require(now < time, );
        require(quantity != 0, );

        
        totalvestedbalance = totalvestedbalance.add(quantity);
        require(totalvestedbalance <= synthetix.balanceof(this), );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        if (schedulelength == 0) {
            totalvestedaccountbalance[account] = quantity;
        } else {
            
            require(getvestingtime(account, numvestingentries(account)  1) < time, );
            totalvestedaccountbalance[account] = totalvestedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);
    }

    
    function addvestingschedule(address account, uint[] times, uint[] quantities)
        external
        onlyowner
        onlyduringsetup
    {
        for (uint i = 0; i < times.length; i++) {
            appendvestingentry(account, times[i], quantities[i]);
        }

    }

    
    function vest()
        external
    {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalvestedbalance = totalvestedbalance.sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].sub(total);
            synthetix.transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }


    

    event synthetixupdated(address newsynthetix);

    event vested(address indexed beneficiary, uint time, uint value);
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;


contract rewardescrow is owned {

    using safemath for uint;

    
    isynthetix public synthetix;

    ifeepool public feepool;

    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalescrowedaccountbalance;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalescrowedbalance;

    uint constant time_index = 0;
    uint constant quantity_index = 1;

    
    uint constant public max_vesting_entries = 52*5;


    

    constructor(address _owner, isynthetix _synthetix, ifeepool _feepool)
    owned(_owner)
    public
    {
        synthetix = _synthetix;
        feepool = _feepool;
    }


    

    
    function setsynthetix(isynthetix _synthetix)
    external
    onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }

    
    function setfeepool(ifeepool _feepool)
        external
        onlyowner
    {
        feepool = _feepool;
        emit feepoolupdated(_feepool);
    }


    

    
    function balanceof(address account)
    public
    view
    returns (uint)
    {
        return totalescrowedaccountbalance[account];
    }

    
    function numvestingentries(address account)
    public
    view
    returns (uint)
    {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index)
    public
    view
    returns (uint[2])
    {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index)
    public
    view
    returns (uint)
    {
        return getvestingscheduleentry(account,index)[time_index];
    }

    
    function getvestingquantity(address account, uint index)
    public
    view
    returns (uint)
    {
        return getvestingscheduleentry(account,index)[quantity_index];
    }

    
    function getnextvestingindex(address account)
    public
    view
    returns (uint)
    {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account)
    public
    view
    returns (uint[2])
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account)
    external
    view
    returns (uint)
    {
        return getnextvestingentry(account)[time_index];
    }

    
    function getnextvestingquantity(address account)
    external
    view
    returns (uint)
    {
        return getnextvestingentry(account)[quantity_index];
    }

    
    function checkaccountschedule(address account)
        public
        view
        returns (uint[520])
    {
        uint[520] memory _result;
        uint schedules = numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = getvestingscheduleentry(account, i);
            _result[i*2] = pair[0];
            _result[i*2 + 1] = pair[1];
        }
        return _result;
    }


    

    
    function appendvestingentry(address account, uint quantity)
    public
    onlyfeepool
    {
        
        require(quantity != 0, );

        
        totalescrowedbalance = totalescrowedbalance.add(quantity);
        require(totalescrowedbalance <= synthetix.balanceof(this), );

        
        uint schedulelength = vestingschedules[account].length;
        require(schedulelength <= max_vesting_entries, );

        
        uint time = now + 52 weeks;

        if (schedulelength == 0) {
            totalescrowedaccountbalance[account] = quantity;
        } else {
            
            require(getvestingtime(account, numvestingentries(account)  1) < time, );
            totalescrowedaccountbalance[account] = totalescrowedaccountbalance[account].add(quantity);
        }

        vestingschedules[account].push([time, quantity]);

        emit vestingentrycreated(account, now, quantity);
    }

    
    function vest()
    external
    {
        uint numentries = numvestingentries(msg.sender);
        uint total;
        for (uint i = 0; i < numentries; i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = total.add(qty);
        }

        if (total != 0) {
            totalescrowedbalance = totalescrowedbalance.sub(total);
            totalescrowedaccountbalance[msg.sender] = totalescrowedaccountbalance[msg.sender].sub(total);
            totalvestedaccountbalance[msg.sender] = totalvestedaccountbalance[msg.sender].add(total);
            synthetix.transfer(msg.sender, total);
            emit vested(msg.sender, now, total);
        }
    }

    

    modifier onlyfeepool() {
        bool isfeepool = msg.sender == address(feepool);

        require(isfeepool, );
        _;
    }


    

    event synthetixupdated(address newsynthetix);

    event feepoolupdated(address newfeepool);

    event vested(address indexed beneficiary, uint time, uint value);

    event vestingentrycreated(address indexed beneficiary, uint time, uint value);

}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;


contract synthetixstate is state, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    
    mapping(address => issuancedata) public issuancedata;

    
    uint public totalissuercount;

    
    uint[] public debtledger;

    
    uint public importedxdramount;

    
    
    uint public issuanceratio = safedecimalmath.unit() / 5;
    
    uint constant max_issuance_ratio = safedecimalmath.unit();

    
    
    mapping(address => bytes4) public preferredcurrency;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        limitedsetup(1 weeks)
        public
    {}

    

    
    function setcurrentissuancedata(address account, uint initialdebtownership)
        external
        onlyassociatedcontract
    {
        issuancedata[account].initialdebtownership = initialdebtownership;
        issuancedata[account].debtentryindex = debtledger.length;
    }

    
    function clearissuancedata(address account)
        external
        onlyassociatedcontract
    {
        delete issuancedata[account];
    }

    
    function incrementtotalissuercount()
        external
        onlyassociatedcontract
    {
        totalissuercount = totalissuercount.add(1);
    }

    
    function decrementtotalissuercount()
        external
        onlyassociatedcontract
    {
        totalissuercount = totalissuercount.sub(1);
    }

    
    function appenddebtledgervalue(uint value)
        external
        onlyassociatedcontract
    {
        debtledger.push(value);
    }

    
    function setpreferredcurrency(address account, bytes4 currencykey)
        external
        onlyassociatedcontract
    {
        preferredcurrency[account] = currencykey;
    }

    
    function setissuanceratio(uint _issuanceratio)
        external
        onlyowner
    {
        require(_issuanceratio <= max_issuance_ratio, );
        issuanceratio = _issuanceratio;
        emit issuanceratioupdated(_issuanceratio);
    }

    
    function importissuerdata(address[] accounts, uint[] susdamounts)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == susdamounts.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            _addtodebtregister(accounts[i], susdamounts[i]);
        }
    }

    
    function _addtodebtregister(address account, uint amount)
        internal
    {
        
        
        synthetix synthetix = synthetix(associatedcontract);

        
        uint xdrvalue = synthetix.effectivevalue(, amount, );

        
        uint totaldebtissued = importedxdramount;

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        importedxdramount = newtotaldebtissued;

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        uint existingdebt = synthetix.debtbalanceof(account, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (issuancedata[account].initialdebtownership == 0) {
            totalissuercount = totalissuercount.add(1);
        }

        
        issuancedata[account].initialdebtownership = debtpercentage;
        issuancedata[account].debtentryindex = debtledger.length;

        
        
        if (debtledger.length > 0) {
            debtledger.push(
                debtledger[debtledger.length  1].multiplydecimalroundprecise(delta)
            );
        } else {
            debtledger.push(safedecimalmath.preciseunit());
        }
    }

    

    
    function debtledgerlength()
        external
        view
        returns (uint)
    {
        return debtledger.length;
    }

    
    function lastdebtledgerentry()
        external
        view
        returns (uint)
    {
        return debtledger[debtledger.length  1];
    }

    
    function hasissued(address account)
        external
        view
        returns (bool)
    {
        return issuancedata[account].initialdebtownership > 0;
    }

    event issuanceratioupdated(uint newratio);
}


pragma solidity 0.4.25;


import ;



contract selfdestructible is owned {
    
    uint public initiationtime;
    bool public selfdestructinitiated;
    address public selfdestructbeneficiary;
    uint public constant selfdestruct_delay = 4 weeks;

    
    constructor(address _owner)
        owned(_owner)
        public
    {
        require(_owner != address(0), );
        selfdestructbeneficiary = _owner;
        emit selfdestructbeneficiaryupdated(_owner);
    }

    
    function setselfdestructbeneficiary(address _beneficiary)
        external
        onlyowner
    {
        require(_beneficiary != address(0), );
        selfdestructbeneficiary = _beneficiary;
        emit selfdestructbeneficiaryupdated(_beneficiary);
    }

    
    function initiateselfdestruct()
        external
        onlyowner
    {
        initiationtime = now;
        selfdestructinitiated = true;
        emit selfdestructinitiated(selfdestruct_delay);
    }

    
    function terminateselfdestruct()
        external
        onlyowner
    {
        initiationtime = 0;
        selfdestructinitiated = false;
        emit selfdestructterminated();
    }

    
    function selfdestruct()
        external
        onlyowner
    {
        require(selfdestructinitiated, );
        require(initiationtime + selfdestruct_delay < now, );
        address beneficiary = selfdestructbeneficiary;
        emit selfdestructed(beneficiary);
        selfdestruct(beneficiary);
    }

    event selfdestructterminated();
    event selfdestructed(address beneficiary);
    event selfdestructinitiated(uint selfdestructdelay);
    event selfdestructbeneficiaryupdated(address newbeneficiary);
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract feepoolstate is selfdestructible, limitedsetup {
    using safemath for uint;
    using safedecimalmath for uint;

    

    uint8 constant public fee_period_length = 6;

    address public feepool;

    
    struct issuancedata {
        uint debtpercentage;
        uint debtentryindex;
    }

    
    mapping(address => issuancedata[fee_period_length]) public accountissuanceledger;

    
    constructor(address _owner, ifeepool _feepool)
        selfdestructible(_owner)
        limitedsetup(6 weeks)
        public
    {
        feepool = _feepool;
    }

    

    
    function setfeepool(ifeepool _feepool)
        external
        onlyowner
    {
        feepool = _feepool;
    }

    

    
    function getaccountsdebtentry(address account, uint index)
        public
        view
        returns (uint debtpercentage, uint debtentryindex)
    {
        require(index < fee_period_length, );

        debtpercentage = accountissuanceledger[account][index].debtpercentage;
        debtentryindex = accountissuanceledger[account][index].debtentryindex;
    }

    
    function applicableissuancedata(address account, uint closingdebtindex)
        external
        view
        returns (uint, uint)
    {
        issuancedata[fee_period_length] memory issuancedata = accountissuanceledger[account];
        
        
        
        for (uint i = 0; i < fee_period_length; i++) {
            if (closingdebtindex >= issuancedata[i].debtentryindex) {
                return (issuancedata[i].debtpercentage, issuancedata[i].debtentryindex);
            }
        }
    }

    

    
    function appendaccountissuancerecord(address account, uint debtratio, uint debtentryindex, uint currentperiodstartdebtindex)
        external
        onlyfeepool
    {
        
        if (accountissuanceledger[account][0].debtentryindex < currentperiodstartdebtindex) {
             
            issuancedataindexorder(account);
        }
        
        
        accountissuanceledger[account][0].debtpercentage = debtratio;
        accountissuanceledger[account][0].debtentryindex = debtentryindex;
    }

    
    function issuancedataindexorder(address account)
        private
    {
        for (uint i = fee_period_length  2; i < fee_period_length; i) {
            uint next = i + 1;
            accountissuanceledger[account][next].debtpercentage = accountissuanceledger[account][i].debtpercentage;
            accountissuanceledger[account][next].debtentryindex = accountissuanceledger[account][i].debtentryindex;
        }
    }

    
    function importissuerdata(address[] accounts, uint[] ratios, uint periodtoinsert, uint feeperiodcloseindex)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == ratios.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            accountissuanceledger[accounts[i]][periodtoinsert].debtpercentage = ratios[i];
            accountissuanceledger[accounts[i]][periodtoinsert].debtentryindex = feeperiodcloseindex;
            emit issuancedebtratioentry(accounts[i], ratios[i], feeperiodcloseindex);
        }
    }

    

    modifier onlyfeepool
    {
        require(msg.sender == address(feepool), );
        _;
    }

    
    event issuancedebtratioentry(address indexed account, uint debtratio, uint feeperiodcloseindex);
}



pragma solidity 0.4.25;

import ;
import ;
import ;


contract supplyschedule is owned {
    using safemath for uint;
    using safedecimalmath for uint;

    
    struct scheduledata {
        
        uint totalsupply;

        
        uint startperiod;

        
        uint endperiod;

        
        uint totalsupplyminted;
    }

    
    uint public mintperiodduration = 1 weeks;

    
    uint public lastmintevent;

    synthetix public synthetix;

    uint constant seconds_in_year = 60 * 60 * 24 * 365;

    uint public constant start_date = 1520294400; 
    uint public constant year_one = start_date + seconds_in_year.mul(1);
    uint public constant year_two = start_date + seconds_in_year.mul(2);
    uint public constant year_three = start_date + seconds_in_year.mul(3);
    uint public constant year_four = start_date + seconds_in_year.mul(4);
    uint public constant year_five = start_date + seconds_in_year.mul(5);
    uint public constant year_six = start_date + seconds_in_year.mul(6);
    uint public constant year_seven = start_date + seconds_in_year.mul(7);

    uint8 constant public inflation_schedules_length = 7;
    scheduledata[inflation_schedules_length] public schedules;

    uint public minterreward = 200 * safedecimalmath.unit();

    constructor(address _owner)
        owned(_owner)
        public
    {
        
        
        schedules[0] = scheduledata(1e8 * safedecimalmath.unit(), start_date, year_one  1, 1e8 * safedecimalmath.unit());
        schedules[1] = scheduledata(75e6 * safedecimalmath.unit(), year_one, year_two  1, 0); 
        schedules[2] = scheduledata(37.5e6 * safedecimalmath.unit(), year_two, year_three  1, 0); 
        schedules[3] = scheduledata(18.75e6 * safedecimalmath.unit(), year_three, year_four  1, 0); 
        schedules[4] = scheduledata(9.375e6 * safedecimalmath.unit(), year_four, year_five  1, 0); 
        schedules[5] = scheduledata(4.6875e6 * safedecimalmath.unit(), year_five, year_six  1, 0); 
        schedules[6] = scheduledata(0, year_six, year_seven  1, 0); 
    }

    
    function setsynthetix(synthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        
    }

    
    function mintablesupply()
        public
        view
        returns (uint)
    {
        if (!ismintable()) {
            return 0;
        }

        uint index = getcurrentschedule();

        
        uint amountpreviousperiod = _remainingsupplyfrompreviousyear(index);

        

        
        
        
        scheduledata memory schedule = schedules[index];

        uint weeksinperiod = (schedule.endperiod  schedule.startperiod).div(mintperiodduration);

        uint supplyperweek = schedule.totalsupply.dividedecimal(weeksinperiod);

        uint weekstomint = lastmintevent >= schedule.startperiod ? _numweeksroundeddown(now.sub(lastmintevent)) : _numweeksroundeddown(now.sub(schedule.startperiod));
        

        uint amountinperiod = supplyperweek.multiplydecimal(weekstomint);
        return amountinperiod.add(amountpreviousperiod);
    }

    function _numweeksroundeddown(uint _timediff)
        public
        view
        returns (uint)
    {
        
        
        
        return _timediff.div(mintperiodduration);
    }

    function ismintable()
        public
        view
        returns (bool)
    {
        bool mintable = false;
        if (now  lastmintevent > mintperiodduration && now <= schedules[6].endperiod) 
        {
            mintable = true;
        }
        return mintable;
    }

    
    
    function getcurrentschedule()
        public
        view
        returns (uint)
    {
        require(now <= schedules[6].endperiod, );

        for (uint i = 0; i < inflation_schedules_length; i++) {
            if (schedules[i].startperiod <= now && schedules[i].endperiod >= now) {
                return i;
            }
        }
    }

    function _remainingsupplyfrompreviousyear(uint currentschedule)
        internal
        view
        returns (uint)
    {
        
        
        if (currentschedule == 0 || lastmintevent > schedules[currentschedule  1].endperiod) {
            return 0;
        }

        
        uint amountinperiod = schedules[currentschedule  1].totalsupply.sub(schedules[currentschedule  1].totalsupplyminted);

        
        if (amountinperiod < 0) {
            return 0;
        }

        return amountinperiod;
    }

    
    function updatemintvalues()
        external
        onlysynthetix
        returns (bool)
    {
        
        uint currentindex = getcurrentschedule();
        uint lastperiodamount = _remainingsupplyfrompreviousyear(currentindex);
        uint currentperiodamount = mintablesupply().sub(lastperiodamount);

        
        if (lastperiodamount > 0) {
            schedules[currentindex  1].totalsupplyminted = schedules[currentindex  1].totalsupplyminted.add(lastperiodamount);
        }

        
        schedules[currentindex].totalsupplyminted = schedules[currentindex].totalsupplyminted.add(currentperiodamount);
        
        lastmintevent = now;

        emit supplyminted(lastperiodamount, currentperiodamount, currentindex, now);
        return true;
    }

    function setminterreward(uint _amount)
        external
        onlyowner
    {
        minterreward = _amount;
        emit minterrewardupdated(_amount);
    }

    

    modifier onlysynthetix() {
        require(msg.sender == address(synthetix), );
        _;
    }

    

    event supplyminted(uint previousperiodamount, uint currentamount, uint indexed schedule, uint timestamp);
    event minterrewardupdated(uint newrewardamount);
}

pragma solidity 0.4.25;

contract migrations {
    address public owner;
    uint public last_completed_migration;

    constructor() public {
        owner = msg.sender;
    }

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function setcompleted(uint completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        migrations upgraded = migrations(new_address);
        upgraded.setcompleted(last_completed_migration);
    }
}

pragma solidity 0.4.25;

contract synthetixescrow {
    function numvestingentries(address account) public returns (uint);
    function getvestingscheduleentry(address account, uint index) public returns (uint[2]);
}

contract escrowchecker {
    synthetixescrow public synthetix_escrow;
    constructor(synthetixescrow _esc) public {
        synthetix_escrow = _esc;
    }

    function checkaccountschedule(address account)
        public
        view
        returns (uint[16])
    {
        uint[16] memory _result;
        uint schedules = synthetix_escrow.numvestingentries(account);
        for (uint i = 0; i < schedules; i++) {
            uint[2] memory pair = synthetix_escrow.getvestingscheduleentry(account, i);
            _result[i*2] = pair[0];
            _result[i*2 + 1] = pair[1];
        }
        return _result;
    }
}



pragma solidity 0.4.25;


import ;



contract pausable is owned {
    
    uint public lastpausetime;
    bool public paused;

    
    constructor(address _owner)
        owned(_owner)
        public
    {
        
    }

    
    function setpaused(bool _paused)
        external
        onlyowner
    {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;
        
        
        if (paused) {
            lastpausetime = now;
        }

        
        emit pausechanged(paused);
    }

    event pausechanged(bool ispaused);

    modifier notpaused {
        require(!paused, );
        _;
    }
}



pragma solidity 0.4.25;

import ;


library safedecimalmath {

    using safemath for uint;

    
    uint8 public constant decimals = 18;
    uint8 public constant highprecisiondecimals = 27;

    
    uint public constant unit = 10 ** uint(decimals);

    
    uint public constant precise_unit = 10 ** uint(highprecisiondecimals);
    uint private constant unit_to_high_precision_conversion_factor = 10 ** uint(highprecisiondecimals  decimals);

    
    function unit()
        external
        pure
        returns (uint)
    {
        return unit;
    }

    
    function preciseunit()
        external
        pure 
        returns (uint)
    {
        return precise_unit;
    }

    
    function multiplydecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        
        return x.mul(y) / unit;
    }

    
    function _multiplydecimalround(uint x, uint y, uint precisionunit)
        private
        pure
        returns (uint)
    {
        
        uint quotienttimesten = x.mul(y) / (precisionunit / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

    
    function multiplydecimalroundprecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplydecimalround(x, y, precise_unit);
    }

    
    function multiplydecimalround(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _multiplydecimalround(x, y, unit);
    }

    
    function dividedecimal(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        
        return x.mul(unit).div(y);
    }

    
    function _dividedecimalround(uint x, uint y, uint precisionunit)
        private
        pure
        returns (uint)
    {
        uint resulttimesten = x.mul(precisionunit * 10).div(y);

        if (resulttimesten % 10 >= 5) {
            resulttimesten += 10;
        }

        return resulttimesten / 10;
    }

    
    function dividedecimalround(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _dividedecimalround(x, y, unit);
    }

    
    function dividedecimalroundprecise(uint x, uint y)
        internal
        pure
        returns (uint)
    {
        return _dividedecimalround(x, y, precise_unit);
    }

    
    function decimaltoprecisedecimal(uint i)
        internal
        pure
        returns (uint)
    {
        return i.mul(unit_to_high_precision_conversion_factor);
    }

    
    function precisedecimaltodecimal(uint i)
        internal
        pure
        returns (uint)
    {
        uint quotienttimesten = i / (unit_to_high_precision_conversion_factor / 10);

        if (quotienttimesten % 10 >= 5) {
            quotienttimesten += 10;
        }

        return quotienttimesten / 10;
    }

}




pragma solidity 0.4.25;


import ;
import ;


contract proxy is owned {

    proxyable public target;
    bool public usedelegatecall;

    constructor(address _owner)
        owned(_owner)
        public
    {}

    function settarget(proxyable _target)
        external
        onlyowner
    {
        target = _target;
        emit targetupdated(_target);
    }

    function setusedelegatecall(bool value) 
        external
        onlyowner
    {
        usedelegatecall = value;
    }

    function _emit(bytes calldata, uint numtopics, bytes32 topic1, bytes32 topic2, bytes32 topic3, bytes32 topic4)
        external
        onlytarget
    {
        uint size = calldata.length;
        bytes memory _calldata = calldata;

        assembly {
            
            switch numtopics
            case 0 {
                log0(add(_calldata, 32), size)
            } 
            case 1 {
                log1(add(_calldata, 32), size, topic1)
            }
            case 2 {
                log2(add(_calldata, 32), size, topic1, topic2)
            }
            case 3 {
                log3(add(_calldata, 32), size, topic1, topic2, topic3)
            }
            case 4 {
                log4(add(_calldata, 32), size, topic1, topic2, topic3, topic4)
            }
        }
    }

    function()
        external
        payable
    {
        if (usedelegatecall) {
            assembly {
                
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := delegatecall(gas, sload(target_slot), free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                
                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        } else {
            
            target.setmessagesender(msg.sender);
            assembly {
                let free_ptr := mload(0x40)
                calldatacopy(free_ptr, 0, calldatasize)

                
                let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)
                returndatacopy(free_ptr, 0, returndatasize)

                if iszero(result) { revert(free_ptr, returndatasize) }
                return(free_ptr, returndatasize)
            }
        }
    }

    modifier onlytarget {
        require(proxyable(msg.sender) == target, );
        _;
    }

    event targetupdated(proxyable newtarget);
}




pragma solidity 0.4.25;


contract limitedsetup {

    uint setupexpirytime;

    
    constructor(uint setupduration)
        public
    {
        setupexpirytime = now + setupduration;
    }

    modifier onlyduringsetup
    {
        require(now < setupexpirytime, );
        _;
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;



contract exchangerates is selfdestructible {


    using safemath for uint;
    using safedecimalmath for uint;

    
    mapping(bytes4 => uint) public rates;

    
    mapping(bytes4 => uint) public lastrateupdatetimes;

    
    address public oracle;

    
    uint constant oracle_future_limit = 10 minutes;

    
    uint public ratestaleperiod = 3 hours;

    
    bool public priceupdatelock = false;

    
    
    
    bytes4[5] public xdrparticipants;

    
    struct inversepricing {
        uint entrypoint;
        uint upperlimit;
        uint lowerlimit;
        bool frozen;
    }
    mapping(bytes4 => inversepricing) public inversepricing;
    bytes4[] public invertedkeys;

    

    
    constructor(
        
        address _owner,

        
        address _oracle,
        bytes4[] _currencykeys,
        uint[] _newrates
    )
        
        selfdestructible(_owner)
        public
    {
        require(_currencykeys.length == _newrates.length, );

        oracle = _oracle;

        
        rates[] = safedecimalmath.unit();
        lastrateupdatetimes[] = now;

        
        
        
        
        
        
        
        xdrparticipants = [
            bytes4(),
            bytes4(),
            bytes4(),
            bytes4(),
            bytes4()
        ];

        internalupdaterates(_currencykeys, _newrates, now);
    }

    

    
    function updaterates(bytes4[] currencykeys, uint[] newrates, uint timesent)
        external
        onlyoracle
        returns(bool)
    {
        return internalupdaterates(currencykeys, newrates, timesent);
    }

    
    function internalupdaterates(bytes4[] currencykeys, uint[] newrates, uint timesent)
        internal
        returns(bool)
    {
        require(currencykeys.length == newrates.length, );
        require(timesent < (now + oracle_future_limit), );

        
        for (uint i = 0; i < currencykeys.length; i++) {
            
            
            
            require(newrates[i] != 0, );
            require(currencykeys[i] != , );

            
            if (timesent < lastrateupdatetimes[currencykeys[i]]) {
                continue;
            }

            newrates[i] = rateorinverted(currencykeys[i], newrates[i]);

            
            rates[currencykeys[i]] = newrates[i];
            lastrateupdatetimes[currencykeys[i]] = timesent;
        }

        emit ratesupdated(currencykeys, newrates);

        
        updatexdrrate(timesent);

        
        if (priceupdatelock) {
            priceupdatelock = false;
        }

        return true;
    }

    
    function rateorinverted(bytes4 currencykey, uint rate) internal returns (uint) {
        
        inversepricing storage inverse = inversepricing[currencykey];
        if (inverse.entrypoint <= 0) {
            return rate;
        }

        
        uint newinverserate = rates[currencykey];

        
        if (!inverse.frozen) {
            uint doubleentrypoint = inverse.entrypoint.mul(2);
            if (doubleentrypoint <= rate) {
                
                
                
                newinverserate = 0;
            } else {
                newinverserate = doubleentrypoint.sub(rate);
            }

            
            if (newinverserate >= inverse.upperlimit) {
                newinverserate = inverse.upperlimit;
            } else if (newinverserate <= inverse.lowerlimit) {
                newinverserate = inverse.lowerlimit;
            }

            if (newinverserate == inverse.upperlimit || newinverserate == inverse.lowerlimit) {
                inverse.frozen = true;
                emit inversepricefrozen(currencykey);
            }
        }

        return newinverserate;
    }

    
    function updatexdrrate(uint timesent)
        internal
    {
        uint total = 0;

        for (uint i = 0; i < xdrparticipants.length; i++) {
            total = rates[xdrparticipants[i]].add(total);
        }

        
        rates[] = total;

        
        lastrateupdatetimes[] = timesent;

        
        
        bytes4[] memory eventcurrencycode = new bytes4[](1);
        eventcurrencycode[0] = ;

        uint[] memory eventrate = new uint[](1);
        eventrate[0] = rates[];

        emit ratesupdated(eventcurrencycode, eventrate);
    }

    
    function deleterate(bytes4 currencykey)
        external
        onlyoracle
    {
        require(rates[currencykey] > 0, );

        delete rates[currencykey];
        delete lastrateupdatetimes[currencykey];

        emit ratedeleted(currencykey);
    }

    
    function setoracle(address _oracle)
        external
        onlyowner
    {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    
    function setratestaleperiod(uint _time)
        external
        onlyowner
    {
        ratestaleperiod = _time;
        emit ratestaleperiodupdated(ratestaleperiod);
    }

    
    function setpriceupdatelock(bool _priceupdatelock)
        external
        onlyoracle
    {
        priceupdatelock = _priceupdatelock;
    }

    
    function setinversepricing(bytes4 currencykey, uint entrypoint, uint upperlimit, uint lowerlimit)
        external onlyowner
    {
        require(entrypoint > 0, );
        require(lowerlimit > 0, );
        require(upperlimit > entrypoint, );
        require(upperlimit < entrypoint.mul(2), );
        require(lowerlimit < entrypoint, );

        if (inversepricing[currencykey].entrypoint <= 0) {
            
            invertedkeys.push(currencykey);
        }
        inversepricing[currencykey].entrypoint = entrypoint;
        inversepricing[currencykey].upperlimit = upperlimit;
        inversepricing[currencykey].lowerlimit = lowerlimit;
        inversepricing[currencykey].frozen = false;

        emit inversepriceconfigured(currencykey, entrypoint, upperlimit, lowerlimit);
    }

    
    function removeinversepricing(bytes4 currencykey) external onlyowner {
        inversepricing[currencykey].entrypoint = 0;
        inversepricing[currencykey].upperlimit = 0;
        inversepricing[currencykey].lowerlimit = 0;
        inversepricing[currencykey].frozen = false;

        
        for (uint8 i = 0; i < invertedkeys.length; i++) {
            if (invertedkeys[i] == currencykey) {
                delete invertedkeys[i];

                
                
                
                invertedkeys[i] = invertedkeys[invertedkeys.length  1];

                
                invertedkeys.length;

                break;
            }
        }

        emit inversepriceconfigured(currencykey, 0, 0, 0);
    }
    

    
    function effectivevalue(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey)
        public
        view
        ratenotstale(sourcecurrencykey)
        ratenotstale(destinationcurrencykey)
        returns (uint)
    {
        
        if (sourcecurrencykey == destinationcurrencykey) return sourceamount;

        
        return sourceamount.multiplydecimalround(rateforcurrency(sourcecurrencykey))
            .dividedecimalround(rateforcurrency(destinationcurrencykey));
    }

    
    function rateforcurrency(bytes4 currencykey)
        public
        view
        returns (uint)
    {
        return rates[currencykey];
    }

    
    function ratesforcurrencies(bytes4[] currencykeys)
        public
        view
        returns (uint[])
    {
        uint[] memory _rates = new uint[](currencykeys.length);

        for (uint8 i = 0; i < currencykeys.length; i++) {
            _rates[i] = rates[currencykeys[i]];
        }

        return _rates;
    }

    
    function lastrateupdatetimeforcurrency(bytes4 currencykey)
        public
        view
        returns (uint)
    {
        return lastrateupdatetimes[currencykey];
    }

    
    function lastrateupdatetimesforcurrencies(bytes4[] currencykeys)
        public
        view
        returns (uint[])
    {
        uint[] memory lastupdatetimes = new uint[](currencykeys.length);

        for (uint8 i = 0; i < currencykeys.length; i++) {
            lastupdatetimes[i] = lastrateupdatetimes[currencykeys[i]];
        }

        return lastupdatetimes;
    }

    
    function rateisstale(bytes4 currencykey)
        public
        view
        returns (bool)
    {
        
        if (currencykey == ) return false;

        return lastrateupdatetimes[currencykey].add(ratestaleperiod) < now;
    }

    
    function rateisfrozen(bytes4 currencykey)
        external
        view
        returns (bool)
    {
        return inversepricing[currencykey].frozen;
    }


    
    function anyrateisstale(bytes4[] currencykeys)
        external
        view
        returns (bool)
    {
        
        uint256 i = 0;

        while (i < currencykeys.length) {
            
            if (currencykeys[i] !=  && lastrateupdatetimes[currencykeys[i]].add(ratestaleperiod) < now) {
                return true;
            }
            i += 1;
        }

        return false;
    }

    

    modifier ratenotstale(bytes4 currencykey) {
        require(!rateisstale(currencykey), );
        _;
    }

    modifier onlyoracle
    {
        require(msg.sender == oracle, );
        _;
    }

    

    event oracleupdated(address neworacle);
    event ratestaleperiodupdated(uint ratestaleperiod);
    event ratesupdated(bytes4[] currencykeys, uint[] newrates);
    event ratedeleted(bytes4 currencykey);
    event inversepriceconfigured(bytes4 currencykey, uint entrypoint, uint upperlimit, uint lowerlimit);
    event inversepricefrozen(bytes4 currencykey);
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract proxyerc20 is proxy, ierc20 {

    constructor(address _owner)
        proxy(_owner)
        public
    {}

    

    function name() public view returns (string){
        
        return ierc20(target).name();
    }

    function symbol() public view returns (string){
         
        return ierc20(target).symbol();
    }

    function decimals() public view returns (uint8){
         
        return ierc20(target).decimals();
    }

    

    
    function totalsupply() public view returns (uint256) {
        
        return ierc20(target).totalsupply();
    }

    
    function balanceof(address owner) public view returns (uint256) {
        
        return ierc20(target).balanceof(owner);
    }

    
    function allowance(
        address owner,
        address spender
    )
        public
        view
        returns (uint256)
    {
        
        return ierc20(target).allowance(owner, spender);
    }

    
    function transfer(address to, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).transfer(to, value);

        
        return true;
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).approve(spender, value);

        
        return true;
    }

    
    function transferfrom(
        address from,
        address to,
        uint256 value
    )
        public
        returns (bool)
    {
        
        target.setmessagesender(msg.sender);

        
        ierc20(target).transferfrom(from, to, value);

        
        return true;
    }
}




pragma solidity 0.4.25;

import ;
import ;


contract proxyable is owned {
    
    proxy public proxy;
    proxy public integrationproxy;

    
    address messagesender;

    constructor(address _proxy, address _owner)
        owned(_owner)
        public
    {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setproxy(address _proxy)
        external
        onlyowner
    {
        proxy = proxy(_proxy);
        emit proxyupdated(_proxy);
    }

    function setintegrationproxy(address _integrationproxy)
        external
        onlyowner
    {
        integrationproxy = proxy(_integrationproxy);
    }

    function setmessagesender(address sender)
        external
        onlyproxy
    {
        messagesender = sender;
    }

    modifier onlyproxy {
        require(proxy(msg.sender) == proxy || proxy(msg.sender) == integrationproxy, );
        _;
    }

    modifier optionalproxy
    {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy) {
            messagesender = msg.sender;
        }
        _;
    }

    modifier optionalproxy_onlyowner
    {
        if (proxy(msg.sender) != proxy && proxy(msg.sender) != integrationproxy) {
            messagesender = msg.sender;
        }
        require(messagesender == owner, );
        _;
    }

    event proxyupdated(address proxyaddress);
}



pragma solidity 0.4.25;


import ;


contract tokenstate is state {

    
    mapping(address => uint) public balanceof;
    mapping(address => mapping(address => uint)) public allowance;

    
    constructor(address _owner, address _associatedcontract)
        state(_owner, _associatedcontract)
        public
    {}

    

    
    function setallowance(address tokenowner, address spender, uint value)
        external
        onlyassociatedcontract
    {
        allowance[tokenowner][spender] = value;
    }

    
    function setbalanceof(address account, uint value)
        external
        onlyassociatedcontract
    {
        balanceof[account] = value;
    }
}



pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;

contract feepool is proxyable, selfdestructible, limitedsetup {

    using safemath for uint;
    using safedecimalmath for uint;

    synthetix public synthetix;
    isynthetixstate public synthetixstate;
    isynthetixescrow public rewardescrow;
    feepooleternalstorage public feepooleternalstorage;

    
    uint public transferfeerate;

    
    uint constant public max_transfer_fee_rate = safedecimalmath.unit() / 10;

    
    uint public exchangefeerate;

    
    uint constant public max_exchange_fee_rate = safedecimalmath.unit() / 10;

    
    address public rewardsauthority;

    
    feepoolstate public feepoolstate;

    
    delegateapprovals public delegates;

    
    address public constant fee_address = 0xfeefeefeefeefeefeefeefeefeefeefeefeefeef;

    
    struct feeperiod {
        uint feeperiodid;
        uint startingdebtindex;
        uint starttime;
        uint feestodistribute;
        uint feesclaimed;
        uint rewardstodistribute;
        uint rewardsclaimed;
    }

    
    
    
    
    
    
    uint8 constant public fee_period_length = 3;

    feeperiod[fee_period_length] public recentfeeperiods;

    
    
    
    
    uint public feeperiodduration = 1 weeks;
    
    uint public constant min_fee_period_duration = 1 days;
    uint public constant max_fee_period_duration = 60 days;

    
    uint public target_threshold = (10 * safedecimalmath.unit()) / 100;

    

    bytes32 constant last_fee_withdrawal = ;

    constructor(
        address _proxy,
        address _owner,
        synthetix _synthetix,
        feepoolstate _feepoolstate,
        feepooleternalstorage _feepooleternalstorage,
        isynthetixstate _synthetixstate,
        isynthetixescrow _rewardescrow,
        address _rewardsauthority,
        uint _transferfeerate,
        uint _exchangefeerate)
        selfdestructible(_owner)
        proxyable(_proxy, _owner)
        limitedsetup(3 weeks)
        public
    {
        
        require(_transferfeerate <= max_transfer_fee_rate, );
        require(_exchangefeerate <= max_exchange_fee_rate, );

        synthetix = _synthetix;
        feepoolstate = _feepoolstate;
        feepooleternalstorage = _feepooleternalstorage;
        rewardescrow = _rewardescrow;
        synthetixstate = _synthetixstate;
        rewardsauthority = _rewardsauthority;
        transferfeerate = _transferfeerate;
        exchangefeerate = _exchangefeerate;

        
        recentfeeperiods[0].feeperiodid = 1;
        recentfeeperiods[0].starttime = now;
    }

    
    function appendaccountissuancerecord(address account, uint debtratio, uint debtentryindex)
        external
        onlysynthetix
    {
        feepoolstate.appendaccountissuancerecord(account, debtratio, debtentryindex, recentfeeperiods[0].startingdebtindex);

        emitissuancedebtratioentry(account, debtratio, debtentryindex, recentfeeperiods[0].startingdebtindex);
    }

    
    function setexchangefeerate(uint _exchangefeerate)
        external
        optionalproxy_onlyowner
    {
        exchangefeerate = _exchangefeerate;
    }

    
    function settransferfeerate(uint _transferfeerate)
        external
        optionalproxy_onlyowner
    {
        require(_transferfeerate <= max_transfer_fee_rate, );

        transferfeerate = _transferfeerate;
    }

    
    function setrewardsauthority(address _rewardsauthority)
        external
        optionalproxy_onlyowner
    {
        rewardsauthority = _rewardsauthority;
    }

    
    function setfeepoolstate(feepoolstate _feepoolstate)
        external
        optionalproxy_onlyowner
    {
        feepoolstate = _feepoolstate;
    }

    
    function setdelegateapprovals(delegateapprovals _delegates)
        external
        optionalproxy_onlyowner
    {
        delegates = _delegates;
    }

    
    function setfeeperiodduration(uint _feeperiodduration)
        external
        optionalproxy_onlyowner
    {
        require(_feeperiodduration >= min_fee_period_duration, );
        require(_feeperiodduration <= max_fee_period_duration, );

        feeperiodduration = _feeperiodduration;

        emitfeeperioddurationupdated(_feeperiodduration);
    }

    
    function setsynthetix(synthetix _synthetix)
        external
        optionalproxy_onlyowner
    {
        require(address(_synthetix) != address(0), );

        synthetix = _synthetix;
    }

    function settargetthreshold(uint _percent)
        external
        optionalproxy_onlyowner
    {
        require(_percent >= 0, );
        target_threshold = (_percent * safedecimalmath.unit()) / 100;
    }

    
    function feepaid(bytes4 currencykey, uint amount)
        external
        onlysynthetix
    {
        uint xdramount;

        if (currencykey != ) {
            xdramount = synthetix.effectivevalue(currencykey, amount, );
        } else {
            xdramount = amount;
        }

        
        recentfeeperiods[0].feestodistribute = recentfeeperiods[0].feestodistribute.add(xdramount);
    }

    
    function setrewardstodistribute(uint amount)
        external
    {
        require(messagesender == rewardsauthority || msg.sender == rewardsauthority, );
        
        recentfeeperiods[0].rewardstodistribute = recentfeeperiods[0].rewardstodistribute.add(amount);
    }

    
    function closecurrentfeeperiod()
        external
    {
        require(recentfeeperiods[0].starttime <= (now  feeperiodduration), );

        feeperiod memory secondlastfeeperiod = recentfeeperiods[fee_period_length  2];
        feeperiod memory lastfeeperiod = recentfeeperiods[fee_period_length  1];

        
        
        
        
        
        recentfeeperiods[fee_period_length  2].feestodistribute = lastfeeperiod.feestodistribute
            .sub(lastfeeperiod.feesclaimed)
            .add(secondlastfeeperiod.feestodistribute);
        recentfeeperiods[fee_period_length  2].rewardstodistribute = lastfeeperiod.rewardstodistribute
            .sub(lastfeeperiod.rewardsclaimed)
            .add(secondlastfeeperiod.rewardstodistribute);

        
        
        
        
        
        for (uint i = fee_period_length  2; i < fee_period_length; i) {
            uint next = i + 1;
            recentfeeperiods[next].feeperiodid = recentfeeperiods[i].feeperiodid;
            recentfeeperiods[next].startingdebtindex = recentfeeperiods[i].startingdebtindex;
            recentfeeperiods[next].starttime = recentfeeperiods[i].starttime;
            recentfeeperiods[next].feestodistribute = recentfeeperiods[i].feestodistribute;
            recentfeeperiods[next].feesclaimed = recentfeeperiods[i].feesclaimed;
            recentfeeperiods[next].rewardstodistribute = recentfeeperiods[i].rewardstodistribute;
            recentfeeperiods[next].rewardsclaimed = recentfeeperiods[i].rewardsclaimed;
        }

        
        delete recentfeeperiods[0];

        
        
        recentfeeperiods[0].feeperiodid = recentfeeperiods[1].feeperiodid.add(1);
        recentfeeperiods[0].startingdebtindex = synthetixstate.debtledgerlength();
        recentfeeperiods[0].starttime = now;

        emitfeeperiodclosed(recentfeeperiods[1].feeperiodid);
    }

    
    function claimfees(bytes4 currencykey)
        external
        optionalproxy
        returns (bool)
    {
        return _claimfees(messagesender, currencykey);
    }

    function claimonbehalf(address claimingforaddress, bytes4 currencykey)
        external
        optionalproxy
        returns (bool)
    {
        require(delegates.approval(claimingforaddress, messagesender), );

        return _claimfees(claimingforaddress, currencykey);
    }

    function _claimfees(address claimingaddress, bytes4 currencykey)
        internal
        returns (bool)
    {
        uint rewardspaid;
        uint feespaid;
        uint availablefees;
        uint availablerewards;

        
        
        require(feesclaimable(claimingaddress), );

        
        (availablefees, availablerewards) = feesavailable(claimingaddress, );

        require(availablefees > 0 || availablerewards > 0, );

        
        _setlastfeewithdrawal(claimingaddress, recentfeeperiods[1].feeperiodid);

        if (availablefees > 0) {
            
            feespaid = _recordfeepayment(availablefees);

            
            _payfees(claimingaddress, feespaid, currencykey);
        }

        if (availablerewards > 0) {
            
            rewardspaid = _recordrewardpayment(availablerewards);

            
            _payrewards(claimingaddress, rewardspaid);
        }

        emitfeesclaimed(claimingaddress, feespaid, rewardspaid);

        return true;
    }

    function importfeeperiod(
        uint feeperiodindex, uint feeperiodid, uint startingdebtindex, uint starttime,
        uint feestodistribute, uint feesclaimed, uint rewardstodistribute, uint rewardsclaimed)
        public
        optionalproxy_onlyowner
        onlyduringsetup
    {
        recentfeeperiods[feeperiodindex].feeperiodid = feeperiodid;
        recentfeeperiods[feeperiodindex].startingdebtindex = startingdebtindex;
        recentfeeperiods[feeperiodindex].starttime = starttime;
        recentfeeperiods[feeperiodindex].feestodistribute = feestodistribute;
        recentfeeperiods[feeperiodindex].feesclaimed = feesclaimed;
        recentfeeperiods[feeperiodindex].rewardstodistribute = rewardstodistribute;
        recentfeeperiods[feeperiodindex].rewardsclaimed = rewardsclaimed;
    }

    
    function appendvestingentry(address account, uint quantity)
        public
        optionalproxy_onlyowner
    {
        
        synthetix.transferfrom(messagesender, rewardescrow, quantity);

        
        rewardescrow.appendvestingentry(account, quantity);
    }

    function approveclaimonbehalf(address account)
        public
        optionalproxy
    {
        require(delegates != address(0), );
        require(account != address(0), );
        delegates.setapproval(messagesender, account);
    }

    function removeclaimonbehalf(address account)
        public
        optionalproxy
    {
        require(delegates != address(0), );
        delegates.withdrawapproval(messagesender, account);
    }

    
    function _recordfeepayment(uint xdramount)
        internal
        returns (uint)
    {
        
        uint remainingtoallocate = xdramount;

        uint feespaid;
        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint delta = recentfeeperiods[i].feestodistribute.sub(recentfeeperiods[i].feesclaimed);

            if (delta > 0) {
                
                uint amountinperiod = delta < remainingtoallocate ? delta : remainingtoallocate;

                recentfeeperiods[i].feesclaimed = recentfeeperiods[i].feesclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);
                feespaid = feespaid.add(amountinperiod);

                
                if (remainingtoallocate == 0) return feespaid;

                
                
                if (i == 0 && remainingtoallocate > 0) {
                    remainingtoallocate = 0;
                }
            }
        }

        return feespaid;
    }

    
    function _recordrewardpayment(uint snxamount)
        internal
        returns (uint)
    {
        
        uint remainingtoallocate = snxamount;

        uint rewardpaid;

        
        
        
        for (uint i = fee_period_length  1; i < fee_period_length; i) {
            uint todistribute = recentfeeperiods[i].rewardstodistribute.sub(recentfeeperiods[i].rewardsclaimed);

            if (todistribute > 0) {
                
                uint amountinperiod = todistribute < remainingtoallocate ? todistribute : remainingtoallocate;

                recentfeeperiods[i].rewardsclaimed = recentfeeperiods[i].rewardsclaimed.add(amountinperiod);
                remainingtoallocate = remainingtoallocate.sub(amountinperiod);
                rewardpaid = rewardpaid.add(amountinperiod);

                
                if (remainingtoallocate == 0) return rewardpaid;

                
                
                
                if (i == 0 && remainingtoallocate > 0) {
                    remainingtoallocate = 0;
                }
            }
        }
        return rewardpaid;
    }

    
    function _payfees(address account, uint xdramount, bytes4 destinationcurrencykey)
        internal
        notfeeaddress(account)
    {
        require(account != address(0), );
        require(account != address(this), );
        require(account != address(proxy), );
        require(account != address(synthetix), );

        synth xdrsynth = synthetix.synths();
        synth destinationsynth = synthetix.synths(destinationcurrencykey);

        
        

        
        xdrsynth.burn(fee_address, xdramount);

        
        uint destinationamount = synthetix.effectivevalue(, xdramount, destinationcurrencykey);

        

        
        destinationsynth.issue(account, destinationamount);

        

        
        destinationsynth.triggertokenfallbackifneeded(fee_address, account, destinationamount);
    }

    
    function _payrewards(address account, uint snxamount)
        internal
        notfeeaddress(account)
    {
        require(account != address(0), );
        require(account != address(this), );
        require(account != address(proxy), );
        require(account != address(synthetix), );

        
        
        rewardescrow.appendvestingentry(account, snxamount);
    }

    
    function transferfeeincurred(uint value)
        public
        view
        returns (uint)
    {
        return value.multiplydecimal(transferfeerate);

        
        
        
        
        
        
        
    }

    
    function transferredamounttoreceive(uint value)
        external
        view
        returns (uint)
    {
        return value.add(transferfeeincurred(value));
    }

    
    function amountreceivedfromtransfer(uint value)
        external
        view
        returns (uint)
    {
        return value.dividedecimal(transferfeerate.add(safedecimalmath.unit()));
    }

    
    function exchangefeeincurred(uint value)
        public
        view
        returns (uint)
    {
        return value.multiplydecimal(exchangefeerate);

        
        
        
        
        
        
        
    }

    
    function exchangedamounttoreceive(uint value)
        external
        view
        returns (uint)
    {
        return value.add(exchangefeeincurred(value));
    }

    
    function amountreceivedfromexchange(uint value)
        external
        view
        returns (uint)
    {
        return value.multiplydecimal(safedecimalmath.unit().sub(exchangefeerate));
    }

    
    function totalfeesavailable(bytes4 currencykey)
        external
        view
        returns (uint)
    {
        uint totalfees = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(recentfeeperiods[i].feestodistribute);
            totalfees = totalfees.sub(recentfeeperiods[i].feesclaimed);
        }

        return synthetix.effectivevalue(, totalfees, currencykey);
    }

    
    function totalrewardsavailable()
        external
        view
        returns (uint)
    {
        uint totalrewards = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalrewards = totalrewards.add(recentfeeperiods[i].rewardstodistribute);
            totalrewards = totalrewards.sub(recentfeeperiods[i].rewardsclaimed);
        }

        return totalrewards;
    }

    
    function feesavailable(address account, bytes4 currencykey)
        public
        view
        returns (uint, uint)
    {
        
        uint[2][fee_period_length] memory userfees = feesbyperiod(account);

        uint totalfees = 0;
        uint totalrewards = 0;

        
        for (uint i = 1; i < fee_period_length; i++) {
            totalfees = totalfees.add(userfees[i][0]);
            totalrewards = totalrewards.add(userfees[i][1]);
        }

        
        
        return (
            synthetix.effectivevalue(, totalfees, currencykey),
            totalrewards
        );
    }

    
    function feesclaimable(address account)
        public
        view
        returns (bool)
    {
        
        
        
        uint ratio = synthetix.collateralisationratio(account);
        uint targetratio = synthetix.synthetixstate().issuanceratio();

        
        if (ratio < targetratio) {
            return true;
        }

        
        uint ratio_threshold = targetratio.multiplydecimal(safedecimalmath.unit().add(target_threshold));

        
        if (ratio > ratio_threshold) {
            return false;
        }

        return true;
    }

    
    function feesbyperiod(address account)
        public
        view
        returns (uint[2][fee_period_length] memory results)
    {
        
        uint userownershippercentage;
        uint debtentryindex;
        (userownershippercentage, debtentryindex) = feepoolstate.getaccountsdebtentry(account, 0);

        
        if (debtentryindex == 0 && userownershippercentage == 0) return;

        
        if (synthetix.totalissuedsynths() == 0) return;

        
        
        uint feesfromperiod;
        uint rewardsfromperiod;
        (feesfromperiod, rewardsfromperiod) = _feesandrewardsfromperiod(0, userownershippercentage, debtentryindex);

        results[0][0] = feesfromperiod;
        results[0][1] = rewardsfromperiod;

        
        
        for (uint i = fee_period_length  1; i > 0; i) {
            uint next = i  1;
            feeperiod memory nextperiod = recentfeeperiods[next];

            
            if (nextperiod.startingdebtindex > 0 &&
            getlastfeewithdrawal(account) < recentfeeperiods[i].feeperiodid) {

                
                
                
                uint closingdebtindex = nextperiod.startingdebtindex.sub(1);

                
                
                
                (userownershippercentage, debtentryindex) = feepoolstate.applicableissuancedata(account, closingdebtindex);

                (feesfromperiod, rewardsfromperiod) = _feesandrewardsfromperiod(i, userownershippercentage, debtentryindex);

                results[i][0] = feesfromperiod;
                results[i][1] = rewardsfromperiod;
            }
        }
    }

    
    function _feesandrewardsfromperiod(uint period, uint ownershippercentage, uint debtentryindex)
        internal
        returns (uint, uint)
    {
        
        if (ownershippercentage == 0) return (0, 0);

        uint debtownershipforperiod = ownershippercentage;

        
        if (period > 0) {
            uint closingdebtindex = recentfeeperiods[period  1].startingdebtindex.sub(1);
            debtownershipforperiod = _effectivedebtratioforperiod(closingdebtindex, ownershippercentage, debtentryindex);
        }

        
        
        uint feesfromperiod = recentfeeperiods[period].feestodistribute
            .multiplydecimal(debtownershipforperiod);

        uint rewardsfromperiod = recentfeeperiods[period].rewardstodistribute
            .multiplydecimal(debtownershipforperiod);

        return (
            feesfromperiod.precisedecimaltodecimal(),
            rewardsfromperiod.precisedecimaltodecimal()
        );
    }

    function _effectivedebtratioforperiod(uint closingdebtindex, uint ownershippercentage, uint debtentryindex)
        internal
        view
        returns (uint)
    {
        
        if (closingdebtindex > synthetixstate.debtledgerlength()) return 0;

        
        
        uint feeperioddebtownership = synthetixstate.debtledger(closingdebtindex)
            .dividedecimalroundprecise(synthetixstate.debtledger(debtentryindex))
            .multiplydecimalroundprecise(ownershippercentage);

        return feeperioddebtownership;
    }

    function effectivedebtratioforperiod(address account, uint period)
        external
        view
        returns (uint)
    {
        require(period != 0, );
        require(period < fee_period_length, );

        
        if (recentfeeperiods[period  1].startingdebtindex == 0) return;

        uint closingdebtindex = recentfeeperiods[period  1].startingdebtindex.sub(1);

        uint ownershippercentage;
        uint debtentryindex;
        (ownershippercentage, debtentryindex) = feepoolstate.applicableissuancedata(account, closingdebtindex);

        
        return _effectivedebtratioforperiod(closingdebtindex, ownershippercentage, debtentryindex);
    }

    
    function getlastfeewithdrawal(address _claimingaddress)
        public
        view
        returns (uint)
    {
        return feepooleternalstorage.getuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, _claimingaddress)));
    }

    
    function getpenaltythresholdratio()
        public
        view
        returns (uint)
    {
        uint targetratio = synthetix.synthetixstate().issuanceratio();

        return targetratio.multiplydecimal(safedecimalmath.unit().add(target_threshold));
    }

    

    
    function _setlastfeewithdrawal(address _claimingaddress, uint _feeperiodid)
        internal
    {
        feepooleternalstorage.setuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, _claimingaddress)), _feeperiodid);
    }

    modifier onlysynthetix
    {
        require(msg.sender == address(synthetix), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != fee_address, );
        _;
    }

    

    event issuancedebtratioentry(address indexed account, uint debtratio, uint debtentryindex, uint feeperiodstartingdebtindex);
    bytes32 constant issuancedebtratioentry_sig = keccak256();
    function emitissuancedebtratioentry(address account, uint debtratio, uint debtentryindex, uint feeperiodstartingdebtindex) internal {
        proxy._emit(abi.encode(debtratio, debtentryindex, feeperiodstartingdebtindex), 2, issuancedebtratioentry_sig, bytes32(account), 0, 0);
    }

    event transferfeeupdated(uint newfeerate);
    bytes32 constant transferfeeupdated_sig = keccak256();
    function emittransferfeeupdated(uint newfeerate) internal {
        proxy._emit(abi.encode(newfeerate), 1, transferfeeupdated_sig, 0, 0, 0);
    }

    event exchangefeeupdated(uint newfeerate);
    bytes32 constant exchangefeeupdated_sig = keccak256();
    function emitexchangefeeupdated(uint newfeerate) internal {
        proxy._emit(abi.encode(newfeerate), 1, exchangefeeupdated_sig, 0, 0, 0);
    }

    event feeperioddurationupdated(uint newfeeperiodduration);
    bytes32 constant feeperioddurationupdated_sig = keccak256();
    function emitfeeperioddurationupdated(uint newfeeperiodduration) internal {
        proxy._emit(abi.encode(newfeeperiodduration), 1, feeperioddurationupdated_sig, 0, 0, 0);
    }

    event feeperiodclosed(uint feeperiodid);
    bytes32 constant feeperiodclosed_sig = keccak256();
    function emitfeeperiodclosed(uint feeperiodid) internal {
        proxy._emit(abi.encode(feeperiodid), 1, feeperiodclosed_sig, 0, 0, 0);
    }

    event feesclaimed(address account, uint xdramount, uint snxrewards);
    bytes32 constant feesclaimed_sig = keccak256();
    function emitfeesclaimed(address account, uint xdramount, uint snxrewards) internal {
        proxy._emit(abi.encode(account, xdramount, snxrewards), 1, feesclaimed_sig, 0, 0, 0);
    }
}



pragma solidity 0.4.25;

contract reentrancypreventer {
    
    bool isinfunctionbody = false;

    modifier preventreentrancy {
        require(!isinfunctionbody, );
        isinfunctionbody = true;
        _;
        isinfunctionbody = false;
    }
}


pragma solidity 0.4.25;

import ;
import ;

contract feepooleternalstorage is eternalstorage, limitedsetup {

    bytes32 constant last_fee_withdrawal = ;

    
    constructor(address _owner, address _feepool)
        eternalstorage(_owner, _feepool)
        limitedsetup(6 weeks)
        public
    {
    }

    
    function importfeewithdrawaldata(address[] accounts, uint[] feeperiodids)
        external
        onlyowner
        onlyduringsetup
    {
        require(accounts.length == feeperiodids.length, );

        for (uint8 i = 0; i < accounts.length; i++) {
            this.setuintvalue(keccak256(abi.encodepacked(last_fee_withdrawal, accounts[i])), feeperiodids[i]);
        }
    }
}


pragma solidity 0.4.25;


contract owned {
    address public owner;
    address public nominatedowner;

    
    constructor(address _owner)
        public
    {
        require(_owner != address(0), );
        owner = _owner;
        emit ownerchanged(address(0), _owner);
    }

    
    function nominatenewowner(address _owner)
        external
        onlyowner
    {
        nominatedowner = _owner;
        emit ownernominated(_owner);
    }

    
    function acceptownership()
        external
    {
        require(msg.sender == nominatedowner, );
        emit ownerchanged(owner, nominatedowner);
        owner = nominatedowner;
        nominatedowner = address(0);
    }

    modifier onlyowner
    {
        require(msg.sender == owner, );
        _;
    }

    event ownernominated(address newowner);
    event ownerchanged(address oldowner, address newowner);
}


pragma solidity 0.4.25;

import ;
import ;
import ;
import ;
import ;
import ;


contract depot is selfdestructible, pausable {
    using safemath for uint;
    using safedecimalmath for uint;

    
    isynthetix public synthetix;
    isynth public synth;
    ifeepool public feepool;

    
    
    
    address public fundswallet;

    
    address public oracle;
    
    uint public constant oracle_future_limit = 10 minutes;

    
    uint public pricestaleperiod = 3 hours;

    
    uint public lastpriceupdatetime;
    
    uint public usdtosnxprice;
    
    uint public usdtoethprice;

    
    struct synthdeposit {
        
        address user;
        
        uint amount;
    }

    
    mapping(uint => synthdeposit) public deposits;
    
    uint public depositstartindex;
    
    uint public depositendindex;

    
    uint public totalsellabledeposits;

    
    uint public minimumdepositamount = 50 * safedecimalmath.unit();

    
    
    
    mapping(address => uint) public smalldeposits;


    

    
    constructor(
        
        address _owner,

        
        address _fundswallet,

        
        isynthetix _synthetix,
        isynth _synth,
		ifeepool _feepool,

        
        address _oracle,
        uint _usdtoethprice,
        uint _usdtosnxprice
    )
        
        selfdestructible(_owner)
        pausable(_owner)
        public
    {
        fundswallet = _fundswallet;
        synthetix = _synthetix;
        synth = _synth;
        feepool = _feepool;
        oracle = _oracle;
        usdtoethprice = _usdtoethprice;
        usdtosnxprice = _usdtosnxprice;
        lastpriceupdatetime = now;
    }

    

    
    function setfundswallet(address _fundswallet)
        external
        onlyowner
    {
        fundswallet = _fundswallet;
        emit fundswalletupdated(fundswallet);
    }

    
    function setoracle(address _oracle)
        external
        onlyowner
    {
        oracle = _oracle;
        emit oracleupdated(oracle);
    }

    
    function setsynth(isynth _synth)
        external
        onlyowner
    {
        synth = _synth;
        emit synthupdated(_synth);
    }

    
    function setsynthetix(isynthetix _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
        emit synthetixupdated(_synthetix);
    }

    
    function setpricestaleperiod(uint _time)
        external
        onlyowner
    {
        pricestaleperiod = _time;
        emit pricestaleperiodupdated(pricestaleperiod);
    }

    
    function setminimumdepositamount(uint _amount)
        external
        onlyowner
    {
        
        require(_amount > safedecimalmath.unit(), );
        minimumdepositamount = _amount;
        emit minimumdepositamountupdated(minimumdepositamount);
    }

    
    
    function updateprices(uint newethprice, uint newsynthetixprice, uint timesent)
        external
        onlyoracle
    {
        
        require(lastpriceupdatetime < timesent, );
        require(timesent < (now + oracle_future_limit), );

        usdtoethprice = newethprice;
        usdtosnxprice = newsynthetixprice;
        lastpriceupdatetime = timesent;

        emit pricesupdated(usdtoethprice, usdtosnxprice, lastpriceupdatetime);
    }

    
    function ()
        external
        payable
    {
        exchangeetherforsynths();
    }

    
    function exchangeetherforsynths()
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        uint ethtosend;

        
        
        uint requestedtopurchase = msg.value.multiplydecimal(usdtoethprice);
        uint remainingtofulfill = requestedtopurchase;

        
        for (uint i = depositstartindex; remainingtofulfill > 0 && i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            
            
            if (deposit.user == address(0)) {

                depositstartindex = depositstartindex.add(1);
            } else {
                
                
                if (deposit.amount > remainingtofulfill) {

                    
                    
                    
                    uint newamount = deposit.amount.sub(remainingtofulfill);
                    deposits[i] = synthdeposit({ user: deposit.user, amount: newamount});

                    totalsellabledeposits = totalsellabledeposits.sub(remainingtofulfill);

                    
                    
                    
                    
                    
                    ethtosend = remainingtofulfill.dividedecimal(usdtoethprice);

                    
                    
                    
                    
                    if(!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, remainingtofulfill, i);
                    }

                    
                    
                    
                    
                    synth.transfer(msg.sender, remainingtofulfill);

                    
                    remainingtofulfill = 0;
                } else if (deposit.amount <= remainingtofulfill) {
                    
                    
                    
                    delete deposits[i];
                    
                    depositstartindex = depositstartindex.add(1);
                    
                    totalsellabledeposits = totalsellabledeposits.sub(deposit.amount);

                    
                    
                    
                    
                    
                    ethtosend = deposit.amount.dividedecimal(usdtoethprice);

                    
                    
                    
                    
                    if(!deposit.user.send(ethtosend)) {
                        fundswallet.transfer(ethtosend);
                        emit nonpayablecontract(deposit.user, ethtosend);
                    } else {
                        emit cleareddeposit(msg.sender, deposit.user, ethtosend, deposit.amount, i);
                    }

                    
                    
                    
                    
                    synth.transfer(msg.sender, deposit.amount);

                    
                    
                    remainingtofulfill = remainingtofulfill.sub(deposit.amount);
                }
            }
        }

        
        
        if (remainingtofulfill > 0) {
            msg.sender.transfer(remainingtofulfill.dividedecimal(usdtoethprice));
        }

        
        uint fulfilled = requestedtopurchase.sub(remainingtofulfill);

        if (fulfilled > 0) {
            
            emit exchange(, msg.value, , fulfilled);
        }

        return fulfilled;
    }

    
    function exchangeetherforsynthsatrate(uint guaranteedrate)
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedrate == usdtoethprice, );

        return exchangeetherforsynths();
    }


    
    function exchangeetherforsynthetix()
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        
        uint synthetixtosend = synthetixreceivedforether(msg.value);

        
        fundswallet.transfer(msg.value);

        
        synthetix.transfer(msg.sender, synthetixtosend);

        emit exchange(, msg.value, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangeetherforsynthetixatrate(uint guaranteedetherrate, uint guaranteedsynthetixrate)
        public
        payable
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedetherrate == usdtoethprice, );
        require(guaranteedsynthetixrate == usdtosnxprice, );

        return exchangeetherforsynthetix();
    }


    
    function exchangesynthsforsynthetix(uint synthamount)
        public
        pricesnotstale
        notpaused
        returns (uint) 
    {
        
        uint synthetixtosend = synthetixreceivedforsynths(synthamount);

        
        
        
        synth.transferfrom(msg.sender, fundswallet, synthamount);

        
        synthetix.transfer(msg.sender, synthetixtosend);

        emit exchange(, synthamount, , synthetixtosend);

        return synthetixtosend;
    }

    
    function exchangesynthsforsynthetixatrate(uint synthamount, uint guaranteedrate)
        public
        pricesnotstale
        notpaused
        returns (uint) 
    {
        require(guaranteedrate == usdtosnxprice, );

        return exchangesynthsforsynthetix(synthamount);
    }

    
    function withdrawsynthetix(uint amount)
        external
        onlyowner
    {
        synthetix.transfer(owner, amount);

        
        
        
        
    }

    
    function withdrawmydepositedsynths()
        external
    {
        uint synthstosend = 0;

        for (uint i = depositstartindex; i < depositendindex; i++) {
            synthdeposit memory deposit = deposits[i];

            if (deposit.user == msg.sender) {
                
                
                synthstosend = synthstosend.add(deposit.amount);
                delete deposits[i];
                
                emit synthdepositremoved(deposit.user, deposit.amount, i);
            }
        }

        
        totalsellabledeposits = totalsellabledeposits.sub(synthstosend);

        
        
        synthstosend = synthstosend.add(smalldeposits[msg.sender]);
        smalldeposits[msg.sender] = 0;

        
        require(synthstosend > 0, );

        
        synth.transfer(msg.sender, synthstosend);

        emit synthwithdrawal(msg.sender, synthstosend);
    }

    
    function depositsynths(uint amount)
        external
    {
        
        synth.transferfrom(msg.sender, this, amount);

        
        
    }

    
    function tokenfallback(address from, uint amount, bytes data)
        external
        onlysynth
        returns (bool)
    {
        
        
        if (amount < minimumdepositamount) {
            
            
            smalldeposits[from] = smalldeposits[from].add(amount);

            emit synthdepositnotaccepted(from, amount, minimumdepositamount);
        } else {
            
            deposits[depositendindex] = synthdeposit({ user: from, amount: amount });
            emit synthdeposit(from, amount, depositendindex);

            
            depositendindex = depositendindex.add(1);

            
            totalsellabledeposits = totalsellabledeposits.add(amount);
        }
    }

    
    
    function pricesarestale()
        public
        view
        returns (bool)
    {
        return lastpriceupdatetime.add(pricestaleperiod) < now;
    }

    
    function synthetixreceivedforsynths(uint amount)
        public
        view
        returns (uint)
    {
        
        uint synthsreceived = feepool.amountreceivedfromtransfer(amount);

        
        return synthsreceived.dividedecimal(usdtosnxprice);
    }

    
    function synthetixreceivedforether(uint amount)
        public
        view
        returns (uint)
    {
        
        uint valuesentinsynths = amount.multiplydecimal(usdtoethprice);

        
        return synthetixreceivedforsynths(valuesentinsynths);
    }

    
    function synthsreceivedforether(uint amount)
        public
        view
        returns (uint)
    {
        
        uint synthstransferred = amount.multiplydecimal(usdtoethprice);

        
        return feepool.amountreceivedfromtransfer(synthstransferred);
    }

    

    modifier onlyoracle
    {
        require(msg.sender == oracle, );
        _;
    }

    modifier onlysynth
    {
        
        require(msg.sender == address(synth), );
        _;
    }

    modifier pricesnotstale
    {
        require(!pricesarestale(), );
        _;
    }

    

    event fundswalletupdated(address newfundswallet);
    event oracleupdated(address neworacle);
    event synthupdated(isynth newsynthcontract);
    event synthetixupdated(isynthetix newsynthetixcontract);
    event pricestaleperiodupdated(uint pricestaleperiod);
    event pricesupdated(uint newethprice, uint newsynthetixprice, uint timesent);
    event exchange(string fromcurrency, uint fromamount, string tocurrency, uint toamount);
    event synthwithdrawal(address user, uint amount);
    event synthdeposit(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositremoved(address indexed user, uint amount, uint indexed depositindex);
    event synthdepositnotaccepted(address user, uint amount, uint minimum);
    event minimumdepositamountupdated(uint amount);
    event nonpayablecontract(address indexed receiver, uint amount);
    event cleareddeposit(address indexed fromaddress, address indexed toaddress, uint fromethamount, uint toamount, uint indexed depositindex);
}



pragma solidity 0.4.25;


import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract synthetix is externstatetoken {

    

    
    synth[] public availablesynths;
    mapping(bytes4 => synth) public synths;

    ifeepool public feepool;
    isynthetixescrow public escrow;
    isynthetixescrow public rewardescrow;
    exchangerates public exchangerates;
    synthetixstate public synthetixstate;
    supplyschedule public supplyschedule;
    irewardsdistribution public rewardsdistribution;

    bool private protectioncircuit = false;

    string constant token_name = ;
    string constant token_symbol = ;
    uint8 constant decimals = 18;
    bool public exchangeenabled = true;

    

    
    constructor(address _proxy, tokenstate _tokenstate, synthetixstate _synthetixstate,
        address _owner, exchangerates _exchangerates, ifeepool _feepool, supplyschedule _supplyschedule,
        isynthetixescrow _rewardescrow, isynthetixescrow _escrow, irewardsdistribution _rewardsdistribution, uint _totalsupply
    )
        externstatetoken(_proxy, _tokenstate, token_name, token_symbol, _totalsupply, decimals, _owner)
        public
    {
        synthetixstate = _synthetixstate;
        exchangerates = _exchangerates;
        feepool = _feepool;
        supplyschedule = _supplyschedule;
        rewardescrow = _rewardescrow;
        escrow = _escrow;
        rewardsdistribution = _rewardsdistribution;
    }
    

    function setfeepool(ifeepool _feepool)
        external
        optionalproxy_onlyowner
    {
        feepool = _feepool;
    }

    function setexchangerates(exchangerates _exchangerates)
        external
        optionalproxy_onlyowner
    {
        exchangerates = _exchangerates;
    }

    function setprotectioncircuit(bool _protectioncircuitisactivated)
        external
        onlyoracle
    {
        protectioncircuit = _protectioncircuitisactivated;
    }

    function setexchangeenabled(bool _exchangeenabled)
        external
        optionalproxy_onlyowner
    {
        exchangeenabled = _exchangeenabled;
    }

    
    function addsynth(synth synth)
        external
        optionalproxy_onlyowner
    {
        bytes4 currencykey = synth.currencykey();

        require(synths[currencykey] == synth(0), );

        availablesynths.push(synth);
        synths[currencykey] = synth;
    }

    
    function removesynth(bytes4 currencykey)
        external
        optionalproxy_onlyowner
    {
        require(synths[currencykey] != address(0), );
        require(synths[currencykey].totalsupply() == 0, );
        require(currencykey != , );

        
        address synthtoremove = synths[currencykey];

        
        for (uint8 i = 0; i < availablesynths.length; i++) {
            if (availablesynths[i] == synthtoremove) {
                delete availablesynths[i];

                
                
                
                availablesynths[i] = availablesynths[availablesynths.length  1];

                
                availablesynths.length;

                break;
            }
        }

        
        delete synths[currencykey];

        
        
        
    }

    

    
    function effectivevalue(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey)
        public
        view
        returns (uint)
    {
        return exchangerates.effectivevalue(sourcecurrencykey, sourceamount, destinationcurrencykey);
    }

    
    function totalissuedsynths(bytes4 currencykey)
        public
        view
        ratenotstale(currencykey)
        returns (uint)
    {
        uint total = 0;
        uint currencyrate = exchangerates.rateforcurrency(currencykey);

        require(!exchangerates.anyrateisstale(availablecurrencykeys()), );

        for (uint8 i = 0; i < availablesynths.length; i++) {
            
            
            
            
            uint synthvalue = availablesynths[i].totalsupply()
                .multiplydecimalround(exchangerates.rateforcurrency(availablesynths[i].currencykey()))
                .dividedecimalround(currencyrate);
            total = total.add(synthvalue);
        }

        return total;
    }

    
    function availablecurrencykeys()
        public
        view
        returns (bytes4[])
    {
        bytes4[] memory availablecurrencykeys = new bytes4[](availablesynths.length);

        for (uint8 i = 0; i < availablesynths.length; i++) {
            availablecurrencykeys[i] = availablesynths[i].currencykey();
        }

        return availablecurrencykeys;
    }

    
    function availablesynthcount()
        public
        view
        returns (uint)
    {
        return availablesynths.length;
    }

    

    
    function transfer(address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transfer(to, value, empty);
    }

    
    function transfer(address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        require(value <= transferablesynthetix(messagesender), );

        
        _transfer_byproxy(messagesender, to, value, data);

        return true;
    }

    
    function transferfrom(address from, address to, uint value)
        public
        returns (bool)
    {
        bytes memory empty;
        return transferfrom(from, to, value, empty);
    }

    
    function transferfrom(address from, address to, uint value, bytes data)
        public
        optionalproxy
        returns (bool)
    {
        
        require(value <= transferablesynthetix(from), );

        
        
        _transferfrom_byproxy(messagesender, from, to, value, data);

        return true;
    }

    
    function exchange(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey, address destinationaddress)
        external
        optionalproxy
        
        returns (bool)
    {
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        
        if (protectioncircuit) {
            return _internalliquidation(
                messagesender,
                sourcecurrencykey,
                sourceamount
            );
        } else {
            
            return _internalexchange(
                messagesender,
                sourcecurrencykey,
                sourceamount,
                destinationcurrencykey,
                messagesender,
                true 
            );
        }
    }

    
    function synthinitiatedexchange(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount,
        bytes4 destinationcurrencykey,
        address destinationaddress
    )
        external
        returns (bool)
    {
        _onlysynth();
        require(sourcecurrencykey != destinationcurrencykey, );
        require(sourceamount > 0, );

        
        return _internalexchange(
            from,
            sourcecurrencykey,
            sourceamount,
            destinationcurrencykey,
            destinationaddress,
            false 
        );
    }

    
    function synthinitiatedfeepayment(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount
    )
        external
        returns (bool)
    {
        _onlysynth();

        
        if (sourceamount == 0) {
            return true;
        }

        require(sourceamount > 0, );

        
        bool result = _internalexchange(
            from,
            sourcecurrencykey,
            sourceamount,
            ,
            feepool.fee_address(),
            false 
        );

        
        feepool.feepaid(sourcecurrencykey, sourceamount);

        return result;
    }

    
    function _internalexchange(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount,
        bytes4 destinationcurrencykey,
        address destinationaddress,
        bool chargefee
    )
        internal
        notfeeaddress(from)
        returns (bool)
    {
        require(exchangeenabled, );
        require(!exchangerates.priceupdatelock(), );
        require(destinationaddress != address(0), );
        require(destinationaddress != address(this), );
        require(destinationaddress != address(proxy), );

        
        

        
        synths[sourcecurrencykey].burn(from, sourceamount);

        
        uint destinationamount = effectivevalue(sourcecurrencykey, sourceamount, destinationcurrencykey);

        
        uint amountreceived = destinationamount;
        uint fee = 0;

        if (chargefee) {
            amountreceived = feepool.amountreceivedfromexchange(destinationamount);
            fee = destinationamount.sub(amountreceived);
        }

        
        synths[destinationcurrencykey].issue(destinationaddress, amountreceived);

        
        if (fee > 0) {
            uint xdrfeeamount = effectivevalue(destinationcurrencykey, fee, );
            synths[].issue(feepool.fee_address(), xdrfeeamount);
            
            feepool.feepaid(, xdrfeeamount);
        }

        

        
        synths[destinationcurrencykey].triggertokenfallbackifneeded(from, destinationaddress, amountreceived);

        
        emitsynthexchange(from, sourcecurrencykey, sourceamount, destinationcurrencykey, amountreceived, destinationaddress);

        return true;
    }

    
    function _internalliquidation(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount
    )
        internal
        returns (bool)
    {
        
        synths[sourcecurrencykey].burn(from, sourceamount);
        return true;
    }

    
    function _addtodebtregister(bytes4 currencykey, uint amount)
        internal
        optionalproxy
    {
        
        uint xdrvalue = effectivevalue(currencykey, amount, );

        
        uint totaldebtissued = totalissuedsynths();

        
        uint newtotaldebtissued = xdrvalue.add(totaldebtissued);

        
        uint debtpercentage = xdrvalue.dividedecimalroundprecise(newtotaldebtissued);

        
        
        
        
        uint delta = safedecimalmath.preciseunit().sub(debtpercentage);

        
        uint existingdebt = debtbalanceof(messagesender, );

        
        if (existingdebt > 0) {
            debtpercentage = xdrvalue.add(existingdebt).dividedecimalroundprecise(newtotaldebtissued);
        }

        
        if (!synthetixstate.hasissued(messagesender)) {
            synthetixstate.incrementtotalissuercount();
        }

        
        synthetixstate.setcurrentissuancedata(messagesender, debtpercentage);

        
        
        if (synthetixstate.debtledgerlength() > 0) {
            synthetixstate.appenddebtledgervalue(
                synthetixstate.lastdebtledgerentry().multiplydecimalroundprecise(delta)
            );
        } else {
            synthetixstate.appenddebtledgervalue(safedecimalmath.preciseunit());
        }
    }

    
    function issuesynths(bytes4 currencykey, uint amount)
        public
        optionalproxy
        
    {
        require(amount <= remainingissuablesynths(messagesender, currencykey), );

        
        _addtodebtregister(currencykey, amount);

        
        synths[currencykey].issue(messagesender, amount);

        
        _appendaccountissuancerecord();
    }

    
    function issuemaxsynths(bytes4 currencykey)
        external
        optionalproxy
    {
        
        uint maxissuable = remainingissuablesynths(messagesender, currencykey);

        
        issuesynths(currencykey, maxissuable);
    }

    
    function burnsynths(bytes4 currencykey, uint amount)
        external
        optionalproxy
        
    {
        
        uint debttoremove = effectivevalue(currencykey, amount, );
        uint debt = debtbalanceof(messagesender, );
        uint debtincurrencykey = debtbalanceof(messagesender, currencykey);

        require(debt > 0, );

        
        
        uint amounttoremove = debt < debttoremove ? debt : debttoremove;

        
        _removefromdebtregister(amounttoremove);

        uint amounttoburn = debtincurrencykey < amount ? debtincurrencykey : amount;

        
        synths[currencykey].burn(messagesender, amounttoburn);

        
        _appendaccountissuancerecord();
    }

    
    function _appendaccountissuancerecord()
        internal
    {
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetixstate.issuancedata(messagesender);

        feepool.appendaccountissuancerecord(
            messagesender,
            initialdebtownership,
            debtentryindex
        );
    }

    
    function _removefromdebtregister(uint amount)
        internal
    {
        uint debttoremove = amount;

        
        uint existingdebt = debtbalanceof(messagesender, );

        
        uint totaldebtissued = totalissuedsynths();

        
        uint newtotaldebtissued = totaldebtissued.sub(debttoremove);

        uint delta;

        
        
        if (newtotaldebtissued > 0) {

            
            uint debtpercentage = debttoremove.dividedecimalroundprecise(newtotaldebtissued);

            
            
            
            delta = safedecimalmath.preciseunit().add(debtpercentage);
        } else {
            delta = 0;
        }

        
        if (debttoremove == existingdebt) {
            synthetixstate.setcurrentissuancedata(messagesender, 0);
            synthetixstate.decrementtotalissuercount();
        } else {
            
            uint newdebt = existingdebt.sub(debttoremove);
            uint newdebtpercentage = newdebt.dividedecimalroundprecise(newtotaldebtissued);

            
            synthetixstate.setcurrentissuancedata(messagesender, newdebtpercentage);
        }

        
        synthetixstate.appenddebtledgervalue(
            synthetixstate.lastdebtledgerentry().multiplydecimalroundprecise(delta)
        );
    }

    

    
    function maxissuablesynths(address issuer, bytes4 currencykey)
        public
        view
        
        returns (uint)
    {
        
        uint destinationvalue = effectivevalue(, collateral(issuer), currencykey);

        
        return destinationvalue.multiplydecimal(synthetixstate.issuanceratio());
    }

    
    function collateralisationratio(address issuer)
        public
        view
        returns (uint)
    {
        uint totalownedsynthetix = collateral(issuer);
        if (totalownedsynthetix == 0) return 0;

        uint debtbalance = debtbalanceof(issuer, );
        return debtbalance.dividedecimalround(totalownedsynthetix);
    }

    
    function debtbalanceof(address issuer, bytes4 currencykey)
        public
        view
        
        returns (uint)
    {
        
        uint initialdebtownership;
        uint debtentryindex;
        (initialdebtownership, debtentryindex) = synthetixstate.issuancedata(issuer);

        
        if (initialdebtownership == 0) return 0;

        
        
        uint currentdebtownership = synthetixstate.lastdebtledgerentry()
            .dividedecimalroundprecise(synthetixstate.debtledger(debtentryindex))
            .multiplydecimalroundprecise(initialdebtownership);

        
        uint totalsystemvalue = totalissuedsynths(currencykey);

        
        uint highprecisionbalance = totalsystemvalue.decimaltoprecisedecimal()
            .multiplydecimalroundprecise(currentdebtownership);

        return highprecisionbalance.precisedecimaltodecimal();
    }

    
    function remainingissuablesynths(address issuer, bytes4 currencykey)
        public
        view
        
        returns (uint)
    {
        uint alreadyissued = debtbalanceof(issuer, currencykey);
        uint max = maxissuablesynths(issuer, currencykey);

        if (alreadyissued >= max) {
            return 0;
        } else {
            return max.sub(alreadyissued);
        }
    }

    
    function collateral(address account)
        public
        view
        returns (uint)
    {
        uint balance = tokenstate.balanceof(account);

        if (escrow != address(0)) {
            balance = balance.add(escrow.balanceof(account));
        }

        if (rewardescrow != address(0)) {
            balance = balance.add(rewardescrow.balanceof(account));
        }

        return balance;
    }

    
    function transferablesynthetix(address account)
        public
        view
        ratenotstale()
        returns (uint)
    {
        
        
        
        uint balance = tokenstate.balanceof(account);

        
        
        
        
        uint lockedsynthetixvalue = debtbalanceof(account, ).dividedecimalround(synthetixstate.issuanceratio());

        
        if (lockedsynthetixvalue >= balance) {
            return 0;
        } else {
            return balance.sub(lockedsynthetixvalue);
        }
    }

    
    function mint()
        external
        returns (bool)
    {
        require(rewardsdistribution != address(0), );

        uint supplytomint = supplyschedule.mintablesupply();
        require(supplytomint > 0, );

        supplyschedule.updatemintvalues();

        
        
        uint minterreward = supplyschedule.minterreward();
        
        uint amounttodistribute = supplytomint.sub(minterreward);

        
        tokenstate.setbalanceof(rewardsdistribution, tokenstate.balanceof(rewardsdistribution).add(amounttodistribute));
        emittransfer(this, rewardsdistribution, amounttodistribute);

        
        rewardsdistribution.distributerewards(amounttodistribute);

        
        tokenstate.setbalanceof(msg.sender, tokenstate.balanceof(msg.sender).add(minterreward));
        emittransfer(this, msg.sender, minterreward);

        totalsupply = totalsupply.add(supplytomint);

        return true;
    }

    

    modifier ratenotstale(bytes4 currencykey) {
        require(!exchangerates.rateisstale(currencykey), );
        _;
    }

    modifier notfeeaddress(address account) {
        require(account != feepool.fee_address(), );
        _;
    }

    
    function _onlysynth() internal view {
        bool issynth = false;

        
        for (uint8 i = 0; i < availablesynths.length; i++) {
            if (availablesynths[i] == msg.sender) {
                issynth = true;
                break;
            }
        }

        require(issynth, );
    }

    modifier onlyoracle
    {
        require(msg.sender == exchangerates.oracle(), );
        _;
    }

    
    
    event synthexchange(address indexed account, bytes4 fromcurrencykey, uint256 fromamount, bytes4 tocurrencykey,  uint256 toamount, address toaddress);
    bytes32 constant synthexchange_sig = keccak256();
    function emitsynthexchange(address account, bytes4 fromcurrencykey, uint256 fromamount, bytes4 tocurrencykey, uint256 toamount, address toaddress) internal {
        proxy._emit(abi.encode(fromcurrencykey, fromamount, tocurrencykey, toamount, toaddress), 2, synthexchange_sig, bytes32(account), 0, 0);
    }
    
}




pragma solidity 0.4.25;


import ;
import ;
import ;
import ;

contract rewardsdistribution is owned {
    using safemath for uint;
    using safedecimalmath for uint;

    
    address public authority;

    
    address public synthetixproxy;
    
    
    address public rewardescrow;

    
    address public feepoolproxy;

    
    struct distributiondata {
        address destination;
        uint amount;
    }

    
    distributiondata[] public distributions;

    
    constructor(address _owner, address _authority, address _synthetixproxy, address _rewardescrow, address _feepoolproxy)
        owned(_owner)
        public
    {
        authority = _authority;
        synthetixproxy = _synthetixproxy;
        rewardescrow = _rewardescrow;
        feepoolproxy = _feepoolproxy;
    }

    

    function setsynthetixproxy(address _synthetixproxy)
        external
        onlyowner
    {
        synthetixproxy = _synthetixproxy;
    }

    function setrewardescrow(address _rewardescrow)
        external
        onlyowner
    {
        rewardescrow = _rewardescrow;
    }

    function setfeepoolproxy(address _feepoolproxy)
        external
        onlyowner
    {
        feepoolproxy = _feepoolproxy;
    }

    
    function setauthority(address _authority)
        external
        onlyowner
    {
        authority = _authority;
    }

    

    
    function addrewarddistribution(address destination, uint amount)
        external
        onlyowner
        returns (bool)
    {
        require(destination != address(0), );
        require(amount != 0, );

        distributiondata memory rewardsdistribution = distributiondata(destination, amount);
        distributions.push(rewardsdistribution);

        emit rewarddistributionadded(distributions.length  1, destination, amount);
        return true;
    }

    
    function removerewarddistribution(uint index)
        external
        onlyowner
    {
        require(index <= distributions.length  1, );

        
        for (uint i = index; i < distributions.length  1; i++) {
            distributions[i] = distributions[i+1];
        }
        distributions.length;
    }

     
    function editrewarddistribution(uint index, address destination, uint amount)
        external
        onlyowner
        returns (bool)
    {
        require(index <= distributions.length  1, );

        distributions[index].destination = destination;
        distributions[index].amount = amount;

        return true;
    }

    
    function distributerewards(uint amount)
        external
        returns (bool)
    {
        require(msg.sender == authority, );
        require(rewardescrow != address(0), );
        require(synthetixproxy != address(0), );
        require(feepoolproxy != address(0), );
        require(amount > 0, );
        require(ierc20(synthetixproxy).balanceof(this) >= amount, );
                
        uint remainder = amount;

        
        for (uint i = 0; i < distributions.length; i++) {
            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {
                remainder = remainder.sub(distributions[i].amount);
                ierc20(synthetixproxy).transfer(distributions[i].destination, distributions[i].amount);
            }
        }

        
        ierc20(synthetixproxy).transfer(rewardescrow, remainder);

        
        ifeepool(feepoolproxy).setrewardstodistribute(remainder);

        emit rewardsdistributed(amount);
        return true;
    }

    

    
    function distributionslength()
        external
        view
        returns (uint)
    {
        return distributions.length;
    }

    

    event rewarddistributionadded(uint index, address destination, uint amount);
    event rewardsdistributed(uint amount);
}

pragma solidity 0.4.25;


import ;
import ;
import ;
import ;
import ;

contract isynthetix {

    

    ifeepool public feepool;
    isynthetixescrow public escrow;
    isynthetixescrow public rewardescrow;
    isynthetixstate public synthetixstate;
    iexchangerates public exchangerates;

    

    function balanceof(address account) public view returns (uint);
    function transfer(address to, uint value) public returns (bool);
    function effectivevalue(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey) public view returns (uint);

    function synthinitiatedfeepayment(address from, bytes4 sourcecurrencykey, uint sourceamount) external returns (bool);
    function synthinitiatedexchange(
        address from,
        bytes4 sourcecurrencykey,
        uint sourceamount,
        bytes4 destinationcurrencykey,
        address destinationaddress) external returns (bool);
    function exchange(
        bytes4 sourcecurrencykey,
        uint sourceamount,
        bytes4 destinationcurrencykey,
        address destinationaddress) external returns (bool);
    function collateralisationratio(address issuer) public view returns (uint);
    function totalissuedsynths(bytes4 currencykey)
        public
        view
        returns (uint);
    function getsynth(bytes4 currencykey) public view returns (isynth);
    function debtbalanceof(address issuer, bytes4 currencykey) public view returns (uint);
}

pragma solidity 0.4.25;

contract isynthetixstate {
    
    struct issuancedata {
        
        
        
        
        
        uint initialdebtownership;
        
        
        
        uint debtentryindex;
    }

    uint[] public debtledger;
    uint public issuanceratio;
    mapping(address => issuancedata) public issuancedata;

    function debtledgerlength() external view returns (uint);
    function hasissued(address account) external view returns (bool);
    function incrementtotalissuercount() external;
    function decrementtotalissuercount() external;
    function setcurrentissuancedata(address account, uint initialdebtownership) external;
    function lastdebtledgerentry() external view returns (uint);
    function appenddebtledgervalue(uint value) external;
    function clearissuancedata(address account) external;
}

pragma solidity 0.4.25;

contract ifeepool {
    address public fee_address;
    uint public exchangefeerate;
    function amountreceivedfromexchange(uint value) external view returns (uint);
    function amountreceivedfromtransfer(uint value) external view returns (uint);
    function feepaid(bytes4 currencykey, uint amount) external;
    function appendaccountissuancerecord(address account, uint lockedamount, uint debtentryindex) external;
    function setrewardstodistribute(uint amount) external;
    function transferfeeincurred(uint value) public view returns (uint);
}

pragma solidity 0.4.25;


interface isynthetixescrow {
    function balanceof(address account) public view returns (uint);
    function appendvestingentry(address account, uint quantity) public;
}

pragma solidity 0.4.25;


interface irewardsdistribution {
    function distributerewards(uint amount) external;
}

pragma solidity 0.4.25;

interface isynth {
  function burn(address account, uint amount) external;
  function issue(address account, uint amount) external;
  function transfer(address to, uint value) public returns (bool);
  function triggertokenfallbackifneeded(address sender, address recipient, uint amount) external;
  function transferfrom(address from, address to, uint value) public returns (bool);
}

pragma solidity 0.4.25;


interface iexchangerates {
    function effectivevalue(bytes4 sourcecurrencykey, uint sourceamount, bytes4 destinationcurrencykey) public view returns (uint);

    function rateforcurrency(bytes4 currencykey) public view returns (uint);

    function anyrateisstale(bytes4[] currencykeys) external view returns (bool);

    function rateisstale(bytes4 currencykey) external view returns (bool);
}
pragma solidity 0.4.25;


contract ierc20 {
    function totalsupply() public view returns (uint);

    function balanceof(address owner) public view returns (uint);

    function allowance(address owner, address spender) public view returns (uint);

    function transfer(address to, uint value) public returns (bool);

    function approve(address spender, uint value) public returns (bool);

    function transferfrom(address from, address to, uint value) public returns (bool);

    
    function name() public view returns (string);
    function symbol() public view returns (string);
    function decimals() public view returns (uint8);

    event transfer(
      address indexed from,
      address indexed to,
      uint value
    );

    event approval(
      address indexed owner,
      address indexed spender,
      uint value
    );
}


pragma solidity 0.4.25;

import ;
import ;
import ;
import ;

contract tokenexchanger is owned {

    address public integrationproxy;
    address public synthetix;

    constructor(address _owner, address _integrationproxy)
        owned(_owner)
        public
    {
        integrationproxy = _integrationproxy;
    }

    function setsynthetixproxy(address _integrationproxy)
        external
        onlyowner
    {
        integrationproxy = _integrationproxy;
    }

    function setsynthetix(address _synthetix)
        external
        onlyowner
    {
        synthetix = _synthetix;
    }

    function checkbalance(address account)
        public
        view
        synthetixproxyisset
        returns (uint)
    {
        return ierc20(integrationproxy).balanceof(account);
    }

    function checkallowance(address tokenowner, address spender)
        public
        view
        synthetixproxyisset
        returns (uint)
    {
        return ierc20(integrationproxy).allowance(tokenowner, spender);
    }

    function checkbalancesnxdirect(address account)
        public
        view
        synthetixproxyisset
        returns (uint)
    {
        return ierc20(synthetix).balanceof(account);
    }

    function getdecimals(address tokenaddress)
        public
        view
        returns (uint)
    {
        return ierc20(tokenaddress).decimals();
    }

    function dotokenspend(address fromaccount, address toaccount, uint amount)
        public
        synthetixproxyisset
        returns (bool)
    {
        
        require(checkbalance(fromaccount) >= amount, );

        
        require(checkallowance(fromaccount, address(this)) >= amount, );

        
        return ierc20(integrationproxy).transferfrom(fromaccount, toaccount, amount);
    }

    modifier synthetixproxyisset {
        require(integrationproxy != address(0), );
        _;
    }

    event logstring(string name, string value);
    event logint(string name, uint value);
    event logaddress(string name, address value);
    event logbytes(string name, bytes4 value);
}


pragma solidity 0.4.25;

import ;

contract publicsafedecimalmath {
    using safedecimalmath for uint;
    
    function unit()
        public
        pure
        returns (uint)
    {
        return safedecimalmath.unit();
    }

    function preciseunit()
        public
        pure
        returns (uint)
    {
        return safedecimalmath.preciseunit();
    }

    function multiplydecimal(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimal(y);
    }

    function multiplydecimalround(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimalround(y);
    }

    function multiplydecimalroundprecise(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.multiplydecimalroundprecise(y);
    }

    function dividedecimal(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimal(y);
    }

    function dividedecimalround(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimalround(y);
    }

    function dividedecimalroundprecise(uint x, uint y)
        public
        pure
        returns (uint)
    {
        return x.dividedecimalroundprecise(y);
    }

    function decimaltoprecisedecimal(uint i)
        public
        pure
        returns (uint)
    {
        return i.decimaltoprecisedecimal();
    }

    function precisedecimaltodecimal(uint i)
        public
        pure
        returns (uint)
    {
        return i.precisedecimaltodecimal();
    }
}

pragma solidity ^0.4.24;

import ;

contract reentranttokenrecipient {
    event tokenfallbackcalled(address from, uint value, bytes data);

    function tokenfallback(address from, uint value, bytes data) public {
        emit tokenfallbackcalled(from, value, data);

        publicest(msg.sender).transferfrom(from, this, value);
    }
}
pragma solidity ^0.4.23;


import ;


contract oneweeksetup is limitedsetup(1 weeks) {
	function testfunc() 
		public
		onlyduringsetup
		returns (bool)
	{
		return true;
	}

	function publicsetupexpirytime()
		public
		returns (uint)
	{
		return setupexpirytime;
	}
}

pragma solidity ^0.4.23;


import ;


contract payablesd is selfdestructible {

    constructor(address _owner)
        selfdestructible(_owner) public {}

    function () public payable {}
}


pragma solidity ^0.4.23;


import ;
import ;

contract publichavvenescrow is havvenescrow {
    using safemath for uint;

    constructor(address _owner, havven _havven)
		havvenescrow(_owner, _havven)
		public 
	{
		
        setupexpirytime = now + 50000 weeks;
    }

    function addregularvestingschedule(address account, uint conclusiontime, uint totalquantity, uint vestingperiods)
        external
        onlyowner
        onlyduringsetup
    {
        
        uint totalduration = conclusiontime.sub(now);

        
        uint periodquantity = totalquantity.div(vestingperiods);
        uint periodduration = totalduration.div(vestingperiods);

        
        for (uint i = 1; i < vestingperiods; i++) {
            uint periodconclusiontime = now.add(i.mul(periodduration));
            appendvestingentry(account, periodconclusiontime, periodquantity);
        }

        
        uint finalperiodquantity = totalquantity.sub(periodquantity.mul(vestingperiods  1));
        appendvestingentry(account, conclusiontime, finalperiodquantity);
    }
}

pragma solidity ^0.4.24;

contract tokenrecipient {
    event tokenfallbackcalled(address from, uint value, bytes data);

    function tokenfallback(address from, uint value, bytes data) public {
        emit tokenfallbackcalled(from, value, data);
    }
}
pragma solidity 0.4.25;

import ;


contract testablepausable is pausable {

    uint public somevalue;

    constructor(address _owner)
        pausable(_owner)
        public
    {}

    function setsomevalue(uint _value)
        external
        notpaused
    {
        somevalue = _value;
    }

}


pragma solidity ^0.4.24;

contract emptytokenrecipient {}
pragma solidity ^0.4.23;

import ;

contract publicest is externstatetoken {
    uint constant decimals = 18;

    constructor(address _proxy, tokenstate _tokenstate,
                string _name, string _symbol, uint _totalsupply,
                address _owner)
        externstatetoken(_proxy, _tokenstate, _name, _symbol, _totalsupply, decimals, _owner)
        public
    {}

    function transfer(address to, uint value)
        optionalproxy
        external
        returns (bool)
    {
        bytes memory empty;
        return _transfer_byproxy(messagesender, to, value, empty);
    }

    function transfer(address to, uint value, bytes data)
        optionalproxy
        external
        returns (bool)
    {
        return _transfer_byproxy(messagesender, to, value, data);
    }

    function transferfrom(address from, address to, uint value)
        optionalproxy
        external
        returns (bool)
    {
        bytes memory empty;
        return _transferfrom_byproxy(messagesender, from, to, value, empty);
    }

    function transferfrom(address from, address to, uint value, bytes data)
        optionalproxy
        external
        returns (bool)
    {
        return _transferfrom_byproxy(messagesender, from, to, value, data);
    }
}

