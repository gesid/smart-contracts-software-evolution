

pragma solidity ^0.4.19;


import ;
import ;
import ;
import ;
import ;


contract havven is erc20token, owned {

    

    
    
    mapping(address => uint) public currentbalancesum;

    
    
    
    
    mapping(address => uint) public lastaveragebalance;

    
    
    
    
    
    mapping(address => uint) public penultimateaveragebalance;

    
    
    mapping(address => uint) public lasttransfertimestamp;

    
    uint public feeperiodstarttime = 3;
    
    
    
    
    
    uint public lastfeeperiodstarttime = 2;
    
    uint public penultimatefeeperiodstarttime = 1;

    
    uint public targetfeeperioddurationseconds = 4 weeks;
    
    uint constant minfeeperioddurationseconds = 1 days;
    
    uint constant maxfeeperioddurationseconds = 26 weeks;

    
    
    uint public lastfeescollected;

    mapping(address => bool) public haswithdrawnlastperiodfees;

    ethernomin public nomin;
    havvenescrow public escrow;


    

    function havven(address _owner)
        erc20token(, ,
                   1e8 * unit, 
                   this)
        owned(_owner)
        public
    {
        lasttransfertimestamp[this] = now;
        feeperiodstarttime = now;
        lastfeeperiodstarttime = now  targetfeeperioddurationseconds;
        penultimatefeeperiodstarttime = now  2*targetfeeperioddurationseconds;
    }

    

    function setnomin(ethernomin _nomin) 
        public
        onlyowner
    {
        nomin = _nomin;
    }

    function setescrow(havvenescrow _escrow)
        public
        onlyowner
    {
        escrow = _escrow;
    }

    function unsetescrow()
        public
        onlyowner
    {
        delete escrow;
    }

    function settargetfeeperiodduration(uint duration)
        public
        postcheckfeeperiodrollover
        onlyowner
    {
        require(minfeeperioddurationseconds <= duration &&
                duration <= maxfeeperioddurationseconds);
        targetfeeperioddurationseconds = duration;
        feeperioddurationupdated(duration);
    }


    

    
    function endow(address account, uint value)
        public
        onlyowner
        returns (bool)
    {
        
        
        return this.transfer(account, value);
    }

    
    function transfer(address _to, uint _value)
        public
        precheckfeeperiodrollover
        returns (bool)
    {
        uint senderprebalance = balanceof[msg.sender];
        uint recipientprebalance = balanceof[_to];

        
        
        super.transfer(_to, _value);

        
        
        adjustfeeentitlement(msg.sender, senderprebalance);
        adjustfeeentitlement(_to, recipientprebalance);

        return true;
    }

    
    function transferfrom(address _from, address _to, uint _value)
        public
        precheckfeeperiodrollover
        returns (bool)
    {
        uint senderprebalance = balanceof[_from];
        uint recipientprebalance = balanceof[_to];

        
        
        super.transferfrom(_from, _to, _value);

        
        
        adjustfeeentitlement(_from, senderprebalance);
        adjustfeeentitlement(_to, recipientprebalance);

        return true;
    }

    
    function withdrawfeeentitlement()
        public
        precheckfeeperiodrollover
    {
        
        require(!nomin.isfrozen(msg.sender));

        
        rolloverfee(msg.sender, lasttransfertimestamp[msg.sender], balanceof[msg.sender]);

        
        require(!haswithdrawnlastperiodfees[msg.sender]);

        uint feesowed = safedecdiv(safedecmul(lastaveragebalance[msg.sender],
                                              lastfeescollected),
                                   totalsupply);

        haswithdrawnlastperiodfees[msg.sender] = true;
        if (feesowed != 0) {
            nomin.withdrawfee(msg.sender, feesowed);
            feeswithdrawn(msg.sender, msg.sender, feesowed);
        }
    }

    
    function adjustfeeentitlement(address account, uint prebalance)
        internal
    {
        
        
        rolloverfee(account, lasttransfertimestamp[account], prebalance);

        currentbalancesum[account] = safeadd(
            currentbalancesum[account],
            safemul(prebalance, now  lasttransfertimestamp[account])
        );

        
        lasttransfertimestamp[account] = now;
    }

    
    function rolloverfee(address account, uint lasttransfertime, uint prebalance)
        internal
    {
        if (lasttransfertime < feeperiodstarttime) {
            if (lasttransfertime < lastfeeperiodstarttime) {
                
                if (lasttransfertime < penultimatefeeperiodstarttime) {
                    
                    
                    penultimateaveragebalance[account] = prebalance;
                
                } else {
                    
                    penultimateaveragebalance[account] = safediv(
                        safeadd(currentbalancesum[account], safemul(prebalance, (lastfeeperiodstarttime  lasttransfertime))),
                        (lastfeeperiodstarttime  penultimatefeeperiodstarttime)
                    );
                }

                
                
                lastaveragebalance[account] = prebalance;

            
            } else {
                
                penultimateaveragebalance[account] = lastaveragebalance[account];

                
                lastaveragebalance[account] = safediv(
                    safeadd(currentbalancesum[account], safemul(prebalance, (feeperiodstarttime  lasttransfertime))),
                    (feeperiodstarttime  lastfeeperiodstarttime)
                );
            }

            
            currentbalancesum[account] = 0;
            haswithdrawnlastperiodfees[account] = false;
            lasttransfertimestamp[account] = feeperiodstarttime;
        }
    }

    
    function recomputelastaveragebalance()
        public
        precheckfeeperiodrollover
        returns (uint)
    {
        adjustfeeentitlement(msg.sender, balanceof[msg.sender]);
        return lastaveragebalance[msg.sender];
    }

    function rolloverfeeperiod()
        public
    {
        checkfeeperiodrollover();
    }

    

    
    function checkfeeperiodrollover()
        internal
    {
        
        if (feeperiodstarttime + targetfeeperioddurationseconds <= now) {
            
            if (escrow != havvenescrow(0)) {
                escrow.remitfees();
            }
            lastfeescollected = nomin.feepool();

            
            penultimatefeeperiodstarttime = lastfeeperiodstarttime;
            lastfeeperiodstarttime = feeperiodstarttime;
            feeperiodstarttime = now;
            
            feeperiodrollover(now);
        }
    }

    modifier postcheckfeeperiodrollover
    {
        _;
        checkfeeperiodrollover();
    }

    modifier precheckfeeperiodrollover
    {
        checkfeeperiodrollover();
        _;
    }
    
    

    event feeperiodrollover(uint timestamp);

    event feeperioddurationupdated(uint duration);

    event feeswithdrawn(address account, address indexed accountindex, uint fees);

}



pragma solidity ^0.4.19;


import ;
import ;
import ;
import ;


contract court is owned, safedecimalmath {

    

    
    havven havven;
    ethernomin nomin;

    
    
    uint public minstandingbalance = 100 * unit;

    
    
    uint public votingperiod = 1 weeks;
    uint constant minvotingperiod = 3 days;
    uint constant maxvotingperiod = 4 weeks;

    
    
    
    uint public confirmationperiod = 1 weeks;
    uint constant minconfirmationperiod = 1 days;
    uint constant maxconfirmationperiod = 2 weeks;

    
    
    
    uint public requiredparticipation = 3 * unit / 10;
    uint constant minrequiredparticipation = unit / 10;

    
    
    
    uint public requiredmajority = (2 * unit) / 3;
    uint constant minrequiredmajority = unit / 2;

    
    
    
    
    
    
    mapping(address => uint) public votestarttimes;

    
    
    
    mapping(address => uint) public votesfor;
    mapping(address => uint) public votesagainst;

    
    
    
    
    
    mapping(address => uint) voteweight;

    
    
    
    
    enum vote {abstention, yea, nay}

    
    
    mapping(address => vote) public uservote;
    
    mapping(address => address) public votetarget;

    

    function court(havven _havven, ethernomin _nomin, address _owner)
        owned(_owner)
        public
    {
        havven = _havven;
        nomin = _nomin;
    }


    

    function setminstandingbalance(uint balance)
        public
        onlyowner
    {
        
        
        
        minstandingbalance = balance;
    }

    function setvotingperiod(uint duration)
        public
        onlyowner
    {
        require(minvotingperiod <= duration &&
                duration <= maxvotingperiod);
        
        
        require(duration <= havven.targetfeeperioddurationseconds());
        votingperiod = duration;
    }

    function setconfirmationperiod(uint duration)
        public
        onlyowner
    {
        require(minconfirmationperiod <= duration &&
                duration <= maxconfirmationperiod);
        confirmationperiod = duration;
    }

    function setrequiredparticipation(uint fraction)
        public
        onlyowner
    {
        require(minrequiredparticipation <= fraction);
        requiredparticipation = fraction;
    }

    function setrequiredmajority(uint fraction)
        public
        onlyowner
    {
        require(minrequiredmajority <= fraction);
        requiredmajority = fraction;
    }


    


    function hasvoted(address account)
        public
        view
        returns (bool)
    {
        return uservote[account] != court.vote.abstention;
    }

    
    function voting(address target)
        public
        view
        returns (bool)
    {
        
        
        
        
        return now < votestarttimes[target] + votingperiod;
    }

    
    function confirming(address target)
        public
        view
        returns (bool)
    {
        
        
        uint starttime = votestarttimes[target];
        return starttime + votingperiod <= now &&
               now < starttime + votingperiod + confirmationperiod;
    }

    
    function waiting(address target)
        public
        view
        returns (bool)
    {
        
        
        return votestarttimes[target] + votingperiod + confirmationperiod <= now;
    }

    
    function votepasses(address target)
        public
        view
        returns (bool)
    {
        uint yeas = votesfor[target];
        uint nays = votesagainst[target];
        uint totalvotes = safeadd(yeas, nays);

        if (totalvotes == 0) {
            return false;
        }

        uint participation = safedecdiv(totalvotes, havven.totalsupply());
        uint fractioninfavour = safedecdiv(yeas, totalvotes);

        
        
        return participation > requiredparticipation &&
               fractioninfavour > requiredmajority;
    }


    

    
    function beginconfiscationmotion(address target)
        public
    {
        
        require((havven.balanceof(msg.sender) >= minstandingbalance) ||
                msg.sender == owner);

        
        
        require(votingperiod <= havven.targetfeeperioddurationseconds());

        
        require(waiting(target));

        
        require(!nomin.isfrozen(target));

        votestarttimes[target] = now;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        confiscationvote(msg.sender, msg.sender, target, target);
    }

    
    function votesetup(address target)
        internal
        returns (uint)
    {
        
        
        require(voting(target));

        
        require(!hasvoted(msg.sender));

        uint weight;
        
        
        
        if (votestarttimes[target] < havven.feeperiodstarttime()) {
            weight = havven.penultimateaveragebalance(msg.sender);
        } else {
            weight = havven.lastaveragebalance(msg.sender);
        }

        
        require(weight > 0);

        return weight;
    }

    
    function votefor(address target)
        public
    {
        uint weight = votesetup(target);
        setvotedyea(msg.sender, target);
        voteweight[msg.sender] = weight;
        votesfor[target] = safeadd(votesfor[target], weight);
        votefor(msg.sender, msg.sender, target, target, weight);
    }

    
    function voteagainst(address target)
        public
    {
        uint weight = votesetup(target);
        setvotednay(msg.sender, target);
        voteweight[msg.sender] = weight;
        votesagainst[target] = safeadd(votesagainst[target], weight);
        voteagainst(msg.sender, msg.sender, target, target, weight);
    }

    
    function cancelvote(address target)
        public
    {
        
        
        
        
        require(!confirming(target));

        
        if (voting(target)) {
            
            vote vote = uservote[msg.sender];

            if (vote == vote.yea) {
                votesfor[target] = safesub(votesfor[target], voteweight[msg.sender]);
            }
            else if (vote == vote.nay) {
                votesagainst[target] = safesub(votesagainst[target], voteweight[msg.sender]);
            } else {
                
                return;
            }

            
            voteweight[msg.sender] = 0;
            cancelledvote(msg.sender, msg.sender, target, target);
        }

        
        
        require(votetarget[msg.sender] == target);
        uservote[msg.sender] = court.vote.abstention;
        votetarget[msg.sender] = 0;
    }

    
    function closevote(address target)
        public
    {
        require((confirming(target) && !votepasses(target)) || waiting(target));

        votestarttimes[target] = 0;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        voteclosed(target, target);
    }

    
    function approve(address target)
        public
        onlyowner
    {
        require(confirming(target));
        require(votepasses(target));

        nomin.confiscatebalance(target);
        votestarttimes[target] = 0;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        voteclosed(target, target);
        confiscationapproval(target, target);
    }

    
    function veto(address target)
        public
        onlyowner
    {
        require(!waiting(target));
        votestarttimes[target] = 0;
        votesfor[target] = 0;
        votesagainst[target] = 0;
        voteclosed(target, target);
        veto(target, target);
    }

    
    function setvotedyea(address account, address target)
        internal
    {
        require(uservote[account] == court.vote.abstention);
        uservote[account] = court.vote.yea;
        votetarget[account] = target;
    }

    
    function setvotednay(address account, address target)
        internal
    {
        require(uservote[account] == court.vote.abstention);
        uservote[account] = court.vote.nay;
        votetarget[account] = target;
    }

    

    event confiscationvote(address initator, address indexed initiatorindex, address target, address indexed targetindex);

    event votefor(address account, address indexed accountindex, address target, address indexed targetindex, uint balance);

    event voteagainst(address account, address indexed accountindex, address target, address indexed targetindex, uint balance);

    event cancelledvote(address account, address indexed accountindex, address target, address indexed targetindex);

    event voteclosed(address target, address indexed targetindex);

    event veto(address target, address indexed targetindex);

    event confiscationapproval(address target, address indexed targetindex);
}



pragma solidity ^0.4.19;


import ;


contract erc20token is safedecimalmath {

    

    
    
    uint public totalsupply;
    string public name;
    string public symbol;
    mapping(address => uint) public balanceof;
    mapping(address => mapping (address => uint256)) public allowance;


    

    function erc20token(string _name, string _symbol,
                        uint initialsupply, address initialbeneficiary)
        public
    {
        name = _name;
        symbol = _symbol;
        totalsupply = initialsupply;
        balanceof[initialbeneficiary] = initialsupply;
    }


    

    function transfer(address _to, uint _value)
        public
        returns (bool)
    {
        
        transfer(msg.sender, _to, _value);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[msg.sender] = safesub(balanceof[msg.sender], _value);
        balanceof[_to] = safeadd(balanceof[_to], _value);

        return true;
    }

    function transferfrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        
        transfer(_from, _to, _value);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[_from] = safesub(balanceof[_from], _value);
        allowance[_from][msg.sender] = safesub(allowance[_from][msg.sender], _value);
        balanceof[_to] = safeadd(balanceof[_to], _value);

        return true;
    }

    function approve(address _spender, uint _value)
        public
        returns (bool)
    {
        allowance[msg.sender][_spender] = _value;
        approval(msg.sender, _spender, _value);
        return true;
    }


    

    event transfer(address indexed _from, address indexed _to, uint _value);

    event approval(address indexed _owner, address indexed _spender, uint _value);

}



import ;
import ;
import ;
import ;

pragma solidity ^0.4.19;

contract havvenescrow is owned, safedecimalmath {    
    
    havven public havven;
    ethernomin public nomin;

    
    
    mapping(address => uint[2][]) public vestingschedules;

    
    mapping(address => uint) public totalvestedaccountbalance;

    
    uint public totalvestedbalance;


    function havvenescrow(address _owner, havven _havven, ethernomin _nomin)
        owned(_owner)
        public
    {
        havven = _havven;
        nomin = _nomin;
    }

    
    function numvestingentries(address account)
        public
        view
        returns (uint)
    {
        return vestingschedules[account].length;
    }

    
    function getvestingscheduleentry(address account, uint index)
        public
        view
        returns (uint[2])
    {
        return vestingschedules[account][index];
    }

    
    function getvestingtime(address account, uint index)
        public
        view
        returns (uint)
    {
        return vestingschedules[account][index][0];
    }

    
    function getvestingquantity(address account, uint index)
        public
        view
        returns (uint)
    {
        return vestingschedules[account][index][1];
    }

    
    function getnextvestingindex(address account)
        public
        view
        returns (uint)
    {
        uint len = numvestingentries(account);
        for (uint i = 0; i < len; i++) {
            if (getvestingtime(account, i) != 0) {
                return i;
            }
        }
        return len;
    }

    
    function getnextvestingentry(address account)
        public
        view
        returns (uint[2])
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return [uint(0), 0];
        }
        return getvestingscheduleentry(account, index);
    }

    
    function getnextvestingtime(address account)
        public
        view
        returns (uint)
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return 0;
        }
        return getvestingtime(account, index);
    }


    
    function getnextvestingquantity(address account)
        public
        view
        returns (uint)
    {
        uint index = getnextvestingindex(account);
        if (index == numvestingentries(account)) {
            return 0;
        }
        return getvestingquantity(account, index);
    }

    
    function feepool()
        public
        view
        returns (uint)
    {
        return nomin.balanceof(this);
    }

    function sethavven(havven newhavven)
        public
        onlyowner
    {
        havven = newhavven;
        havvenupdated(newhavven);
    }

    function setnomin(ethernomin newnomin)
        public
        onlyowner
    {
        nomin = newnomin;
        nominupdated(newnomin);
    } 

    
    function remitfees()
        public
    {
        
        
        require(havven(msg.sender) == havven);
        uint feebalance = feepool();
        
        if (feebalance != 0) {
            nomin.donatetofeepool(feepool());
        }
    }

    
    function withdrawfeepool()
        public
        onlyowner
    {
        havven.withdrawfeeentitlement();
        contractfeeswithdrawn(now, feepool());
    }

    
    function withdrawfees()
        public
    {
        
        if (!havven.haswithdrawnlastperiodfees(this)) {
            withdrawfeepool();
            
            
            
            contractfeeswithdrawn(now, feepool());
        }
        
        uint entitlement = nomin.pricetospend(safedecdiv(safedecmul(totalvestedaccountbalance[msg.sender], feepool()), totalvestedbalance));
        if (entitlement != 0) {
            nomin.transfer(msg.sender, entitlement);
            feeswithdrawn(msg.sender, msg.sender, now, entitlement);
        }
    }

    
    function purgeaccount(address account)
        onlyowner
        public
    {
        delete vestingschedules[account];
        totalvestedbalance = safesub(totalvestedbalance, totalvestedaccountbalance[account]);
        totalvestedaccountbalance[account] = 0;
    }

    
    function withdrawhavvens(uint quantity)
        onlyowner
        external
    {
        havven.transfer(havven, quantity);
    }

    
    function appendvestingentry(address account, uint time, uint quantity)
        onlyowner
        public
    {
        
        require(now < time);
        require(quantity != 0);

        if (vestingschedules[account].length == 0) {
            totalvestedaccountbalance[account] = quantity;
        } else {
            
            
            require(getvestingtime(account, numvestingentries(account)  1) < time);
            totalvestedaccountbalance[account] = safeadd(totalvestedaccountbalance[account], quantity);
        }

        vestingschedules[account].push([time, quantity]);
        totalvestedbalance = safeadd(totalvestedbalance, quantity);
    }

    
    function addregularvestingschedule(address account, uint conclusion_time, uint quantity, uint vesting_periods)
        onlyowner
        public
    {
        
        uint time_period = safesub(conclusion_time, now);
        
        uint item_quantity = safediv(quantity, vesting_periods);
        uint quant_sum = safemul(item_quantity, (vesting_periods1));
        uint period_length = safediv(time_period, vesting_periods); 

        for (uint i = 1; i < vesting_periods; i++) {
            uint item_time_period = safemul(i, period_length);
            appendvestingentry(account, safeadd(now, item_time_period), item_quantity);
        }
        appendvestingentry(account, conclusion_time, safesub(quantity, quant_sum));
    }

    
    function vest() 
        public
    {
        uint total = 0;
        for (uint i = 0; i < numvestingentries(msg.sender); i++) {
            uint time = getvestingtime(msg.sender, i);
            
            if (time > now) {
                break;
            }
            uint qty = getvestingquantity(msg.sender, i);
            if (qty == 0) {
                continue;
            }

            vestingschedules[msg.sender][i] = [0, 0];
            total = safeadd(total, qty);
            totalvestedaccountbalance[msg.sender] = safesub(totalvestedaccountbalance[msg.sender], qty);
        }

        if (total != 0) {
            totalvestedbalance = safesub(totalvestedbalance, total);
            havven.transfer(msg.sender, total);
            vested(msg.sender, msg.sender, now, total);
        }
    }

    event havvenupdated(address newhavven);

    event nominupdated(address newnomin);

    event contractfeeswithdrawn(uint time, uint value);

    event feeswithdrawn(address recipient, address indexed recipientindex, uint time, uint value);

    event vested(address beneficiary, address indexed beneficiaryindex, uint time, uint value);

}


pragma solidity ^0.4.19;



contract safedecimalmath {

    
    uint public constant decimals = 18;

    
    uint public constant unit = 10 ** decimals;

    
    function addissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        return x + y >= y;
    }

    
    function safeadd(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        require(addissafe(x, y));
        return x + y;
    }

    
    function subissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        return y <= x;
    }

    
    function safesub(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        require(subissafe(x, y));
        return x  y;
    }

    
    function mulissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        if (x == 0) {
            return true;
        }
        uint r = x * y;
        return r / x == y;
    }

    
    function safemul(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        require(mulissafe(x, y));
        return x * y;
    }

    
    function safedecmul(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        
        
        return safemul(x, y) / unit;

    }

    
    function divissafe(uint x, uint y)
        pure
        internal
        returns (bool)
    {
        return y != 0;
    }

    
    function safediv(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        
        
        
        require(divissafe(x, y));
        return x / y;
    }

    
    function safedecdiv(uint x, uint y)
        pure
        internal
        returns (uint)
    {
        
        return safediv(safemul(x, unit), y);
    }

    
    function inttodec(uint i)
        pure
        internal
        returns (uint)
    {
        return safemul(i, unit);
    }
}



pragma solidity ^0.4.19;


import ;
import ;


contract erc20feetoken is owned, safedecimalmath {

    

    
    
    uint public totalsupply;
    string public name;
    string public symbol;
    mapping(address => uint) public balanceof;
    mapping(address => mapping (address => uint256)) public allowance;

    
    
    uint public transferfeerate;
    
    uint constant maxtransferfeerate = unit / 10;

    
    uint public feepool = 0;

    
    address public feeauthority;


    

    function erc20feetoken(string _name, string _symbol,
                           uint initialsupply, address initialbeneficiary,
                           uint _feerate, address _feeauthority,
                           address _owner)
        owned(_owner)
        public
    {
        name = _name;
        symbol = _symbol;
        totalsupply = initialsupply;
        balanceof[initialbeneficiary] = initialsupply;
        transferfeerate = _feerate;
        feeauthority = _feeauthority;
    }


    

    function settransferfeerate(uint newfeerate)
        public
        onlyowner
    {
        require(newfeerate <= maxtransferfeerate);
        transferfeerate = newfeerate;
        transferfeerateupdate(newfeerate);
    }

    function setfeeauthority(address newfeeauthority)
        public
        onlyowner
    {
        feeauthority = newfeeauthority;
        feeauthorityupdate(newfeeauthority);
    }


    

    
    function transferfeeincurred(uint _value)
        public
        view
        returns (uint)
    {
        return safedecmul(_value, transferfeerate);
        
        
        
        
        
        
        
    }

    
    
    function transferplusfee(uint _value)
        public
        view
        returns (uint)
    {
        return safeadd(_value, transferfeeincurred(_value));
    }

    
    function pricetospend(uint value)
        public
        view
        returns (uint)
    {
        return safedecdiv(value, safeadd(unit, transferfeerate));
    }


    

    function transfer(address _to, uint _value)
        public
        returns (bool)
    {
        
        
        uint fee = transferfeeincurred(_value);
        uint totalcharge = safeadd(_value, fee);

        
        transfer(msg.sender, _to, _value);
        transferfeepaid(msg.sender, fee);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[msg.sender] = safesub(balanceof[msg.sender], totalcharge);
        balanceof[_to] = safeadd(balanceof[_to], _value);
        feepool = safeadd(feepool, fee);

        return true;
    }

    function transferfrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        
        
        uint fee = transferfeeincurred(_value);
        uint totalcharge = safeadd(_value, fee);

        
        transfer(_from, _to, _value);
        transferfeepaid(msg.sender, fee);

        
        if (_value == 0) {
            return true;
        }

        
        balanceof[_from] = safesub(balanceof[_from], totalcharge);
        allowance[_from][msg.sender] = safesub(allowance[_from][msg.sender], totalcharge);
        balanceof[_to] = safeadd(balanceof[_to], _value);
        feepool = safeadd(feepool, fee);

        return true;
    }

    function approve(address _spender, uint _value)
        public
        returns (bool)
    {
        allowance[msg.sender][_spender] = _value;
        approval(msg.sender, _spender, _value);
        return true;
    }

    
    function withdrawfee(address account, uint value)
        public
        returns (bool)
    {
        require(msg.sender == feeauthority);
        
        feepool = safesub(feepool, value);
        balanceof[account] = safeadd(balanceof[account], value);
        feewithdrawal(account, value);
        return true;
    }

    
    function donatetofeepool(uint n)
        public
        returns (bool)
    {
        uint balance = balanceof[msg.sender];
        require(balance != 0);

        
        balanceof[msg.sender] = safesub(balance, n);
        feepool = safeadd(feepool, n);
        feedonation(msg.sender, msg.sender, n);
        return true;
    }


    

    event transfer(address indexed _from, address indexed _to, uint _value);

    event transferfeepaid(address indexed account, uint value);

    event approval(address indexed _owner, address indexed _spender, uint _value);

    event transferfeerateupdate(uint newfeerate);

    event feewithdrawal(address indexed account, uint value);

    event feedonation(address donor, address indexed donorindex, uint value);

    event feeauthorityupdate(address feeauthority);
}




pragma solidity ^0.4.19;

contract owned {
    address public owner;

    function owned(address _owner)
        public
    {
        owner = _owner;
    }

    function setowner(address newowner)
        public
        onlyowner
    {
        owner = newowner;
        ownerchanged(owner, newowner);
    }

    modifier onlyowner
    {
        require(msg.sender == owner);
        _;
    }

    event ownerchanged(address oldowner, address newowner);
}



pragma solidity ^0.4.19;


import ;
import ;
import ;


contract ethernomin is erc20feetoken {

    

    
    
    address public oracle;

    
    court public court;

    
    address public beneficiary;

    
    uint public nominpool = 0;

    
    uint public poolfeerate = unit / 200;

    
    uint constant purchasemininum = unit / 100;

    
    uint constant collatratiominimum =  2 * unit;

    
    
    uint constant autoliquidationratio = unit;

    
    
    uint constant defaultliquidationperiod = 90 days;
    uint constant maxliquidationperiod = 180 days;
    uint public liquidationperiod = defaultliquidationperiod;

    
    
    
    uint public liquidationtimestamp = ~uint(0);

    
    uint public etherprice;

    
    uint public lastpriceupdate;

    
    
    uint public staleperiod = 2 days;

    
    mapping(address => bool) public isfrozen;


    

    function ethernomin(havven _havven, address _oracle,
                        address _beneficiary,
                        uint initialetherprice,
                        address _owner)
        erc20feetoken(, ,
                      0, _owner,
                      unit / 500, 
                      address(_havven), 
                      _owner)
        public
    {
        oracle = _oracle;
        beneficiary = _beneficiary;

        etherprice = initialetherprice;
        lastpriceupdate = now;
        priceupdated(etherprice);

        isfrozen[this] = true;
    }


    

    function setoracle(address neworacle)
        public
        onlyowner
    {
        oracle = neworacle;
        oracleupdated(neworacle);
    }

    function setcourt(address newcourt)
        public
        onlyowner
    {
        court = court(newcourt);
        courtupdated(newcourt);
    }

    function setbeneficiary(address newbeneficiary)
        public
        onlyowner
    {
        beneficiary = newbeneficiary;
        beneficiaryupdated(newbeneficiary);
    }

    function setpoolfeerate(uint newfeerate)
        public
        onlyowner
    {
        require(newfeerate <= unit);
        poolfeerate = newfeerate;
        poolfeerateupdated(newfeerate);
    }

    function setstaleperiod(uint period)
        public
        onlyowner
    {
        staleperiod = period;
        staleperiodupdated(period);
    }

    

    
    function fiatvalue(uint eth)
        public
        view
        pricenotstale
        returns (uint)
    {
        return safedecmul(eth, etherprice);
    }

    
    function fiatbalance()
        public
        view
        returns (uint)
    {
        
        return fiatvalue(this.balance);
    }

    
    function ethervalue(uint fiat)
        public
        view
        pricenotstale
        returns (uint)
    {
        return safedecdiv(fiat, etherprice);
    }

    
    function ethervalueallowstale(uint fiat) 
        internal
        view
        returns (uint)
    {
        return safedecdiv(fiat, etherprice);
    }

    
    function collateralisationratio()
        public
        view
        returns (uint)
    {
        return safedecdiv(fiatbalance(), totalsupply);
    }

    
    function poolfeeincurred(uint n)
        public
        view
        returns (uint)
    {
        return safedecmul(n, poolfeerate);
    }

    
    function purchasecostfiat(uint n)
        public
        view
        returns (uint)
    {
        return safeadd(n, poolfeeincurred(n));
    }

    
    function purchasecostether(uint n)
        public
        view
        returns (uint)
    {
        
        return ethervalue(purchasecostfiat(n));
    }

    
    function saleproceedsfiat(uint n)
        public
        view
        returns (uint)
    {
        return safesub(n, poolfeeincurred(n));
    }

    
    function saleproceedsether(uint n)
        public
        view
        returns (uint)
    {
        
        return ethervalue(saleproceedsfiat(n));
    }

    
    function saleproceedsetherallowstale(uint n)
        internal
        view
        returns (uint)
    {
        return ethervalueallowstale(saleproceedsfiat(n));
    }

    
    function priceisstale()
        public
        view
        returns (bool)
    {
        return safeadd(lastpriceupdate, staleperiod) < now;
    }

    function isliquidating()
        public
        view
        returns (bool)
    {
        return liquidationtimestamp <= now;
    }

    
    function canselfdestruct()
        public
        view
        returns (bool)
    {
        
        
        if (isliquidating()) {
            
            
            bool totalperiodelapsed = liquidationtimestamp + liquidationperiod < now;
            bool alltokensreturned = (liquidationtimestamp + 1 weeks < now) && (nominpool == totalsupply);
            return totalperiodelapsed || alltokensreturned;
        }
        return false;
    }


    

    
    function transfer(address _to, uint _value)
        public
        returns (bool)
    {
        require(!(isfrozen[msg.sender] || isfrozen[_to]));
        return super.transfer(_to, _value);
    }

    
    function transferfrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        require(!(isfrozen[_from] || isfrozen[_to]));
        return super.transferfrom(_from, _to, _value);
    }

    
    function updateprice(uint price)
        public
        postcheckautoliquidate
    {
        
        require(msg.sender == oracle);

        etherprice = price;
        lastpriceupdate = now;
        priceupdated(price);
    }

    
    function issue(uint n)
        public
        onlyowner
        payable
        notliquidating
    {
        
        
        
        uint sum = safeadd(totalsupply, n);
        require(fiatbalance() >= safedecmul(sum, collatratiominimum));
        totalsupply = sum;
        nominpool = safeadd(nominpool, n);
        issuance(n, msg.value);
    }

    
    function burn(uint n)
        public
        onlyowner
    {
        
        require(nominpool >= n);
        nominpool = safesub(nominpool, n);
        totalsupply = safesub(totalsupply, n);
        burning(n);
    }

    
    function buy(uint n)
        public
        notliquidating
        payable
    {
        
        require(n >= purchasemininum &&
                msg.value == purchasecostether(n));
        
        nominpool = safesub(nominpool, n);
        balanceof[msg.sender] = safeadd(balanceof[msg.sender], n);
        purchase(msg.sender, msg.sender, n, msg.value);
    }

    
    function sell(uint n)
        public
    {

        
        
        
        uint proceeds;
        if (isliquidating()) {
            proceeds = saleproceedsetherallowstale(n);
        } else {
            proceeds = saleproceedsether(n);
        }

        require(this.balance >= proceeds);

        
        balanceof[msg.sender] = safesub(balanceof[msg.sender], n);
        nominpool = safeadd(nominpool, n);
        sale(msg.sender, msg.sender, n, proceeds);
        msg.sender.transfer(proceeds);
    }

    
    function forceliquidation()
        public
        onlyowner
        notliquidating
    {
        beginliquidation();
    }

    function beginliquidation()
        internal
    {
        liquidationtimestamp = now;
        liquidation(liquidationperiod);
    }

    
    function extendliquidationperiod(uint extension)
        public
        onlyowner
    {
        require(isliquidating());
        uint sum = safeadd(liquidationperiod, extension);
        require(sum <= maxliquidationperiod);
        liquidationperiod = sum;
        liquidationextended(extension);
    }

    
    function terminateliquidation()
        public
        onlyowner
        pricenotstale
        payable
    {
        require(isliquidating());
        require(totalsupply == 0 || collateralisationratio() >= autoliquidationratio);
        liquidationtimestamp = ~uint(0);
        liquidationperiod = defaultliquidationperiod;
        liquidationterminated();
    }

    
    function selfdestruct()
        public
        onlyowner
    {
        require(canselfdestruct());
        selfdestructed();
        selfdestruct(beneficiary);
    }

    
    function confiscatebalance(address target)
        public
    {
        
        require(court(msg.sender) == court);

        
        
        
        require(court.confirming(target));
        require(court.votepasses(target));

        
        uint balance = balanceof[target];
        feepool = safeadd(feepool, balance);
        balanceof[target] = 0;
        isfrozen[target] = true;
        confiscation(target, target, balance);
    }

    
    function unfreezeaccount(address target)
        public
        onlyowner
    {
        if (isfrozen[target] && ethernomin(target) != this) {
            isfrozen[target] = false;
            accountunfrozen(target, target);
        }
    }

    
    function() public payable {}


    

    modifier notliquidating
    {
        require(!isliquidating());
        _;
    }

    modifier pricenotstale
    {
        require(!priceisstale());
        _;
    }

    
    modifier postcheckautoliquidate
    {
        _;
        if (!isliquidating() && totalsupply != 0 && collateralisationratio() < autoliquidationratio) {
            beginliquidation();
        }
    }


    

    event issuance(uint nominsissued, uint collateraldeposited);

    event burning(uint nominsburned);

    event purchase(address buyer, address indexed buyerindex, uint nomins, uint eth);

    event sale(address seller, address indexed sellerindex, uint nomins, uint eth);

    event priceupdated(uint newprice);

    event staleperiodupdated(uint newperiod);

    event oracleupdated(address neworacle);

    event courtupdated(address newcourt);

    event beneficiaryupdated(address newbeneficiary);

    event liquidation(uint duration);

    event liquidationterminated();

    event liquidationextended(uint extension);

    event poolfeerateupdated(uint newfeerate);

    event selfdestructed();

    event confiscation(address target, address indexed targetindex, uint balance);

    event accountunfrozen(address target, address indexed targetindex);
}



pragma solidity ^0.4.19;


import ;



contract publichavven is havven {
    
    function publichavven(address _owner)
        havven(_owner)
        public
    {}

    function _currentbalancesum(address account)
        public
        view
        returns (uint)
    {
        return currentbalancesum[account];
    }

    function _lasttransfertimestamp(address account)
        public
        view
        returns (uint)
    {
        return lasttransfertimestamp[account];
    }

    function _haswithdrawnlastperiodfees(address account)
        public
        view
        returns (bool)
    {
        return haswithdrawnlastperiodfees[account];
    }

    function _lastfeeperiodstarttime()
        public
        view
        returns (uint)
    {
        return lastfeeperiodstarttime;
    }

    function _penultimatefeeperiodstarttime()
        public
        view
        returns (uint)
    {
        return penultimatefeeperiodstarttime;
    }

    function _minfeeperioddurationseconds()
        public
        view
        returns (uint)
    {
        return minfeeperioddurationseconds;
    }

    function _maxfeeperioddurationseconds()
        public
        view
        returns (uint)
    {
        return maxfeeperioddurationseconds;
    }
    
    function _adjustfeeentitlement(address account, uint prebalance)
        public
    {
        return adjustfeeentitlement(account, prebalance);
    }

    function _rolloverfee(address account, uint lasttransfertime, uint prebalance)
        public
    {
        return rolloverfee(account, lasttransfertime, prebalance);
    }

    function _checkfeeperiodrollover()
        public
    {
        checkfeeperiodrollover();
    }
}

pragma solidity ^0.4.19;

import ;

contract publiccourt is court {

	function publiccourt(havven _havven, ethernomin _nomin, address _owner)
		court(_havven, _nomin, _owner)
		public
	{}

	function _havven()
		public 
		view
		returns (address)
	{
		return havven;
	}

	function _nomin()
		public 
		view
		returns (address)
	{
		return nomin;
	}

	function _minvotingperiod()
		public
		view
		returns (uint)
	{
		return minvotingperiod;
	}

	function _maxvotingperiod()
		public
		view
		returns (uint)
	{
		return maxvotingperiod;
	}

	function _minconfirmationperiod()
		public
		view
		returns (uint)
	{
		return minconfirmationperiod;
	}

	function _maxconfirmationperiod()
		public
		view
		returns (uint)
	{
		return maxconfirmationperiod;
	}

	function _minrequiredparticipation()
		public
		view
		returns (uint)
	{
		return minrequiredparticipation;
	}

	function _minrequiredmajority()
		public
		view
		returns (uint)
	{
		return minrequiredmajority;
	}

	function _voteweight(address account)
		public
		view
		returns (uint)
	{
		return voteweight[account];
	}

	function publicsetvotedyea(address account, address target)
		public
	{
		setvotedyea(account, target);
	}

	function publicsetvotednay(address account, address target)
		public
	{
		setvotednay(account, target);
	}
}

pragma solidity ^0.4.19;

import ;

contract publicmath is safedecimalmath {
    function pubaddissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return addissafe(x, y);
    }

    function pubsafeadd(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safeadd(x, y);
    }

    function pubsubissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return subissafe(x, y);
    }

    function pubsafesub(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safesub(x, y);
    }

    function pubmulissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return mulissafe(x, y);
    }

	function pubsafemul(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safemul(x, y);
    }

    function pubsafedecmul(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safedecmul(x, y);
    }

    function pubdivissafe(uint x, uint y)
        pure
        public
        returns (bool)
    {
        return divissafe(x, y);
    }

	function pubsafediv(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safediv(x, y);
    }

    function pubsafedecdiv(uint x, uint y)
        pure
        public
        returns (uint)
    {
        return safedecdiv(x, y);
    }

    function pubinttodec(uint i)
        pure
        public
        returns (uint)
    {
        return inttodec(i);
    }
}


pragma solidity ^0.4.19;

import ;

contract publicethernomin is ethernomin {

	function publicethernomin(havven _havven, address _oracle,
                              address _beneficiary,
                              uint initialetherprice,
                              address _owner)
		ethernomin(_havven, _oracle, _beneficiary, initialetherprice, _owner)
		public {}

	function publicethervalueallowstale(uint n) 
		public
		view
		returns (uint)
	{
		return ethervalueallowstale(n);
	}

	function publicsaleproceedsetherallowstale(uint n)
		public
		view
		returns (uint)
	{
		return saleproceedsetherallowstale(n);
	}

	function debugwithdrawallether(address recipient)
		public
	{
		recipient.send(this.balance);
	}
	
	function debugemptyfeepool()
		public
	{
		feepool = 0;
	}

	function debugfreezeaccount(address target)
		public
	{
		isfrozen[target] = true;
	}
}

pragma solidity ^0.4.19;

import ;

contract fakecourt {
		ethernomin public nomin;

		mapping(address => bool) public confirming;
		mapping(address => bool) public votepasses;

		function setnomin(ethernomin newnomin)
			public
		{
			nomin = newnomin;
		}

		function setconfirming(address target, bool status)
			public
		{
			confirming[target] = status;
		}

		function setvotepasses(address target, bool status)
			public
		{
			votepasses[target] = status;
		}

		function confiscatebalance(address target)
			public
		{
			nomin.confiscatebalance(target);
		}
}

