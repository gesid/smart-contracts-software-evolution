

pragma solidity ^0.4.23;

contract gemlike {
    function move(address,address,uint) public;
}

contract flippy{
    function kick(address lad, address gal, uint tab, uint lot, uint bid)
        public returns (uint);
}

contract fusspot {
    function kick(address gal, uint lot, uint bid) public returns (uint);
}

contract vat {
    address public root;
    bool    public live;
    uint256 public forms;

    address public flapper;
    address public flopper;

    uint256 public line;
    uint256 public lump;
    uint48  public wait;

    struct ilk {
        uint256  spot;  
        uint256  rate;  
        uint256  line;  
        uint256  chop;  

        uint256  art;   

        address  flip;
    }
    struct urn {
        uint256 gem;
        uint256 ink;
        uint256 art;
    }

    mapping (address => int256)                   public dai;
    mapping (bytes32 => ilk)                      public ilks;
    mapping (bytes32 => mapping (address => urn)) public urns;

    function gem(bytes32 ilk, address lad) public view returns (uint) {
        return urns[ilk][lad].gem;
    }
    function ink(bytes32 ilk, address lad) public view returns (uint) {
        return urns[ilk][lad].ink;
    }
    function art(bytes32 ilk, address lad) public view returns (uint) {
        return urns[ilk][lad].art;
    }
    uint public tab;

    function era() public view returns (uint48) { return uint48(now); }

    uint constant ray = 10 ** 27;
    uint constant maxint = uint(1) / 2;
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x  y) <= x);
    }
    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
    function rmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), ray / 2) / ray;
    }
    function rmuli(uint x, int y) internal pure returns (int z) {
        return y > 0 ? int(rmul(x, uint(y))) : int(rmul(x, uint(y)));
    }
    function addi(uint x, int y) internal pure returns (uint z) {
        z = uint(int(x) + y);  
    }
    function subi(uint x, int y) internal pure returns (uint z) {
        z = uint(int(x)  y);  
    }

    constructor() public {
        root = msg.sender;
        live = true;
    }

    
    function form() public returns (bytes32 ilk) {   
        ilk = bytes32(++forms);
        ilks[ilk].rate = ray;
        ilks[ilk].chop = ray;
    }
    function file(bytes32 what, uint risk) public {  
        if (what == ) wait = uint48(risk);
        if (what == ) lump = risk;
        if (what == ) line = risk;
    }
    function file(bytes32 ilk, bytes32 what, uint risk) public {  
        if (what == ) ilks[ilk].spot = risk;
        if (what == ) ilks[ilk].rate = risk;
        if (what == ) ilks[ilk].line = risk;
        if (what == ) ilks[ilk].chop = risk;
        if (what == ) wait = uint48(risk);
        if (what == ) lump = risk;
        if (what == ) line = risk;
    }
    function tiff(bytes32 ilk, address flip) public {       
        ilks[ilk].flip = flippy(flip);
    }
    function taff(address flap) public { flapper = flap; }  
    function toff(address flop) public { flopper = flop; }  

    function flux(bytes32 ilk, address lad, int wad) public {  
        urns[ilk][lad].gem = addi(urns[ilk][lad].gem, wad);
    }

    
    function move(address src, address dst, uint256 wad) public {  
        require(dai[src] >= int(wad));
        dai[src] = int(wad);
        dai[dst] += int(wad);
    }

    
    function frob(bytes32 ilk, int dink, int dart) public {
        urn storage u = urns[ilk][msg.sender];
        ilk storage i = ilks[ilk];

        u.gem = addi(u.gem, dink);
        u.ink = addi(u.ink,  dink);

        dai[msg.sender] += rmuli(i.rate, dart);
        u.art = addi(u.art, dart);
        i.art = addi(i.art, dart);
        tab   = addi(  tab, rmuli(i.rate, dart));

        bool calm = rmul(i.art, i.rate) <= i.line && tab < line;

        bool cool = dart <= 0;
        bool firm = dink >= 0;
        bool safe = rmul(u.ink, i.spot) >= rmul(u.art, i.rate);

        require(( calm || cool ) && ( cool && firm || safe ) && live);
    }

    
    function drip(int wad) public {  
        dai[this] += wad;
        tab = addi(tab, wad);
    }

    
    struct flip {
        bytes32 ilk;
        address lad;
        uint256 ink;
        uint256 tab;
    }
    flip[] public flips;
    mapping (uint48 => uint) public sin;

    function bite(bytes32 ilk, address lad) public returns (uint) {
        urn storage u = urns[ilk][lad];
        ilk storage i = ilks[ilk];

        uint ink = u.ink;
        uint art = u.art;
        uint tab = rmul(art, i.rate);

        u.ink = 0;
        u.art = 0;
        i.art = sub(i.art, art);

        require(rmul(ink, i.spot) < tab);  

        sin[era()] = add(sin[era()], tab);
        return flips.push(flip(ilk, lad, ink, tab))  1;
    }
    function flog(uint48 tic) public {
        require(tic + wait <= era());
        dai[this] = int(sin[tic]);
        tab = sub(tab, sin[tic]);
        sin[tic] = 0;
    }

    function flip(uint n, uint wad) public returns (uint) {
        flip storage f = flips[n];
        ilk  storage i = ilks[f.ilk];

        require(wad <= f.tab);
        require(wad == lump || (wad < lump && wad == f.tab));

        uint tab = f.tab;
        uint ink = f.ink * wad / tab;

        f.tab = sub(f.tab, wad);
        f.ink = sub(f.ink, ink);

        return flippy(i.flip).kick({ lad: f.lad
                                   , gal: this
                                   , tab: rmul(wad, i.chop)
                                   , lot: ink
                                   , bid: 0
                                   });
    }
    function flap() public returns (uint) {
        require(dai[this] >= int(lump));
        return fusspot(flapper).kick(this, lump, 0);
    }
    function flop() public returns (uint) {
        require(dai[this] <= int(lump));
        return fusspot(flopper).kick(this, uint(1), lump);
    }
}

pragma solidity ^0.4.23;

import ;
import ;

import ;
import {dai20} from ;

contract guy {
    flipper flip;
    constructor(flipper flip_) public {
        flip = flip_;
    }
    function tend(uint id, uint lot, uint bid) public {
        flip.tend(id, lot, bid);
    }
    function dent(uint id, uint lot, uint bid) public {
        flip.dent(id, lot, bid);
    }
    function deal(uint id) public {
        flip.deal(id);
    }
    function try_tend(uint id, uint lot, uint bid)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(flip).call(sig, id, lot, bid);
    }
    function try_dent(uint id, uint lot, uint bid)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(flip).call(sig, id, lot, bid);
    }
    function try_deal(uint id)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(flip).call(sig, id);
    }
    function try_tick(uint id)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(flip).call(sig, id);
    }
}

contract vat is vatlike {
    mapping (address => int)  public gems;
    mapping (address => uint) public dai;
    function flux(bytes32 ilk, address lad, int jam) public {
        gems[lad] += jam;
        ilk;
    }
    function move(address src, address dst, uint wad) public {
        dai[src] = wad;
        dai[dst] += wad;
    }
    function suck(address guy, uint wad) public {
        dai[guy] += wad;
    }
}

contract gal {}

contract warpflip is flipper {
    uint48 _era; function warp(uint48 era_) public { _era = era_; }
    function era() public view returns (uint48) { return _era; }
    constructor(address vat_, bytes32 ilk_) public
        flipper(vat_, ilk_) {}
}

contract fliptest is dstest {
    warpflip flip;
    dai20   pie;

    guy  ali;
    guy  bob;
    gal  gal;
    vat  vat;

    function setup() public {
        vat = new vat();
        pie = new dai20(vat);
        flip = new warpflip(vat, );

        flip.warp(1 hours);

        ali = new guy(flip);
        bob = new guy(flip);
        gal = new gal();

        pie.approve(flip);

        vat.suck(this, 1000 ether);

        pie.push(ali, 200 ether);
        pie.push(bob, 200 ether);
    }
    function test_kick() public {
        flip.kick({ lot: 100 ether
                  , tab: 50 ether
                  , lad: address(0xacab)
                  , gal: gal
                  , bid: 0
                  });
    }
    function testfail_tend_empty() public {
        
        flip.tend(42, 0, 0);
    }
    function test_tend() public {
        uint id = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });

        ali.tend(id, 100 ether, 1 ether);
        
        asserteq(pie.balanceof(ali),   199 ether);
        
        asserteq(pie.balanceof(gal),     1 ether);

        bob.tend(id, 100 ether, 2 ether);
        
        asserteq(pie.balanceof(bob), 198 ether);
        
        asserteq(pie.balanceof(ali), 200 ether);
        
        asserteq(pie.balanceof(gal),   2 ether);

        flip.warp(5 hours);
        bob.deal(id);
        
        asserteq(vat.gems(bob), 100 ether);
    }
    function test_tend_later() public {
        uint id = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });
        flip.warp(5 hours);

        ali.tend(id, 100 ether, 1 ether);
        
        asserteq(pie.balanceof(ali), 199 ether);
        
        asserteq(pie.balanceof(gal),   1 ether);
    }
    function test_dent() public {
        uint id = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });
        ali.tend(id, 100 ether,  1 ether);
        bob.tend(id, 100 ether, 50 ether);

        ali.dent(id,  95 ether, 50 ether);
        
        asserteq(vat.gems(0xacab), 5 ether);
        asserteq(pie.balanceof(ali),  150 ether);
        asserteq(pie.balanceof(bob),  200 ether);
    }
    function test_beg() public {
        uint id = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });
        asserttrue( ali.try_tend(id, 100 ether, 1.00 ether));
        asserttrue(!bob.try_tend(id, 100 ether, 1.01 ether));
        
        asserttrue(!ali.try_tend(id, 100 ether, 1.01 ether));
        asserttrue( bob.try_tend(id, 100 ether, 1.07 ether));

        
        asserttrue( ali.try_tend(id, 100 ether, 49 ether));
        asserttrue( bob.try_tend(id, 100 ether, 50 ether));

        asserttrue(!ali.try_dent(id, 100 ether, 50 ether));
        asserttrue(!ali.try_dent(id,  99 ether, 50 ether));
        asserttrue( ali.try_dent(id,  95 ether, 50 ether));
    }
    function test_deal() public {
        uint id = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });

        
        ali.tend(id, 100 ether, 1 ether);
        asserttrue(!bob.try_deal(id));
        flip.warp(4.1 hours);
        asserttrue( bob.try_deal(id));

        uint ie = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });

        
        flip.warp(1 weeks);
        ali.tend(ie, 100 ether, 1 ether);
        asserttrue(!bob.try_deal(ie));
        flip.warp(1.1 weeks);
        asserttrue( bob.try_deal(ie));
    }
    function test_tick() public {
        
        uint id = flip.kick({ lot: 100 ether
                            , tab: 50 ether
                            , lad: address(0xacab)
                            , gal: gal
                            , bid: 0
                            });
        
        asserttrue(!ali.try_tick(id));
        
        flip.warp(2 weeks);
        
        asserttrue(!ali.try_tend(id, 100 ether, 1 ether));
        asserttrue(ali.try_tick(id));
        
        asserttrue( ali.try_tend(id, 100 ether, 1 ether));
    }
}



pragma solidity ^0.4.23;

contract vatlike {
    function dai(address) public view returns (int);
    function tab() public view returns (uint);
    function move(address,address,uint) public;
}

contract dai20 {    
    vatlike public vat;
    constructor(address vat_) public  { vat = vatlike(vat_); }

    function balanceof(address guy) public view returns (uint) {
        return uint(vat.dai(guy));
    }
    function totalsupply() public view returns (uint) {
        return vat.tab();
    }

    mapping (address => mapping (address => uint)) public allowance;
    function approve(address guy, uint wad) public returns (bool) {
        allowance[msg.sender][guy] += wad;
        return true;
    }

    function transferfrom(address src, address dst, uint wad) public returns (bool) {
        if (src != msg.sender && allowance[src][msg.sender] != uint(1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] = wad;
        }
        vat.move(src, dst, wad);
        return true;
    }
    function transfer(address guy, uint wad) public returns (bool) {
        vat.move(msg.sender, guy, wad);
        return true;
    }

    function approve(address guy) public { approve(guy, uint(1)); }
    function push(address guy, uint wad) public { transfer(guy, wad); }
    function move(address src, address dst, uint wad) public {
        transferfrom(src, dst, wad);
    }
}

pragma solidity ^0.4.23;

import ;
import ;

import ;

contract guy {
    flapper fuss;
    constructor(flapper fuss_) public {
        fuss = fuss_;
        dstoken(fuss.pie()).approve(fuss);
        dstoken(fuss.gem()).approve(fuss);
    }
    function tend(uint id, uint lot, uint bid) public {
        fuss.tend(id, lot, bid);
    }
    function deal(uint id) public {
        fuss.deal(id);
    }
    function try_tend(uint id, uint lot, uint bid)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(fuss).call(sig, id, lot, bid);
    }
    function try_deal(uint id)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(fuss).call(sig, id);
    }
}

contract gal {}

contract warpflap is flapper {
    uint48 _era; function warp(uint48 era_) public { _era = era_; }
    function era() public view returns (uint48) { return _era; }
    constructor(address pie_, address gem_) public flapper(pie_, gem_) {}
}

contract flaptest is dstest {
    warpflap fuss;
    dstoken pie;
    dstoken gem;

    guy  ali;
    guy  bob;
    gal  gal;

    function setup() public {
        pie = new dstoken();
        gem = new dstoken();

        fuss = new warpflap(pie, gem);

        fuss.warp(1 hours);

        ali = new guy(fuss);
        bob = new guy(fuss);
        gal = new gal();

        pie.approve(fuss);
        gem.approve(fuss);

        pie.mint(1000 ether);
        gem.mint(1000 ether);

        gem.push(ali, 200 ether);
        gem.push(bob, 200 ether);
    }
    function test_kick() public {
        asserteq(pie.balanceof(this), 1000 ether);
        asserteq(pie.balanceof(fuss),    0 ether);
        fuss.kick({ lot: 100 ether
                  , gal: gal
                  , bid: 0
                  });
        asserteq(pie.balanceof(this),  900 ether);
        asserteq(pie.balanceof(fuss),  100 ether);
    }
    function test_tend() public {
        uint id = fuss.kick({ lot: 100 ether
                            , gal: gal
                            , bid: 0
                            });
        
        asserteq(pie.balanceof(this), 900 ether);

        ali.tend(id, 100 ether, 1 ether);
        
        asserteq(gem.balanceof(ali), 199 ether);
        
        asserteq(gem.balanceof(gal),   1 ether);

        bob.tend(id, 100 ether, 2 ether);
        
        asserteq(gem.balanceof(bob), 198 ether);
        
        asserteq(gem.balanceof(ali), 200 ether);
        
        asserteq(gem.balanceof(gal),   2 ether);

        fuss.warp(5 weeks);
        bob.deal(id);
        
        asserteq(pie.balanceof(fuss),  0 ether);
        asserteq(pie.balanceof(bob), 100 ether);
    }
    function test_beg() public {
        uint id = fuss.kick({ lot: 100 ether
                            , gal: gal
                            , bid: 0
                            });
        asserttrue( ali.try_tend(id, 100 ether, 1.00 ether));
        asserttrue(!bob.try_tend(id, 100 ether, 1.01 ether));
        
        asserttrue(!ali.try_tend(id, 100 ether, 1.01 ether));
        asserttrue( bob.try_tend(id, 100 ether, 1.07 ether));
    }
}



pragma solidity ^0.4.23;

contract gemlike {
    function move(address,address,uint) public;
    function mint(address,uint) public;
}




contract flopper {
    gemlike public pie;
    gemlike public gem;

    uint256 public beg = 1.05 ether;  
    uint48  public ttl = 3.00 hours;  
    uint48  public tau = 1 weeks;     

    uint256 public kicks;

    struct bid {
        uint256 bid;
        uint256 lot;
        address guy;  
        uint48  tic;  
        uint48  end;
    }

    mapping (uint => bid) public bids;

    function era() public view returns (uint48) { return uint48(now); }

    uint constant wad = 10 ** 18;
    function mul(uint x, uint y) internal pure returns (uint z) {
        require((y == 0 || x * y / y == x) && (z = x * y + wad / 2) >= x * y);
        z = z / wad;
    }

    constructor(address pie_, address gem_) public {
        pie = gemlike(pie_);
        gem = gemlike(gem_);
    }

    function kick(address gal, uint lot, uint bid)
        public returns (uint)
    {
        uint id = ++kicks;

        bids[id].bid = bid;
        bids[id].lot = lot;
        bids[id].guy = gal;
        bids[id].end = era() + tau;

        return id;
    }
    function dent(uint id, uint lot, uint bid) public {
        require(bids[id].guy != 0);
        require(bids[id].tic > era() || bids[id].tic == 0);
        require(bids[id].end > era());

        require(bid == bids[id].bid);
        require(mul(beg, lot) <= bids[id].lot);

        pie.move(msg.sender, bids[id].guy, bid);

        bids[id].guy = msg.sender;
        bids[id].lot = lot;
        bids[id].tic = era() + ttl;
    }
    function deal(uint id) public {
        require(bids[id].tic < era() && bids[id].tic != 0 ||
                bids[id].end < era());
        gem.mint(bids[id].guy, bids[id].lot);
        delete bids[id];
    }
}



pragma solidity ^0.4.23;

contract gemlike {
    function move(address,address,uint) public;
}

contract vatlike {
    function move(address,address,uint) public;
    function flux(bytes32,address,int)  public;
}




contract flipper {
    vatlike public vat;
    bytes32 public ilk;

    uint256 public beg = 1.05 ether;  
    uint48  public ttl = 3.00 hours;  
    uint48  public tau = 1 weeks;     

    uint256 public kicks;

    struct bid {
        uint256 bid;
        uint256 lot;
        address guy;  
        uint48  tic;  
        uint48  end;
        address lad;
        address gal;
        uint256 tab;
    }

    mapping (uint => bid) public bids;

    function era() public view returns (uint48) { return uint48(now); }

    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
    uint constant wad = 10 ** 18;
    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), wad / 2) / wad;
    }

    constructor(address vat_, bytes32 ilk_) public {
        ilk = ilk_;
        vat = vatlike(vat_);
    }

    function kick(address lad, address gal, uint tab, uint lot, uint bid)
        public returns (uint)
    {
        uint id = ++kicks;

        bids[id].bid = bid;
        bids[id].lot = lot;
        bids[id].guy = msg.sender; 
        bids[id].end = era() + tau;
        bids[id].lad = lad;
        bids[id].gal = gal;
        bids[id].tab = tab;

        return id;
    }
    function tick(uint id) public {
        require(bids[id].end < era());
        require(bids[id].tic == 0);
        bids[id].end = era() + tau;
    }
    function tend(uint id, uint lot, uint bid) public {
        require(bids[id].guy != 0);
        require(bids[id].tic > era() || bids[id].tic == 0);
        require(bids[id].end > era());

        require(lot == bids[id].lot);
        require(bid <= bids[id].tab);
        require(bid >= wmul(beg, bids[id].bid) || bid == bids[id].tab);

        vat.move(msg.sender, bids[id].guy, bids[id].bid);
        vat.move(msg.sender, bids[id].gal, bid  bids[id].bid);

        bids[id].guy = msg.sender;
        bids[id].bid = bid;
        bids[id].tic = era() + ttl;
    }
    function dent(uint id, uint lot, uint bid) public {
        require(bids[id].guy != 0);
        require(bids[id].tic > era() || bids[id].tic == 0);
        require(bids[id].end > era());

        require(bid == bids[id].bid);
        require(bid == bids[id].tab);
        require(wmul(beg, lot) <= bids[id].lot);

        vat.move(msg.sender, bids[id].guy, bid);
        vat.flux(ilk, bids[id].lad, int(bids[id].lot  lot));

        bids[id].guy = msg.sender;
        bids[id].lot = lot;
        bids[id].tic = era() + ttl;
    }
    function deal(uint id) public {
        require(bids[id].tic < era() && bids[id].tic != 0 ||
                bids[id].end < era());
        vat.flux(ilk, bids[id].guy, int(bids[id].lot));
        delete bids[id];
    }
}



pragma solidity ^0.4.23;

contract gemlike {
    function move(address,address,uint) public;
}




contract flapper {
    gemlike public pie;
    gemlike public gem;

    uint256 public beg = 1.05 ether;  
    uint48  public ttl = 3.00 hours;  
    uint48  public tau = 1 weeks;     

    uint256 public kicks;

    struct bid {
        uint256 bid;
        uint256 lot;
        address guy;  
        uint48  tic;  
        uint48  end;
        address gal;
    }

    mapping (uint => bid) public bids;

    function era() public view returns (uint48) { return uint48(now); }

    uint constant wad = 10 ** 18;
    function mul(uint x, uint y) internal pure returns (uint z) {
        require((y == 0 || x * y / y == x) && (z = x * y + wad / 2) >= x * y);
        z = z / wad;
    }

    constructor(address pie_, address gem_) public {
        pie = gemlike(pie_);
        gem = gemlike(gem_);
    }

    function kick(address gal, uint lot, uint bid)
        public returns (uint)
    {
        uint id = ++kicks;
        pie.move(msg.sender, this, lot);

        bids[id].bid = bid;
        bids[id].lot = lot;
        bids[id].guy = msg.sender; 
        bids[id].end = era() + tau;
        bids[id].gal = gal;

        return id;
    }
    function tend(uint id, uint lot, uint bid) public {
        require(bids[id].guy != 0);
        require(bids[id].tic > era() || bids[id].tic == 0);
        require(bids[id].end > era());

        require(lot == bids[id].lot);
        require(bid >= mul(beg, bids[id].bid));

        gem.move(msg.sender, this, bid);
        gem.move(this, bids[id].gal, bid  bids[id].bid);
        gem.move(this, bids[id].guy, bids[id].bid);

        bids[id].guy = msg.sender;
        bids[id].bid = bid;
        bids[id].tic = era() + ttl;
    }
    function deal(uint id) public {
        require(bids[id].tic < era() && bids[id].tic != 0 ||
                bids[id].end < era());
        pie.move(this, bids[id].guy, bids[id].lot);
        delete bids[id];
    }
}

pragma solidity ^0.4.23;

import ;
import ;

import ;

contract guy {
    flopper fuss;
    constructor(flopper fuss_) public {
        fuss = fuss_;
        dstoken(fuss.pie()).approve(fuss);
        dstoken(fuss.gem()).approve(fuss);
    }
    function dent(uint id, uint lot, uint bid) public {
        fuss.dent(id, lot, bid);
    }
    function deal(uint id) public {
        fuss.deal(id);
    }
    function try_dent(uint id, uint lot, uint bid)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(fuss).call(sig, id, lot, bid);
    }
    function try_deal(uint id)
        public returns (bool)
    {
        bytes4 sig = bytes4(keccak256());
        return address(fuss).call(sig, id);
    }
}

contract gal {}

contract warpflop is flopper {
    uint48 _era; function warp(uint48 era_) public { _era = era_; }
    function era() public view returns (uint48) { return _era; }
    constructor(address pie_, address gem_) public flopper(pie_, gem_) {}
}

contract floptest is dstest {
    warpflop fuss;
    dstoken pie;
    dstoken gem;

    guy  ali;
    guy  bob;
    gal  gal;

    function setup() public {
        pie = new dstoken();
        gem = new dstoken();

        fuss = new warpflop(pie, gem);

        fuss.warp(1 hours);

        ali = new guy(fuss);
        bob = new guy(fuss);
        gal = new gal();

        pie.approve(fuss);
        gem.approve(fuss);

        pie.mint(1000 ether);

        pie.push(ali, 200 ether);
        pie.push(bob, 200 ether);
    }
    function test_kick() public {
        asserteq(pie.balanceof(this), 600 ether);
        asserteq(gem.balanceof(this),   0 ether);
        fuss.kick({ lot: uint(1)   
                  , gal: gal
                  , bid: 0
                  });
        
        asserteq(pie.balanceof(this), 600 ether);
        asserteq(gem.balanceof(this),   0 ether);
    }
    function test_dent() public {
        uint id = fuss.kick({ lot: uint(1)   
                            , gal: gal
                            , bid: 10 ether
                            });

        ali.dent(id, 100 ether, 10 ether);
        
        asserteq(pie.balanceof(ali), 190 ether);
        
        asserteq(pie.balanceof(gal),  10 ether);

        bob.dent(id, 80 ether, 10 ether);
        
        asserteq(pie.balanceof(bob), 190 ether);
        
        asserteq(pie.balanceof(ali), 200 ether);
        
        asserteq(pie.balanceof(gal), 10 ether);

        fuss.warp(5 weeks);
        asserteq(gem.totalsupply(),  0 ether);
        gem.setowner(fuss);
        bob.deal(id);
        
        asserteq(gem.totalsupply(), 80 ether);
        
        asserteq(gem.balanceof(bob), 80 ether);
    }
}

pragma solidity ^0.4.23;

import ;
import ;

import ;
import {dai20} from ;
import {adapter} from ;

import {warpflip as flipper} from ;
import {warpflop as flopper} from ;
import {warpflap as flapper} from ;


contract warpvat is vat {
    uint48 _era; function warp(uint48 era_) public { _era = era_; }
    function era() public view returns (uint48) { return _era; }

    function woe() public view returns (uint w) {
        w = dai[this] > 0 ? 0 : uint(dai[this]);
    }

    function suck(address guy, uint wad) public {
        dai[guy] += int(wad);
    }
}

contract frobtest is dstest {
    warpvat vat;
    dai20   pie;

    dstoken gold;
    bytes32 gold_ilk;

    adapter adapter;

    flipper flip;
    flopper flop;
    flapper flap;

    dstoken gov;

    function try_frob(bytes32 ilk, int ink, int art) public returns(bool) {
        bytes4 sig = bytes4(keccak256());
        return address(vat).call(sig, ilk, ink, art);
    }

    function ray(uint wad) internal pure returns (uint) {
        return wad * 10 ** 9;
    }

    function setup() public {
        gov = new dstoken();
        gov.mint(100 ether);

        vat = new warpvat();
        pie = new dai20(vat);

        flap = new flapper(vat, gov);
        flop = new flopper(vat, gov);
        gov.setowner(flop);

        vat.taff(flap);
        vat.toff(flop);

        gold = new dstoken();
        gold.mint(1000 ether);

        gold_ilk = vat.form();
        adapter = new adapter(vat, gold_ilk, gold);
        gold.approve(adapter);
        adapter.join(1000 ether);

        vat.file(gold_ilk, , ray(1 ether));
        vat.file(gold_ilk, , 1000 ether);
        vat.file(, 1000 ether);
        flip = new flipper(vat, gold_ilk);
        vat.tiff(gold_ilk, flip);

        gold.approve(vat);
        gov.approve(flap);
    }

    function test_join() public {
        gold.mint(500 ether);
        asserteq(gold.balanceof(this),     500 ether);
        asserteq(gold.balanceof(adapter), 1000 ether);
        adapter.join(500 ether);
        asserteq(gold.balanceof(this),       0 ether);
        asserteq(gold.balanceof(adapter), 1500 ether);
        adapter.exit(250 ether);
        asserteq(gold.balanceof(this),     250 ether);
        asserteq(gold.balanceof(adapter), 1250 ether);
    }
    function test_lock() public {
        asserteq(vat.ink(gold_ilk, this), 0 ether);
        asserteq(adapter.balanceof(this), 1000 ether);
        vat.frob(gold_ilk, 6 ether, 0);
        asserteq(vat.ink(gold_ilk, this), 6 ether);
        asserteq(adapter.balanceof(this), 994 ether);
        vat.frob(gold_ilk, 6 ether, 0);
        asserteq(vat.ink(gold_ilk, this), 0 ether);
        asserteq(adapter.balanceof(this), 1000 ether);
    }
    function test_calm() public {
        
        
        vat.file(gold_ilk, , 10 ether);
        asserttrue( try_frob(gold_ilk, 10 ether, 9 ether));
        
        asserttrue(!try_frob(gold_ilk,  0 ether, 2 ether));
    }
    function test_cool() public {
        
        
        vat.file(gold_ilk, , 10 ether);
        asserttrue(try_frob(gold_ilk, 10 ether,  8 ether));
        vat.file(gold_ilk, , 5 ether);
        
        asserttrue(try_frob(gold_ilk,  0 ether, 1 ether));
    }
    function test_safe() public {
        
        
        vat.frob(gold_ilk, 10 ether, 5 ether);                
        asserttrue(!try_frob(gold_ilk, 0 ether, 6 ether));  
    }
    function test_nice() public {
        
        

        vat.frob(gold_ilk, 10 ether, 10 ether);
        vat.file(gold_ilk, , ray(0.5 ether));  

        
        asserttrue(!try_frob(gold_ilk,  0 ether,  1 ether));
        
        asserttrue( try_frob(gold_ilk,  0 ether, 1 ether));
        
        asserttrue(!try_frob(gold_ilk, 1 ether,  0 ether));
        
        asserttrue( try_frob(gold_ilk,  1 ether,  0 ether));

        
        
        asserttrue(!this.try_frob(gold_ilk, 2 ether, 4 ether));
        
        asserttrue(!this.try_frob(gold_ilk,  5 ether,  1 ether));

        
        asserttrue( this.try_frob(gold_ilk, 1 ether, 4 ether));
        vat.file(gold_ilk, , ray(0.4 ether));  
        
        asserttrue( this.try_frob(gold_ilk,  5 ether, 1 ether));
    }

    function test_happy_bite() public {
        
        
        vat.file(gold_ilk, , ray(2.5 ether));
        vat.frob(gold_ilk,  40 ether, 100 ether);

        
        vat.file(gold_ilk, , ray(2 ether));  

        asserteq(vat.ink(gold_ilk, this),  40 ether);
        asserteq(vat.art(gold_ilk, this), 100 ether);
        asserteq(vat.woe(), 0 ether);
        asserteq(adapter.balanceof(this), 960 ether);
        uint id = vat.bite(gold_ilk, this);
        asserteq(vat.ink(gold_ilk, this), 0);
        asserteq(vat.art(gold_ilk, this), 0);
        asserteq(vat.sin(vat.era()), 100 ether);
        asserteq(adapter.balanceof(this), 960 ether);

        vat.file(, 100 ether);
        uint auction = vat.flip(id, 100 ether);  

        asserteq(pie.balanceof(vat),   0 ether);
        flip.tend(auction, 40 ether,   1 ether);
        asserteq(pie.balanceof(vat),   1 ether);
        flip.tend(auction, 40 ether, 100 ether);
        asserteq(pie.balanceof(vat), 100 ether);

        asserteq(pie.balanceof(this),       0 ether);
        asserteq(adapter.balanceof(this), 960 ether);
        vat.suck(this, 100 ether);  
        flip.dent(auction, 38 ether,  100 ether);
        asserteq(pie.balanceof(this), 100 ether);
        asserteq(pie.balanceof(vat),  100 ether);
        asserteq(adapter.balanceof(this), 962 ether);
        asserteq(vat.gem(gold_ilk, this), 962 ether);

        asserteq(vat.sin(vat.era()), 100 ether);
        asserteq(pie.balanceof(vat), 100 ether);
        vat.flog(vat.era());
        asserteq(vat.sin(vat.era()),   0 ether);
        asserteq(pie.balanceof(vat),   0 ether);
    }

    function test_floppy_bite() public {
        vat.file(gold_ilk, , ray(2.5 ether));
        vat.frob(gold_ilk,  40 ether, 100 ether);
        vat.file(gold_ilk, , ray(2 ether));  
        vat.bite(gold_ilk, this);

        asserteq(vat.sin(vat.era()), 100 ether);
        vat.flog(vat.era());
        asserteq(vat.woe(), 100 ether);

        vat.file(, 10 ether);
        uint f1 = vat.flop();
        asserteq(vat.woe(), 100 ether);
        flop.dent(f1, 1000 ether, 10 ether);
        asserteq(vat.woe(),  90 ether);

        asserteq(gov.balanceof(this),  100 ether);
        flop.warp(4 hours);
        flop.deal(f1);
        asserteq(gov.balanceof(this), 1100 ether);
    }

    function test_flappy_bite() public {
        
        vat.suck(vat, 100 ether);
        asserteq(pie.balanceof(vat),  100 ether);
        asserteq(gov.balanceof(this), 100 ether);

        vat.file(, 100 ether);
        uint id = vat.flap();

        asserteq(pie.balanceof(this),   0 ether);
        asserteq(gov.balanceof(this), 100 ether);
        flap.tend(id, 100 ether, 10 ether);
        flap.warp(4 hours);
        flap.deal(id);
        asserteq(pie.balanceof(this),   100 ether);
        asserteq(gov.balanceof(this),    90 ether);
    }
}



pragma solidity ^0.4.20;

contract gemlike {
    function move(address,address,uint) public;  
}

contract fluxing {
    function flux(bytes32,address,int) public;
    function gem(bytes32,address) public view returns (uint);
}

contract adapter {
    fluxing public vat;
    bytes32 public ilk;
    gemlike public gem;
    constructor(address vat_, bytes32 ilk_, address gem_) public {
        vat = fluxing(vat_);
        ilk = ilk_;
        gem = gemlike(gem_);
    }
    function join(uint wad) public {
        gem.move(msg.sender, this, wad);
        vat.flux(ilk, msg.sender, int(wad));
    }
    function exit(uint wad) public {
        gem.move(this, msg.sender, wad);
        vat.flux(ilk, msg.sender, int(wad));
    }
    function balanceof(address guy) public view returns (uint) {
        return vat.gem(ilk, guy);
    }
}

