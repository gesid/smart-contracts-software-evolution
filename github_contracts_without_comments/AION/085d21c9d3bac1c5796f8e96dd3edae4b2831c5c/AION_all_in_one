pragma solidity >=0.4.10;

import ;
import ;
import ;
import ;
import ;
import ;

contract token is finalizable, tokenreceivable, safemath, eventdefinitions, pausable {
    
    string constant public name = ;
    uint8 constant public decimals = 8;
    string constant public symbol = ;
    controller public controller;
    string public motd;
    event motd(string message);

    address public burnaddress; 
    bool public burnable = false;

    

    
    function setmotd(string _m) onlyowner {
        motd = _m;
        motd(_m);
    }

    function setcontroller(address _c) onlyowner notfinalized {
        controller = controller(_c);
    }

    

    function balanceof(address a) constant returns (uint) {
        return controller.balanceof(a);
    }

    function totalsupply() constant returns (uint) {
        return controller.totalsupply();
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
        return controller.allowance(_owner, _spender);
    }

    function transfer(address _to, uint _value) notpaused returns (bool success) {
        if (controller.transfer(msg.sender, _to, _value)) {
            transfer(msg.sender, _to, _value);
            return true;
        }
        return false;
    }

    function transferfrom(address _from, address _to, uint _value) notpaused returns (bool success) {
        if (controller.transferfrom(msg.sender, _from, _to, _value)) {
            transfer(_from, _to, _value);
            return true;
        }
        return false;
    }

    function approve(address _spender, uint _value) notpaused returns (bool success) {
        
        if (controller.approve(msg.sender, _spender, _value)) {
            approval(msg.sender, _spender, _value);
            return true;
        }
        return false;
    }

    function increaseapproval (address _spender, uint _addedvalue) notpaused returns (bool success) {
        if (controller.increaseapproval(msg.sender, _spender, _addedvalue)) {
            uint newval = controller.allowance(msg.sender, _spender);
            approval(msg.sender, _spender, newval);
            return true;
        }
        return false;
    }

    function decreaseapproval (address _spender, uint _subtractedvalue) notpaused returns (bool success) {
        if (controller.decreaseapproval(msg.sender, _spender, _subtractedvalue)) {
            uint newval = controller.allowance(msg.sender, _spender);
            approval(msg.sender, _spender, newval);
            return true;
        }
        return false;
    }

    
    
    
    

    

    modifier onlycontroller() {
        assert(msg.sender == address(controller));
        _;
    }

    
    
    

    function controllertransfer(address _from, address _to, uint _value) onlycontroller {
        transfer(_from, _to, _value);
    }

    function controllerapprove(address _owner, address _spender, uint _value) onlycontroller {
        approval(_owner, _spender, _value);
    }

    
    function controllerburn(address _from, bytes32 _to, uint256 _value) onlycontroller {
        burn(_from, _to, _value);
    }

    function controllerclaim(address _claimer, uint256 _value) onlycontroller {
        claimed(_claimer, _value);
    }

    
    function setburnaddress(address _address) onlycontroller {
        burnaddress = _address;
    }

    
    function enableburning() onlycontroller {
        burnable = true;
    }

    
    function disableburning() onlycontroller {
        burnable = false;
    }

    
    modifier burnenabled() {
        require(burnable == true);
        _;
    }

    
    function burn(bytes32 _to, uint _amount) notpaused burnenabled returns (bool success) {
        return controller.burn(msg.sender, _to, _amount);
    }

    
    function claimbyproof(bytes32[] data, bytes32[] proofs, uint256 number) notpaused burnenabled returns (bool success) {
        return controller.claimbyproof(msg.sender, data, proofs, number);
    }

    
    function claim() notpaused burnenabled returns (bool success) {
        return controller.claim(msg.sender);
    }
}


pragma solidity >=0.4.10;

contract owned {
    address public owner;
    address newowner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyowner() {
        require(msg.sender == owner);
        _;
    }

    function changeowner(address _newowner) onlyowner {
        newowner = _newowner;
    }

    function acceptownership() {
        if (msg.sender == newowner) {
            owner = newowner;
        }
    }
}


pragma solidity >=0.4.10;

import ;
import ;
import ;
import ;

contract ledger is owned, safemath, finalizable {
    controller public controller;
    mapping(address => uint) public balanceof;
    mapping (address => mapping (address => uint)) public allowance;
    uint public totalsupply;
    uint public mintingnonce;
    bool public mintingstopped;

    
    mapping(uint256 => bytes32) public proofs;

    
    mapping(address => uint256) public locked;

    
    mapping(bytes32 => bytes32) public metadata;

    
    address public burnaddress;

    
    mapping(address => bool) public bridgenodes;

    

    function ledger() {
    }

    function setcontroller(address _controller) onlyowner notfinalized {
        controller = controller(_controller);
    }

    
    function stopminting() onlyowner {
        mintingstopped = true;
    }

    
    function multimint(uint nonce, uint256[] bits) onlyowner {
        require(!mintingstopped);
        if (nonce != mintingnonce) return;
        mintingnonce += 1;
        uint256 lomask = (1 << 96)  1;
        uint created = 0;
        for (uint i=0; i<bits.length; i++) {
            address a = address(bits[i]>>96);
            uint value = bits[i]&lomask;
            balanceof[a] = balanceof[a] + value;
            controller.ledgertransfer(0, a, value);
            created += value;
        }
        totalsupply += created;
    }

    

    modifier onlycontroller() {
        require(msg.sender == address(controller));
        _;
    }

    function transfer(address _from, address _to, uint _value) onlycontroller returns (bool success) {
        if (balanceof[_from] < _value) return false;

        balanceof[_from] = safesub(balanceof[_from], _value);
        balanceof[_to] = safeadd(balanceof[_to], _value);
        return true;
    }

    function transferfrom(address _spender, address _from, address _to, uint _value) onlycontroller returns (bool success) {
        if (balanceof[_from] < _value) return false;

        var allowed = allowance[_from][_spender];
        if (allowed < _value) return false;

        balanceof[_to] = safeadd(balanceof[_to], _value);
        balanceof[_from] = safesub(balanceof[_from], _value);
        allowance[_from][_spender] = safesub(allowed, _value);
        return true;
    }

    function approve(address _owner, address _spender, uint _value) onlycontroller returns (bool success) {
        
        if ((_value != 0) && (allowance[_owner][_spender] != 0)) {
            return false;
        }

        allowance[_owner][_spender] = _value;
        return true;
    }

    function increaseapproval (address _owner, address _spender, uint _addedvalue) onlycontroller returns (bool success) {
        uint oldvalue = allowance[_owner][_spender];
        allowance[_owner][_spender] = safeadd(oldvalue, _addedvalue);
        return true;
    }

    function decreaseapproval (address _owner, address _spender, uint _subtractedvalue) onlycontroller returns (bool success) {
        uint oldvalue = allowance[_owner][_spender];
        if (_subtractedvalue > oldvalue) {
            allowance[_owner][_spender] = 0;
        } else {
            allowance[_owner][_spender] = safesub(oldvalue, _subtractedvalue);
        }
        return true;
    }


    function setproof(uint256 _key, bytes32 _proof) onlycontroller {
        proofs[_key] = _proof;
    }

    function setlocked(address _key, uint256 _value) onlycontroller {
        locked[_key] = _value;
    }

    function setmetadata(bytes32 _key, bytes32 _value) onlycontroller {
        metadata[_key] = _value;
    }

    

    
    function setburnaddress(address _address) onlycontroller {
        burnaddress = _address;
    }

    function setbridgenode(address _address, bool enabled) onlycontroller {
        bridgenodes[_address] = enabled;
    }
}



pragma solidity >=0.4.10;

contract itoken {
    function transfer(address _to, uint _value) returns (bool);
    function balanceof(address owner) returns(uint);
}


pragma solidity >=0.4.10;

import ;

contract finalizable is owned {
    bool public finalized;

    function finalize() onlyowner {
        finalized = true;
    }

    modifier notfinalized() {
        require(!finalized);
        _;
    }
}


pragma solidity >=0.4.10;

import ;
import ;



contract tokenreceivable is owned {
    function claimtokens(address _token, address _to) onlyowner returns (bool) {
        itoken token = itoken(_token);
        return token.transfer(_to, token.balanceof(this));
    }
}

pragma solidity ^0.4.4;

contract migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function migrations() {
    owner = msg.sender;
  }

  function setcompleted(uint completed) restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted {
    migrations upgraded = migrations(new_address);
    upgraded.setcompleted(last_completed_migration);
  }
}



pragma solidity >=0.4.10;


contract safemath {
    function safemul(uint a, uint b) internal returns (uint) {
        uint c = a * b;
        require(a == 0 || c / a == b);
        return c;
    }

    function safesub(uint a, uint b) internal returns (uint) {
        require(b <= a);
        return a  b;
    }

    function safeadd(uint a, uint b) internal returns (uint) {
        uint c = a + b;
        require(c>=a && c>=b);
        return c;
    }
}


pragma solidity >=0.4.10;

import ;

contract pausable is owned {
    bool public paused;

    function pause() onlyowner {
        paused = true;
    }

    function unpause() onlyowner {
        paused = false;
    }

    modifier notpaused() {
        require(!paused);
        _;
    }
}


pragma solidity >=0.4.10;

import ;
import ;
import ;
import ;
import ;


contract controller is owned, finalizable, controllereventdefinitions {
    ledger public ledger;
    token public token;
    address public burnaddress;

    function controller() {
    }

    


    function settoken(address _token) onlyowner {
        token = token(_token);
    }

    function setledger(address _ledger) onlyowner {
        ledger = ledger(_ledger);
    }

    
    function setburnaddress(address _address) onlyowner {
        burnaddress = _address;
        ledger.setburnaddress(_address);
        token.setburnaddress(_address);
    }

    modifier onlytoken() {
        require(msg.sender == address(token));
        _;
    }

    modifier onlyledger() {
        require(msg.sender == address(ledger));
        _;
    }

    function totalsupply() constant returns (uint) {
        return ledger.totalsupply();
    }

    function balanceof(address _a) constant returns (uint) {
        return ledger.balanceof(_a);
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
        return ledger.allowance(_owner, _spender);
    }

    

    
    
    
    function ledgertransfer(address from, address to, uint val) onlyledger {
        token.controllertransfer(from, to, val);
    }

    

    function transfer(address _from, address _to, uint _value) onlytoken returns (bool success) {
        return ledger.transfer(_from, _to, _value);
    }

    function transferfrom(address _spender, address _from, address _to, uint _value) onlytoken returns (bool success) {
        return ledger.transferfrom(_spender, _from, _to, _value);
    }

    function approve(address _owner, address _spender, uint _value) onlytoken returns (bool success) {
        return ledger.approve(_owner, _spender, _value);
    }

    function increaseapproval (address _owner, address _spender, uint _addedvalue) onlytoken returns (bool success) {
        return ledger.increaseapproval(_owner, _spender, _addedvalue);
    }

    function decreaseapproval (address _owner, address _spender, uint _subtractedvalue) onlytoken returns (bool success) {
        return ledger.decreaseapproval(_owner, _spender, _subtractedvalue);
    }

    

    
    function enableburning() onlyowner {
        token.enableburning();
    }

    
    function disableburning() onlyowner {
        token.disableburning();
    }

    

     
    function burn(address _from, bytes32 _to, uint _amount) onlytoken returns (bool success) {
        if (ledger.transfer(_from, burnaddress, _amount)) {
            controllerburn(_from, _to, _amount);
            token.controllerburn(_from, _to, _amount);
            return true;
        }
        return false;
    }

    
    function claimbyproof(address _claimer, bytes32[] data, bytes32[] proofs, uint256 number)
        onlytoken
        returns (bool success) {
        return false;
    }

    
    function claim(address _claimer) onlytoken returns (bool success) {
        return false;
    }
}
pragma solidity >=0.4.10;


contract dummytoken {

    event debugtransferevent();
    event debugbalanceofevent();

    function transfer(address _to, uint _value) returns (bool) {
        debugtransferevent();
        return true;
    }

    function balanceof(address owner) returns(uint) {
        debugbalanceofevent();
        return 42;
    }
}


pragma solidity >=0.4.10;

contract eventdefinitions {
    event transfer(address indexed from, address indexed to, uint value);
    event approval(address indexed owner, address indexed spender, uint value);
    event burn(address indexed from, bytes32 indexed to, uint value);
    event claimed(address indexed claimer, uint value);
}
pragma solidity >=0.4.10;

contract controllereventdefinitions {
    
    event controllerburn(address indexed from, bytes32 indexed to, uint value);
}

pragma solidity >=0.4.10;

import ;
import ;


contract receiver {
    event startsale();
    event endsale();
    event etherin(address from, uint amount);

    address public owner;    
    address public newowner; 
    string public notice;    

    sale public sale;

    function receiver() {
        owner = msg.sender;
    }

    modifier onlyowner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlysale() {
        require(msg.sender == address(sale));
        _;
    }

    function live() constant returns(bool) {
        return sale.live();
    }

    
    function start() onlysale {
        startsale();
    }

    
    function end() onlysale {
        endsale();
    }

    function () payable {
        
        etherin(msg.sender, msg.value);
        require(sale.call.value(msg.value)());
    }

    
    function changeowner(address next) onlyowner {
        newowner = next;
    }

    
    function acceptownership() {
        require(msg.sender == newowner);
        owner = msg.sender;
        newowner = 0;
    }

    
    function setnotice(string note) onlyowner {
        notice = note;
    }

    
    function setsale(address s) onlyowner {
        sale = sale(s);
    }

    
    
    

    
    function withdrawtoken(address token) onlyowner {
        token t = token(token);
        require(t.transfer(msg.sender, t.balanceof(this)));
    }

    
    function refundtoken(address token, address sender, uint amount) onlyowner {
        token t = token(token);
        require(t.transfer(sender, amount));
    }
}



pragma solidity>=0.4.10;


contract token {
    function balanceof(address addr) returns(uint);
    function transfer(address to, uint amount) returns(bool);
}

pragma solidity >=0.4.10;

import ;
import ;

contract sale {
    
    
    
    uint public constant softcap_time = 4 hours;

    address public owner;    
    address public newowner; 
    string public notice;    
    uint public start;       
    uint public end;         
    uint public cap;         
    uint public softcap;     
    bool public live;        

    receiver public r0;
    receiver public r1;
    receiver public r2;

    function sale() {
        owner = msg.sender;
    }

    modifier onlyowner() {
        require(msg.sender == owner);
        _;
    }

    
    function emitbegin() internal {
        r0.start();
        r1.start();
        r2.start();
    }

    
    function emitend() internal {
        r0.end();
        r1.end();
        r2.end();
    }

    function () payable {
        
        require(msg.sender == address(r0) || msg.sender == address(r1) || msg.sender == address(r2));
        require(block.timestamp >= start);

        
        
        if (this.balance > softcap && block.timestamp < end && (end  block.timestamp) > softcap_time)
            end = block.timestamp + softcap_time;

        
        
        
        
        
        
        if (block.timestamp > end || this.balance > cap) {
            require(live);
            live = false;
            emitend();
        } else if (!live) {
            live = true;
            emitbegin();
        }
    }

    function init(uint _start, uint _end, uint _cap, uint _softcap) onlyowner {
        start = _start;
        end = _end;
        cap = _cap;
        softcap = _softcap;
    }

    function setreceivers(address a, address b, address c) onlyowner {
        r0 = receiver(a);
        r1 = receiver(b);
        r2 = receiver(c);
    }

    
    function changeowner(address next) onlyowner {
        newowner = next;
    }

    
    function acceptownership() {
        require(msg.sender == newowner);
        owner = msg.sender;
        newowner = 0;
    }

    
    function setnotice(string note) onlyowner {
        notice = note;
    }

    
    function withdraw() onlyowner {
        msg.sender.transfer(this.balance);
    }

    
    function withdrawsome(uint value) onlyowner {
        require(value <= this.balance);
        msg.sender.transfer(value);
    }

    
    function withdrawtoken(address token) onlyowner {
        token t = token(token);
        require(t.transfer(msg.sender, t.balanceof(this)));
    }

    
    function refundtoken(address token, address sender, uint amount) onlyowner {
        token t = token(token);
        require(t.transfer(sender, amount));
    }
}


pragma solidity ^0.4.4;

contract migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function migrations() {
    owner = msg.sender;
  }

  function setcompleted(uint completed) restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted {
    migrations upgraded = migrations(new_address);
    upgraded.setcompleted(last_completed_migration);
  }
}

pragma solidity >=0.4.10;

import ;


contract controllermock is controller {
    
}
pragma solidity >=0.4.10;

import ;


contract tokenmock is token {
    
}
pragma solidity >=0.4.10;

import ;


contract ledgermock is ledger {
    
}

pragma solidity ^0.4.15;

contract owned {
    address public owner;
    address public newowner;

    
    event changedowner(address indexed new_owner);

    

    function owned() {
        owner = msg.sender;
    }

    modifier onlyowner() {
        require(msg.sender == owner);
        _;
    }

    function changeowner(address _newowner) onlyowner external {
        newowner = _newowner;
    }

    function acceptownership() external {
        if (msg.sender == newowner) {
            owner = newowner;
            newowner = 0x0;
            changedowner(owner);
        }
    }
}

contract iowned {
    function owner() returns (address);
    function changeowner(address);
    function acceptownership();
}
pragma solidity ^0.4.4;

contract migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function migrations() {
    owner = msg.sender;
  }

  function setcompleted(uint completed) restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted {
    migrations upgraded = migrations(new_address);
    upgraded.setcompleted(last_completed_migration);
  }
}


pragma solidity ^0.4.15;

import {owned} from ;


contract administrator is owned {
    
    mapping(address => bool) public admins;

    
    modifier onlyadministrator(address _address) {
        require(_address == owner || admins[_address]);
        _;
    }

    function addadmin(address _address)
        onlyowner
        external
    {
        require(_address != owner && !(admins[_address]));
        admins[_address] = true;
    }

    function deladmin(address _address)
        onlyowner
        external
    {
        require(_address != owner && admins[_address]);
        admins[_address] = false;
    }
}

pragma solidity >=0.4.10;

contract token {
	function transferfrom(address from, address to, uint amount) returns(bool);
	function transfer(address to, uint amount) returns(bool);
	function balanceof(address addr) constant returns(uint);
}

import {owned} from ;


contract savings is owned {
	
	uint public periods;

	
	uint public t0special;

	uint constant public intervalsecs = 30 days;
	uint constant public precision = 10 ** 18;


	
	event withdraws(address indexed who, uint amount);
	event deposit(address indexed who, uint amount);

	bool public inited;
	bool public locked;
	uint public startblocktimestamp = 0;

	token public token;

	
	mapping (address => uint) public deposited;

	
	uint public totalfv;

	
	uint public remainder;

	
	uint public total;

	
	mapping (address => uint256) public withdrawn;

	bool public nullified;

	modifier notnullified() { require(!nullified); _; }

	modifier prelock() { require(!locked && startblocktimestamp == 0); _; }

	
	modifier postlock() { require(locked); _; }

	
	modifier prestart() { require(locked && startblocktimestamp == 0); _; }

	
	modifier poststart() { require(locked && startblocktimestamp != 0); _; }

	
	modifier notinitialized() { require(!inited); _; }

	
	modifier initialized() { require(inited); _; }

	
	function() {
		revert();
	}

	
	function nullify() onlyowner {
		nullified = true;
	}

	
	function init(uint _periods, uint _t0special) onlyowner notinitialized {
		require(_periods != 0);
		periods = _periods;
		t0special = _t0special;
	}

	function finalizeinit() onlyowner notinitialized {
		inited = true;
	}

	function settoken(address tok) onlyowner {
		token = token(tok);
	}

	
	function lock() onlyowner {
		locked = true;
	}

	
	function start(uint _startblocktimestamp) onlyowner initialized prestart {
		startblocktimestamp = _startblocktimestamp;
		uint256 tokenbalance = token.balanceof(this);
		total = tokenbalance;
		remainder = tokenbalance;
	}

	
	function isstarted() constant returns(bool) {
		return locked && startblocktimestamp != 0;
	}

	
	

	
	function refundtokens(address addr, uint amount) onlyowner prelock {
		token.transfer(addr, amount);
	}


	
	function updatetotal() onlyowner postlock {
		uint current = token.balanceof(this);
		require(current >= remainder); 

		uint difference = (current  remainder);
		total += difference;
		remainder = current;
	}

	
	function periodat(uint _blocktimestamp) constant returns(uint) {
		
		if (startblocktimestamp > _blocktimestamp)
			return 0;

		
		uint p = ((_blocktimestamp  startblocktimestamp) / intervalsecs) + 1;
		if (p > periods)
			p = periods;
		return p;
	}

	
	
	function period() constant returns(uint) {
		return periodat(block.timestamp);
	}

	
	
	
	function deposit(uint tokens) onlyowner notnullified {
		depositto(msg.sender, tokens);
	}


	function depositto(address beneficiary, uint tokens) onlyowner prelock notnullified {
		require(token.transferfrom(msg.sender, this, tokens));
	    deposited[beneficiary] += tokens;
		totalfv += tokens;
		deposit(beneficiary, tokens);
	}

	
	function bulkdepositto(uint256[] bits) onlyowner {
		uint256 lomask = (1 << 96)  1;
		for (uint i=0; i<bits.length; i++) {
			address a = address(bits[i]>>96);
			uint val = bits[i]&lomask;
			depositto(a, val);
		}
	}

	
	
	function withdraw() notnullified returns(bool) {
		return withdrawto(msg.sender);
	}

	
	function availableforwithdrawalat(uint256 blocktimestamp) constant returns (uint256) {
		
		return ((t0special + periodat(blocktimestamp)) * precision) / (t0special + periods);
	}

	
	function _withdrawto(uint _deposit, uint _withdrawn, uint _blocktimestamp, uint _total) constant returns (uint) {
		uint256 fraction = availableforwithdrawalat(_blocktimestamp);

		
		uint256 withdrawable = ((_deposit * fraction * _total) / totalfv) / precision;

		
		if (withdrawable > _withdrawn) {
			return withdrawable  _withdrawn;
		}
		return 0;
	}

	
	function withdrawto(address addr) poststart notnullified returns (bool) {
		uint _d = deposited[addr];
		uint _w = withdrawn[addr];

		uint diff = _withdrawto(_d, _w, block.timestamp, total);

		
		if (diff == 0) {
			return false;
		}

		
		require((diff + _w) <= ((_d * total) / totalfv));

		
		require(token.transfer(addr, diff));

		withdrawn[addr] += diff;
		remainder = diff;
		withdraws(addr, diff);
		return true;
	}

	
	function bulkwithdraw(address[] addrs) notnullified {
		for (uint i=0; i<addrs.length; i++)
			withdrawto(addrs[i]);
	}

	
	
	
	
	uint public mintingnonce;
	function multimint(uint nonce, uint256[] bits) onlyowner prelock {

		if (nonce != mintingnonce) return;
		mintingnonce += 1;
		uint256 lomask = (1 << 96)  1;
		uint sum = 0;
		for (uint i=0; i<bits.length; i++) {
			address a = address(bits[i]>>96);
			uint value = bits[i]&lomask;
			deposited[a] += value;
			sum += value;
			deposit(a, value);
		}
		totalfv += sum;
	}
}

pragma solidity ^0.4.4;

contract migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function migrations() {
    owner = msg.sender;
  }

  function setcompleted(uint completed) restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted {
    migrations upgraded = migrations(new_address);
    upgraded.setcompleted(last_completed_migration);
  }
}

pragma solidity >=0.4.10;

import ;


contract savingsmock is savings {
    
    uint constant public periods = 4;
    uint constant public interval = 10;
}
pragma solidity >=0.4.10;

import ;


contract controllermock is controller {
    
}
pragma solidity >=0.4.10;

import ;


contract tokenmock is token {
    
}

contract dummymock {
    uint256 public counter;

    function increment() {
        counter = counter + 1;
    }
}
pragma solidity >=0.4.10;

import ;


contract ledgermock is ledger {
    
}
