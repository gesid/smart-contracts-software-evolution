pragma solidity ^0.4.24;
pragma experimental ;




contract migrations {
    uint public last_completed_migration;

    function setcompleted(uint completed) public {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public {
        migrations upgraded = migrations(new_address);
        upgraded.setcompleted(last_completed_migration);
    }
}

pragma solidity ^0.4.24;
pragma experimental ;


import ;



contract paximplementationv2 {

    

    using safemath for uint256;

    

    
    bool private initialized = false;

    
    mapping(address => uint256) internal balances;
    uint256 internal totalsupply_;
    string public constant name = ; 
    string public constant symbol = ; 
    uint8 public constant decimals = 18; 

    
    mapping(address => mapping(address => uint256)) internal allowed;

    
    address public owner;

    
    bool public paused = false;

    
    address public assetprotectionrole;
    mapping(address => bool) internal frozen;

    
    address public supplycontroller;

    
    address public proposedowner;

    
    address public betadelegatewhitelister;
    mapping(address => bool) internal betadelegatewhitelist;
    mapping(address => uint256) internal nextseqs;
    
    string constant internal eip191_header = ;
    
    bytes32 constant internal eip712_domain_separator_schema_hash = keccak256(
        
    );
    bytes32 constant internal eip712_delegated_transfer_schema_hash = keccak256(
        
    );
    
    
    bytes32 public eip712_domain_hash;

    

    
    event transfer(address indexed from, address indexed to, uint256 value);

    
    event approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    
    event ownershiptransferproposed(
        address indexed currentowner,
        address indexed proposedowner
    );
    event ownershiptransferdisregarded(
        address indexed oldproposedowner
    );
    event ownershiptransferred(
        address indexed oldowner,
        address indexed newowner
    );

    
    event pause();
    event unpause();

    
    event addressfrozen(address indexed addr);
    event addressunfrozen(address indexed addr);
    event frozenaddresswiped(address indexed addr);
    event assetprotectionroleset (
        address indexed oldassetprotectionrole,
        address indexed newassetprotectionrole
    );

    
    event supplyincreased(address indexed to, uint256 value);
    event supplydecreased(address indexed from, uint256 value);
    event supplycontrollerset(
        address indexed oldsupplycontroller,
        address indexed newsupplycontroller
    );

    
    event betadelegatedtransfer(
        address indexed from, address indexed to, uint256 value, uint256 seq, uint256 fee
    );
    event betadelegatewhitelisterset(
        address indexed oldwhitelister,
        address indexed newwhitelister
    );
    event betadelegatewhitelisted(address indexed newdelegate);
    event betadelegateunwhitelisted(address indexed olddelegate);

    

    

    
    function initialize() public {
        require(!initialized, );
        owner = msg.sender;
        assetprotectionrole = address(0);
        totalsupply_ = 0;
        supplycontroller = msg.sender;
        initialized = true;
    }

    
    constructor() public {
        initialize();
        pause();
        
        initializedomainseparator();
    }

    
    function initializedomainseparator() public {
        
        eip712_domain_hash = keccak256(abi.encodepacked(
                eip712_domain_separator_schema_hash,
                keccak256(bytes(name)),
                bytes32(address(this))
            ));
        proposedowner = address(0);
    }

    

    
    function totalsupply() public view returns (uint256) {
        return totalsupply_;
    }

    
    function transfer(address _to, uint256 _value) public whennotpaused returns (bool) {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[msg.sender], );
        require(_value <= balances[msg.sender], );

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceof(address _addr) public view returns (uint256) {
        return balances[_addr];
    }

    

    
    function transferfrom(
        address _from,
        address _to,
        uint256 _value
    )
    public
    whennotpaused
    returns (bool)
    {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[_from] && !frozen[msg.sender], );
        require(_value <= balances[_from], );
        require(_value <= allowed[_from][msg.sender], );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public whennotpaused returns (bool) {
        require(!frozen[_spender] && !frozen[msg.sender], );
        allowed[msg.sender][_spender] = _value;
        emit approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    

    
    modifier onlyowner() {
        require(msg.sender == owner, );
        _;
    }

    
    function proposeowner(address _proposedowner) public onlyowner {
        require(_proposedowner != address(0), );
        require(msg.sender != _proposedowner, );
        proposedowner = _proposedowner;
        emit ownershiptransferproposed(owner, proposedowner);
    }
    
    function disregardproposeowner() public {
        require(msg.sender == proposedowner || msg.sender == owner, );
        require(proposedowner != address(0), );
        address _oldproposedowner = proposedowner;
        proposedowner = address(0);
        emit ownershiptransferdisregarded(_oldproposedowner);
    }
    
    function claimownership() public {
        require(msg.sender == proposedowner, );
        address _oldowner = owner;
        owner = proposedowner;
        proposedowner = address(0);
        emit ownershiptransferred(_oldowner, owner);
    }

    
    function reclaimpax() external onlyowner {
        uint256 _balance = balances[this];
        balances[this] = 0;
        balances[owner] = balances[owner].add(_balance);
        emit transfer(this, owner, _balance);
    }

    

    
    modifier whennotpaused() {
        require(!paused, );
        _;
    }

    
    function pause() public onlyowner {
        require(!paused, );
        paused = true;
        emit pause();
    }

    
    function unpause() public onlyowner {
        require(paused, );
        paused = false;
        emit unpause();
    }

    

    
    function setassetprotectionrole(address _newassetprotectionrole) public {
        require(msg.sender == assetprotectionrole || msg.sender == owner, );
        emit assetprotectionroleset(assetprotectionrole, _newassetprotectionrole);
        assetprotectionrole = _newassetprotectionrole;
    }

    modifier onlyassetprotectionrole() {
        require(msg.sender == assetprotectionrole, );
        _;
    }

    
    function freeze(address _addr) public onlyassetprotectionrole {
        require(!frozen[_addr], );
        frozen[_addr] = true;
        emit addressfrozen(_addr);
    }

    
    function unfreeze(address _addr) public onlyassetprotectionrole {
        require(frozen[_addr], );
        frozen[_addr] = false;
        emit addressunfrozen(_addr);
    }

    
    function wipefrozenaddress(address _addr) public onlyassetprotectionrole {
        require(frozen[_addr], );
        uint256 _balance = balances[_addr];
        balances[_addr] = 0;
        totalsupply_ = totalsupply_.sub(_balance);
        emit frozenaddresswiped(_addr);
        emit supplydecreased(_addr, _balance);
        emit transfer(_addr, address(0), _balance);
    }

    
    function isfrozen(address _addr) public view returns (bool) {
        return frozen[_addr];
    }

    

    
    function setsupplycontroller(address _newsupplycontroller) public {
        require(msg.sender == supplycontroller || msg.sender == owner, );
        require(_newsupplycontroller != address(0), );
        emit supplycontrollerset(supplycontroller, _newsupplycontroller);
        supplycontroller = _newsupplycontroller;
    }

    modifier onlysupplycontroller() {
        require(msg.sender == supplycontroller, );
        _;
    }

    
    function increasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        totalsupply_ = totalsupply_.add(_value);
        balances[supplycontroller] = balances[supplycontroller].add(_value);
        emit supplyincreased(supplycontroller, _value);
        emit transfer(address(0), supplycontroller, _value);
        return true;
    }

    
    function decreasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        require(_value <= balances[supplycontroller], );
        balances[supplycontroller] = balances[supplycontroller].sub(_value);
        totalsupply_ = totalsupply_.sub(_value);
        emit supplydecreased(supplycontroller, _value);
        emit transfer(supplycontroller, address(0), _value);
        return true;
    }

    

    
    
        return nextseqs[target];
    }

    
    function betadelegatedtransfer(
        bytes sig, address to, uint256 value, uint256 fee, uint256 seq, uint256 deadline
    ) public returns (bool) {
        require(sig.length == 65, );
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        require(_betadelegatedtransfer(r, s, v, to, value, fee, seq, deadline), );
        return true;
    }

    
    function _betadelegatedtransfer(
        bytes32 r, bytes32 s, uint8 v, address to, uint256 value, uint256 fee, uint256 seq, uint256 deadline
    ) internal whennotpaused returns (bool) {
        require(betadelegatewhitelist[msg.sender], );
        require(value > 0 || fee > 0, );
        require(block.number <= deadline, );
        
        require(uint256(s) <= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0, );
        require(v == 27 || v == 28, );

        
        bytes32 delegatedtransferhash = keccak256(abi.encodepacked(
                eip712_delegated_transfer_schema_hash, bytes32(to), value, fee, seq, deadline
            ));
        bytes32 hash = keccak256(abi.encodepacked(eip191_header, eip712_domain_hash, delegatedtransferhash));
        address _from = ecrecover(hash, v, r, s);

        require(_from != address(0), );
        require(to != address(0), );
        require(!frozen[to] && !frozen[_from] && !frozen[msg.sender], );
        require(value.add(fee) <= balances[_from], );
        require(nextseqs[_from] == seq, );

        nextseqs[_from] = nextseqs[_from].add(1);
        balances[_from] = balances[_from].sub(value.add(fee));
        if (fee != 0) {
            balances[msg.sender] = balances[msg.sender].add(fee);
            emit transfer(_from, msg.sender, fee);
        }
        balances[to] = balances[to].add(value);
        emit transfer(_from, to, value);

        emit betadelegatedtransfer(_from, to, value, seq, fee);
        return true;
    }

    
    function betadelegatedtransferbatch(
        bytes32[] r, bytes32[] s, uint8[] v, address[] to, uint256[] value, uint256[] fee, uint256[] seq, uint256[] deadline
    ) public returns (bool) {
        require(r.length == s.length && r.length == v.length && r.length == to.length && r.length == value.length, );
        require(r.length == fee.length && r.length == seq.length && r.length == deadline.length, );

        for (uint i = 0; i < r.length; i++) {
            require(
                _betadelegatedtransfer(r[i], s[i], v[i], to[i], value[i], fee[i], seq[i], deadline[i]),
                
            );
        }
        return true;
    }

    
    function iswhitelistedbetadelegate(address _addr) public view returns (bool) {
        return betadelegatewhitelist[_addr];
    }

    
    function setbetadelegatewhitelister(address _newwhitelister) public {
        require(msg.sender == betadelegatewhitelister || msg.sender == owner, );
        betadelegatewhitelister = _newwhitelister;
        emit betadelegatewhitelisterset(betadelegatewhitelister, _newwhitelister);
    }

    modifier onlybetadelegatewhitelister() {
        require(msg.sender == betadelegatewhitelister, );
        _;
    }

    
    function whitelistbetadelegate(address _addr) public onlybetadelegatewhitelister {
        require(!betadelegatewhitelist[_addr], );
        betadelegatewhitelist[_addr] = true;
        emit betadelegatewhitelisted(_addr);
    }

    
    function unwhitelistbetadelegate(address _addr) public onlybetadelegatewhitelister {
        require(betadelegatewhitelist[_addr], );
        betadelegatewhitelist[_addr] = false;
        emit betadelegateunwhitelisted(_addr);
    }
}

pragma solidity ^0.4.24;

import ;
import ;


contract upgradeabilityproxy is proxy {
    
    event upgraded(address implementation);

    
    bytes32 private constant implementation_slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;

    
    constructor(address _implementation) public {
        assert(implementation_slot == keccak256());

        _setimplementation(_implementation);
    }

    
    function _implementation() internal view returns (address impl) {
        bytes32 slot = implementation_slot;
        assembly {
            impl := sload(slot)
        }
    }

    
    function _upgradeto(address newimplementation) internal {
        _setimplementation(newimplementation);
        emit upgraded(newimplementation);
    }

    
    function _setimplementation(address newimplementation) private {
        require(addressutils.iscontract(newimplementation), );

        bytes32 slot = implementation_slot;

        assembly {
            sstore(slot, newimplementation)
        }
    }
}

pragma solidity ^0.4.24;



library safemath {
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a  b;

        return c;
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }
}

pragma solidity ^0.4.24;


contract proxy {
    
    function () payable external {
        _fallback();
    }

    
    function _implementation() internal view returns (address);

    
    function _delegate(address implementation) internal {
        assembly {
        
        
        
            calldatacopy(0, 0, calldatasize)

        
        
            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

        
            returndatacopy(0, 0, returndatasize)

            switch result
            
            case 0 { revert(0, returndatasize) }
            default { return(0, returndatasize) }
        }
    }

    
    function _willfallback() internal {
    }

    
    function _fallback() internal {
        _willfallback();
        _delegate(_implementation());
    }
}

pragma solidity ^0.4.24;



library addressutils {

    
    function iscontract(address addr) internal view returns (bool) {
        uint256 size;
        
        
        
        
        
        
        
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

}

pragma solidity ^0.4.24;

import ;


contract adminupgradeabilityproxy is upgradeabilityproxy {
    
    event adminchanged(address previousadmin, address newadmin);

    
    bytes32 private constant admin_slot = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;

    
    modifier ifadmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    
    constructor(address _implementation) upgradeabilityproxy(_implementation) public {
        assert(admin_slot == keccak256());

        _setadmin(msg.sender);
    }

    
    function admin() external view ifadmin returns (address) {
        return _admin();
    }

    
    function implementation() external view ifadmin returns (address) {
        return _implementation();
    }

    
    function changeadmin(address newadmin) external ifadmin {
        require(newadmin != address(0), );
        emit adminchanged(_admin(), newadmin);
        _setadmin(newadmin);
    }

    
    function upgradeto(address newimplementation) external ifadmin {
        _upgradeto(newimplementation);
    }

    
    function upgradetoandcall(address newimplementation, bytes data) payable external ifadmin {
        _upgradeto(newimplementation);
        require(address(this).call.value(msg.value)(data));
    }

    
    function _admin() internal view returns (address adm) {
        bytes32 slot = admin_slot;
        assembly {
            adm := sload(slot)
        }
    }

    
    function _setadmin(address newadmin) internal {
        bytes32 slot = admin_slot;

        assembly {
            sstore(slot, newadmin)
        }
    }

    
    function _willfallback() internal {
        require(msg.sender != _admin(), );
        super._willfallback();
    }
}

pragma solidity ^0.4.24;




pragma experimental ;
library safemath {
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a  b;

        return c;
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }
}








contract paximplementation {

    

    using safemath for uint256;

    

    
    bool private initialized = false;

    
    mapping(address => uint256) internal balances;
    uint256 internal totalsupply_;
    string public constant name = ; 
    string public constant symbol = ; 
    uint8 public constant decimals = 18; 

    
    mapping (address => mapping (address => uint256)) internal allowed;

    
    address public owner;

    
    bool public paused = false;

    
    address public lawenforcementrole;
    mapping(address => bool) internal frozen;

    
    address public supplycontroller;

    

    
    event transfer(address indexed from, address indexed to, uint256 value);

    
    event approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    
    event ownershiptransferred(
        address indexed oldowner,
        address indexed newowner
    );

    
    event pause();
    event unpause();

    
    event addressfrozen(address indexed addr);
    event addressunfrozen(address indexed addr);
    event frozenaddresswiped(address indexed addr);
    event lawenforcementroleset (
        address indexed oldlawenforcementrole,
        address indexed newlawenforcementrole
    );

    
    event supplyincreased(address indexed to, uint256 value);
    event supplydecreased(address indexed from, uint256 value);
    event supplycontrollerset(
        address indexed oldsupplycontroller,
        address indexed newsupplycontroller
    );

    

    

    
    function initialize() public {
        require(!initialized, );
        owner = msg.sender;
        lawenforcementrole = address(0);
        totalsupply_ = 0;
        supplycontroller = msg.sender;
        initialized = true;
    }

    
    constructor() public {
        initialize();
        pause();
    }

    

    
    function totalsupply() public view returns (uint256) {
        return totalsupply_;
    }

    
    function transfer(address _to, uint256 _value) public whennotpaused returns (bool) {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[msg.sender], );
        require(_value <= balances[msg.sender], );

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceof(address _addr) public view returns (uint256) {
        return balances[_addr];
    }

    

    
    function transferfrom(
        address _from,
        address _to,
        uint256 _value
    )
    public
    whennotpaused
    returns (bool)
    {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[_from] && !frozen[msg.sender], );
        require(_value <= balances[_from], );
        require(_value <= allowed[_from][msg.sender], );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public whennotpaused returns (bool) {
        require(!frozen[_spender] && !frozen[msg.sender], );
        allowed[msg.sender][_spender] = _value;
        emit approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    

    
    modifier onlyowner() {
        require(msg.sender == owner, );
        _;
    }

    
    function transferownership(address _newowner) public onlyowner {
        require(_newowner != address(0), );
        emit ownershiptransferred(owner, _newowner);
        owner = _newowner;
    }

    

    
    modifier whennotpaused() {
        require(!paused, );
        _;
    }

    
    function pause() public onlyowner {
        require(!paused, );
        paused = true;
        emit pause();
    }

    
    function unpause() public onlyowner {
        require(paused, );
        paused = false;
        emit unpause();
    }

    

    
    function setlawenforcementrole(address _newlawenforcementrole) public {
        require(msg.sender == lawenforcementrole || msg.sender == owner, );
        emit lawenforcementroleset(lawenforcementrole, _newlawenforcementrole);
        lawenforcementrole = _newlawenforcementrole;
    }

    modifier onlylawenforcementrole() {
        require(msg.sender == lawenforcementrole, );
        _;
    }

    
    function freeze(address _addr) public onlylawenforcementrole {
        require(!frozen[_addr], );
        frozen[_addr] = true;
        emit addressfrozen(_addr);
    }

    
    function unfreeze(address _addr) public onlylawenforcementrole {
        require(frozen[_addr], );
        frozen[_addr] = false;
        emit addressunfrozen(_addr);
    }

    
    function wipefrozenaddress(address _addr) public onlylawenforcementrole {
        require(frozen[_addr], );
        uint256 _balance = balances[_addr];
        balances[_addr] = 0;
        totalsupply_ = totalsupply_.sub(_balance);
        emit frozenaddresswiped(_addr);
        emit supplydecreased(_addr, _balance);
        emit transfer(_addr, address(0), _balance);
    }

    
    function isfrozen(address _addr) public view returns (bool) {
        return frozen[_addr];
    }

    

    
    function setsupplycontroller(address _newsupplycontroller) public {
        require(msg.sender == supplycontroller || msg.sender == owner, );
        require(_newsupplycontroller != address(0), );
        emit supplycontrollerset(supplycontroller, _newsupplycontroller);
        supplycontroller = _newsupplycontroller;
    }

    modifier onlysupplycontroller() {
        require(msg.sender == supplycontroller, );
        _;
    }

    
    function increasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        totalsupply_ = totalsupply_.add(_value);
        balances[supplycontroller] = balances[supplycontroller].add(_value);
        emit supplyincreased(supplycontroller, _value);
        emit transfer(address(0), supplycontroller, _value);
        return true;
    }

    
    function decreasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        require(_value <= balances[supplycontroller], );
        
        

        balances[supplycontroller] = balances[supplycontroller].sub(_value);
        totalsupply_ = totalsupply_.sub(_value);
        emit supplydecreased(supplycontroller, _value);
        emit transfer(supplycontroller, address(0), _value);
        return true;
    }
}
pragma solidity ^0.4.24;

import ;


contract paxwithbalance is paximplementationv2 {

    function initializebalance(address initialaccount, uint initialbalance) public {
        balances[initialaccount] = initialbalance;
        totalsupply_ = initialbalance;
    }

}

pragma solidity ^0.4.24;


import ;


contract safemathmock {
    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        return safemath.sub(a, b);
    }

    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return safemath.add(a, b);
    }
}

pragma solidity ^0.4.24;
pragma experimental ;


import ;



contract badv2upgradeexample {

    

    using safemath for uint256;

    

    

    
    mapping(address => uint256) internal nextseqs;
    
    string constant internal eip191_header = ;
    
    bytes32 constant internal eip712_domain_separator_schema_hash = keccak256(
        
    );
    bytes32 constant internal eip712_delegated_transfer_schema_hash = keccak256(
        
    );
    
    
    bytes32 public eip712_domain_hash;

    
    bool private initialized = false;

    
    mapping(address => uint256) internal balances;
    uint256 internal totalsupply_;
    string public constant name = ; 
    string public constant symbol = ; 
    uint8 public constant decimals = 18; 

    
    mapping(address => mapping(address => uint256)) internal allowed;

    
    address public owner;

    
    bool public paused = false;

    
    address public assetprotectionrole;
    mapping(address => bool) internal frozen;

    
    address public supplycontroller;

    

    
    event transfer(address indexed from, address indexed to, uint256 value);

    
    event approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    
    event ownershiptransferred(
        address indexed oldowner,
        address indexed newowner
    );

    
    event pause();
    event unpause();

    
    event addressfrozen(address indexed addr);
    event addressunfrozen(address indexed addr);
    event frozenaddresswiped(address indexed addr);
    event assetprotectionroleset (
        address indexed oldassetprotectionrole,
        address indexed newassetprotectionrole
    );

    
    event supplyincreased(address indexed to, uint256 value);
    event supplydecreased(address indexed from, uint256 value);
    event supplycontrollerset(
        address indexed oldsupplycontroller,
        address indexed newsupplycontroller
    );

    
    event delegatedtransfer(
        address indexed from, address indexed to, uint256 value, uint256 seq, uint256 fee
    );

    

    

    
    function initialize() public {
        require(!initialized, );
        owner = msg.sender;
        assetprotectionrole = address(0);
        totalsupply_ = 0;
        supplycontroller = msg.sender;
        initialized = true;
    }

    
    constructor() public {
        initialize();
        pause();
        
        initializedomainseparator();
    }

    
    function initializedomainseparator() public {
        
        eip712_domain_hash = keccak256(abi.encodepacked(
                eip712_domain_separator_schema_hash,
                keccak256(bytes(name)),
                bytes32(address(this))
            ));
    }

    

    
    function totalsupply() public view returns (uint256) {
        return totalsupply_;
    }

    
    function transfer(address _to, uint256 _value) public whennotpaused returns (bool) {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[msg.sender], );
        require(_value <= balances[msg.sender], );

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceof(address _addr) public view returns (uint256) {
        return balances[_addr];
    }

    

    
    function transferfrom(
        address _from,
        address _to,
        uint256 _value
    )
    public
    whennotpaused
    returns (bool)
    {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[_from] && !frozen[msg.sender], );
        require(_value <= balances[_from], );
        require(_value <= allowed[_from][msg.sender], );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public whennotpaused returns (bool) {
        require(!frozen[_spender] && !frozen[msg.sender], );
        allowed[msg.sender][_spender] = _value;
        emit approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    

    
    modifier onlyowner() {
        require(msg.sender == owner, );
        _;
    }

    
    function transferownership(address _newowner) public onlyowner {
        require(_newowner != address(0), );
        emit ownershiptransferred(owner, _newowner);
        owner = _newowner;
    }

    
    function reclaimpax() external onlyowner {
        uint256 _balance = balances[this];
        balances[this] = 0;
        balances[owner] = balances[owner].add(_balance);
        emit transfer(this, owner, _balance);
    }

    

    
    modifier whennotpaused() {
        require(!paused, );
        _;
    }

    
    function pause() public onlyowner {
        require(!paused, );
        paused = true;
        emit pause();
    }

    
    function unpause() public onlyowner {
        require(paused, );
        paused = false;
        emit unpause();
    }

    

    
    function setassetprotectionrole(address _newassetprotectionrole) public {
        require(msg.sender == assetprotectionrole || msg.sender == owner, );
        emit assetprotectionroleset(assetprotectionrole, _newassetprotectionrole);
        assetprotectionrole = _newassetprotectionrole;
    }

    modifier onlyassetprotectionrole() {
        require(msg.sender == assetprotectionrole, );
        _;
    }

    
    function freeze(address _addr) public onlyassetprotectionrole {
        require(!frozen[_addr], );
        frozen[_addr] = true;
        emit addressfrozen(_addr);
    }

    
    function unfreeze(address _addr) public onlyassetprotectionrole {
        require(frozen[_addr], );
        frozen[_addr] = false;
        emit addressunfrozen(_addr);
    }

    
    function wipefrozenaddress(address _addr) public onlyassetprotectionrole {
        require(frozen[_addr], );
        uint256 _balance = balances[_addr];
        balances[_addr] = 0;
        totalsupply_ = totalsupply_.sub(_balance);
        emit frozenaddresswiped(_addr);
        emit supplydecreased(_addr, _balance);
        emit transfer(_addr, address(0), _balance);
    }

    
    function isfrozen(address _addr) public view returns (bool) {
        return frozen[_addr];
    }

    

    
    function setsupplycontroller(address _newsupplycontroller) public {
        require(msg.sender == supplycontroller || msg.sender == owner, );
        require(_newsupplycontroller != address(0), );
        emit supplycontrollerset(supplycontroller, _newsupplycontroller);
        supplycontroller = _newsupplycontroller;
    }

    modifier onlysupplycontroller() {
        require(msg.sender == supplycontroller, );
        _;
    }

    
    function increasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        totalsupply_ = totalsupply_.add(_value);
        balances[supplycontroller] = balances[supplycontroller].add(_value);
        emit supplyincreased(supplycontroller, _value);
        emit transfer(address(0), supplycontroller, _value);
        return true;
    }

    
    function decreasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        require(_value <= balances[supplycontroller], );
        balances[supplycontroller] = balances[supplycontroller].sub(_value);
        totalsupply_ = totalsupply_.sub(_value);
        emit supplydecreased(supplycontroller, _value);
        emit transfer(supplycontroller, address(0), _value);
        return true;
    }

    

    
    
        return nextseqs[target];
    }

    
    function delegatedtransfer(
        bytes sig, address to, uint256 value, uint256 fee, uint256 seq, uint256 deadline
    ) public whennotpaused returns (bool) {
        require(sig.length == 65, );
        require(value > 0, );
        require(block.number <= deadline, );

        
        bytes32 delegatedtransferhash = keccak256(abi.encodepacked(
                eip712_delegated_transfer_schema_hash, bytes32(to), value, fee, seq, deadline
            ));
        bytes32 hash = keccak256(abi.encodepacked(eip191_header, eip712_domain_hash, delegatedtransferhash));
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        address from = ecrecover(hash, v, r, s);

        require(from != address(0) && to != address(0), );
        require(!frozen[to] && !frozen[from] && !frozen[msg.sender], );
        require(value+fee <= balances[from], );
        require(nextseqs[from] == seq, );

        nextseqs[from] = nextseqs[from] + 1;
        balances[from] = balances[from].sub(value + fee);
        if (fee != 0) {
            balances[msg.sender] = balances[msg.sender].add(fee);
            emit transfer(from, msg.sender, fee);
        }
        balances[to] = balances[to].add(value);
        emit transfer(from, to, value);

        emit delegatedtransfer(from, to, value, seq, fee);
        return true;
    }
}





pragma solidity ^0.4.24;



library safemath {
    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a  b;

        return c;
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }
}



pragma solidity ^0.4.24;
pragma experimental ;




contract paximplementationv2 {

    

    using safemath for uint256;

    

    
    bool private initialized = false;

    
    mapping(address => uint256) internal balances;
    uint256 internal totalsupply_;
    string public constant name = ; 
    string public constant symbol = ; 
    uint8 public constant decimals = 18; 

    
    mapping(address => mapping(address => uint256)) internal allowed;

    
    address public owner;

    
    bool public paused = false;

    
    address public assetprotectionrole;
    mapping(address => bool) internal frozen;

    
    address public supplycontroller;

    
    address public proposedowner;

    
    address public betadelegatewhitelister;
    mapping(address => bool) internal betadelegatewhitelist;
    mapping(address => uint256) internal nextseqs;
    
    string constant internal eip191_header = ;
    
    bytes32 constant internal eip712_domain_separator_schema_hash = keccak256(
        
    );
    bytes32 constant internal eip712_delegated_transfer_schema_hash = keccak256(
        
    );
    
    
    bytes32 public eip712_domain_hash;

    

    
    event transfer(address indexed from, address indexed to, uint256 value);

    
    event approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );

    
    event ownershiptransferproposed(
        address indexed currentowner,
        address indexed proposedowner
    );
    event ownershiptransferdisregarded(
        address indexed oldproposedowner
    );
    event ownershiptransferred(
        address indexed oldowner,
        address indexed newowner
    );

    
    event pause();
    event unpause();

    
    event addressfrozen(address indexed addr);
    event addressunfrozen(address indexed addr);
    event frozenaddresswiped(address indexed addr);
    event assetprotectionroleset (
        address indexed oldassetprotectionrole,
        address indexed newassetprotectionrole
    );

    
    event supplyincreased(address indexed to, uint256 value);
    event supplydecreased(address indexed from, uint256 value);
    event supplycontrollerset(
        address indexed oldsupplycontroller,
        address indexed newsupplycontroller
    );

    
    event betadelegatedtransfer(
        address indexed from, address indexed to, uint256 value, uint256 seq, uint256 fee
    );
    event betadelegatewhitelisterset(
        address indexed oldwhitelister,
        address indexed newwhitelister
    );
    event betadelegatewhitelisted(address indexed newdelegate);
    event betadelegateunwhitelisted(address indexed olddelegate);

    

    

    
    function initialize() public {
        require(!initialized, );
        owner = msg.sender;
        assetprotectionrole = address(0);
        totalsupply_ = 0;
        supplycontroller = msg.sender;
        initialized = true;
    }

    
    constructor() public {
        initialize();
        pause();
        
        initializedomainseparator();
    }

    
    function initializedomainseparator() public {
        
        eip712_domain_hash = keccak256(abi.encodepacked(
                eip712_domain_separator_schema_hash,
                keccak256(bytes(name)),
                bytes32(address(this))
            ));
        proposedowner = address(0);
    }

    

    
    function totalsupply() public view returns (uint256) {
        return totalsupply_;
    }

    
    function transfer(address _to, uint256 _value) public whennotpaused returns (bool) {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[msg.sender], );
        require(_value <= balances[msg.sender], );

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit transfer(msg.sender, _to, _value);
        return true;
    }

    
    function balanceof(address _addr) public view returns (uint256) {
        return balances[_addr];
    }

    

    
    function transferfrom(
        address _from,
        address _to,
        uint256 _value
    )
    public
    whennotpaused
    returns (bool)
    {
        require(_to != address(0), );
        require(!frozen[_to] && !frozen[_from] && !frozen[msg.sender], );
        require(_value <= balances[_from], );
        require(_value <= allowed[_from][msg.sender], );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        emit transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public whennotpaused returns (bool) {
        require(!frozen[_spender] && !frozen[msg.sender], );
        allowed[msg.sender][_spender] = _value;
        emit approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(
        address _owner,
        address _spender
    )
    public
    view
    returns (uint256)
    {
        return allowed[_owner][_spender];
    }

    

    
    modifier onlyowner() {
        require(msg.sender == owner, );
        _;
    }

    
    function proposeowner(address _proposedowner) public onlyowner {
        require(_proposedowner != address(0), );
        require(msg.sender != _proposedowner, );
        proposedowner = _proposedowner;
        emit ownershiptransferproposed(owner, proposedowner);
    }
    
    function disregardproposeowner() public {
        require(msg.sender == proposedowner || msg.sender == owner, );
        require(proposedowner != address(0), );
        address _oldproposedowner = proposedowner;
        proposedowner = address(0);
        emit ownershiptransferdisregarded(_oldproposedowner);
    }
    
    function claimownership() public {
        require(msg.sender == proposedowner, );
        address _oldowner = owner;
        owner = proposedowner;
        proposedowner = address(0);
        emit ownershiptransferred(_oldowner, owner);
    }

    
    function reclaimpax() external onlyowner {
        uint256 _balance = balances[this];
        balances[this] = 0;
        balances[owner] = balances[owner].add(_balance);
        emit transfer(this, owner, _balance);
    }

    

    
    modifier whennotpaused() {
        require(!paused, );
        _;
    }

    
    function pause() public onlyowner {
        require(!paused, );
        paused = true;
        emit pause();
    }

    
    function unpause() public onlyowner {
        require(paused, );
        paused = false;
        emit unpause();
    }

    

    
    function setassetprotectionrole(address _newassetprotectionrole) public {
        require(msg.sender == assetprotectionrole || msg.sender == owner, );
        emit assetprotectionroleset(assetprotectionrole, _newassetprotectionrole);
        assetprotectionrole = _newassetprotectionrole;
    }

    modifier onlyassetprotectionrole() {
        require(msg.sender == assetprotectionrole, );
        _;
    }

    
    function freeze(address _addr) public onlyassetprotectionrole {
        require(!frozen[_addr], );
        frozen[_addr] = true;
        emit addressfrozen(_addr);
    }

    
    function unfreeze(address _addr) public onlyassetprotectionrole {
        require(frozen[_addr], );
        frozen[_addr] = false;
        emit addressunfrozen(_addr);
    }

    
    function wipefrozenaddress(address _addr) public onlyassetprotectionrole {
        require(frozen[_addr], );
        uint256 _balance = balances[_addr];
        balances[_addr] = 0;
        totalsupply_ = totalsupply_.sub(_balance);
        emit frozenaddresswiped(_addr);
        emit supplydecreased(_addr, _balance);
        emit transfer(_addr, address(0), _balance);
    }

    
    function isfrozen(address _addr) public view returns (bool) {
        return frozen[_addr];
    }

    

    
    function setsupplycontroller(address _newsupplycontroller) public {
        require(msg.sender == supplycontroller || msg.sender == owner, );
        require(_newsupplycontroller != address(0), );
        emit supplycontrollerset(supplycontroller, _newsupplycontroller);
        supplycontroller = _newsupplycontroller;
    }

    modifier onlysupplycontroller() {
        require(msg.sender == supplycontroller, );
        _;
    }

    
    function increasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        totalsupply_ = totalsupply_.add(_value);
        balances[supplycontroller] = balances[supplycontroller].add(_value);
        emit supplyincreased(supplycontroller, _value);
        emit transfer(address(0), supplycontroller, _value);
        return true;
    }

    
    function decreasesupply(uint256 _value) public onlysupplycontroller returns (bool success) {
        require(_value <= balances[supplycontroller], );
        balances[supplycontroller] = balances[supplycontroller].sub(_value);
        totalsupply_ = totalsupply_.sub(_value);
        emit supplydecreased(supplycontroller, _value);
        emit transfer(supplycontroller, address(0), _value);
        return true;
    }

    

    
    
        return nextseqs[target];
    }

    
    function betadelegatedtransfer(
        bytes sig, address to, uint256 value, uint256 fee, uint256 seq, uint256 deadline
    ) public returns (bool) {
        require(sig.length == 65, );
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        require(_betadelegatedtransfer(r, s, v, to, value, fee, seq, deadline), );
        return true;
    }

    
    function _betadelegatedtransfer(
        bytes32 r, bytes32 s, uint8 v, address to, uint256 value, uint256 fee, uint256 seq, uint256 deadline
    ) internal whennotpaused returns (bool) {
        require(betadelegatewhitelist[msg.sender], );
        require(value > 0 || fee > 0, );
        require(block.number <= deadline, );
        
        require(uint256(s) <= 0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0, );
        require(v == 27 || v == 28, );

        
        bytes32 delegatedtransferhash = keccak256(abi.encodepacked(
                eip712_delegated_transfer_schema_hash, bytes32(to), value, fee, seq, deadline
            ));
        bytes32 hash = keccak256(abi.encodepacked(eip191_header, eip712_domain_hash, delegatedtransferhash));
        address _from = ecrecover(hash, v, r, s);

        require(_from != address(0), );
        require(to != address(0), );
        require(!frozen[to] && !frozen[_from] && !frozen[msg.sender], );
        require(value.add(fee) <= balances[_from], );
        require(nextseqs[_from] == seq, );

        nextseqs[_from] = nextseqs[_from].add(1);
        balances[_from] = balances[_from].sub(value.add(fee));
        if (fee != 0) {
            balances[msg.sender] = balances[msg.sender].add(fee);
            emit transfer(_from, msg.sender, fee);
        }
        balances[to] = balances[to].add(value);
        emit transfer(_from, to, value);

        emit betadelegatedtransfer(_from, to, value, seq, fee);
        return true;
    }

    
    function betadelegatedtransferbatch(
        bytes32[] r, bytes32[] s, uint8[] v, address[] to, uint256[] value, uint256[] fee, uint256[] seq, uint256[] deadline
    ) public returns (bool) {
        require(r.length == s.length && r.length == v.length && r.length == to.length && r.length == value.length, );
        require(r.length == fee.length && r.length == seq.length && r.length == deadline.length, );

        for (uint i = 0; i < r.length; i++) {
            require(
                _betadelegatedtransfer(r[i], s[i], v[i], to[i], value[i], fee[i], seq[i], deadline[i]),
                
            );
        }
        return true;
    }

    
    function iswhitelistedbetadelegate(address _addr) public view returns (bool) {
        return betadelegatewhitelist[_addr];
    }

    
    function setbetadelegatewhitelister(address _newwhitelister) public {
        require(msg.sender == betadelegatewhitelister || msg.sender == owner, );
        betadelegatewhitelister = _newwhitelister;
        emit betadelegatewhitelisterset(betadelegatewhitelister, _newwhitelister);
    }

    modifier onlybetadelegatewhitelister() {
        require(msg.sender == betadelegatewhitelister, );
        _;
    }

    
    function whitelistbetadelegate(address _addr) public onlybetadelegatewhitelister {
        require(!betadelegatewhitelist[_addr], );
        betadelegatewhitelist[_addr] = true;
        emit betadelegatewhitelisted(_addr);
    }

    
    function unwhitelistbetadelegate(address _addr) public onlybetadelegatewhitelister {
        require(betadelegatewhitelist[_addr], );
        betadelegatewhitelist[_addr] = false;
        emit betadelegateunwhitelisted(_addr);
    }
}




pragma solidity ^0.4.24;


contract proxy {
    
    function () payable external {
        _fallback();
    }

    
    function _implementation() internal view returns (address);

    
    function _delegate(address implementation) internal {
        assembly {
        
        
        
            calldatacopy(0, 0, calldatasize)

        
        
            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

        
            returndatacopy(0, 0, returndatasize)

            switch result
            
            case 0 { revert(0, returndatasize) }
            default { return(0, returndatasize) }
        }
    }

    
    function _willfallback() internal {
    }

    
    function _fallback() internal {
        _willfallback();
        _delegate(_implementation());
    }
}



pragma solidity ^0.4.24;



library addressutils {

    
    function iscontract(address addr) internal view returns (bool) {
        uint256 size;
        
        
        
        
        
        
        
        assembly { size := extcodesize(addr) }
        return size > 0;
    }

}



pragma solidity ^0.4.24;




contract upgradeabilityproxy is proxy {
    
    event upgraded(address implementation);

    
    bytes32 private constant implementation_slot = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;

    
    constructor(address _implementation) public {
        assert(implementation_slot == keccak256());

        _setimplementation(_implementation);
    }

    
    function _implementation() internal view returns (address impl) {
        bytes32 slot = implementation_slot;
        assembly {
            impl := sload(slot)
        }
    }

    
    function _upgradeto(address newimplementation) internal {
        _setimplementation(newimplementation);
        emit upgraded(newimplementation);
    }

    
    function _setimplementation(address newimplementation) private {
        require(addressutils.iscontract(newimplementation), );

        bytes32 slot = implementation_slot;

        assembly {
            sstore(slot, newimplementation)
        }
    }
}



pragma solidity ^0.4.24;



contract adminupgradeabilityproxy is upgradeabilityproxy {
    
    event adminchanged(address previousadmin, address newadmin);

    
    bytes32 private constant admin_slot = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;

    
    modifier ifadmin() {
        if (msg.sender == _admin()) {
            _;
        } else {
            _fallback();
        }
    }

    
    constructor(address _implementation) upgradeabilityproxy(_implementation) public {
        assert(admin_slot == keccak256());

        _setadmin(msg.sender);
    }

    
    function admin() external view ifadmin returns (address) {
        return _admin();
    }

    
    function implementation() external view ifadmin returns (address) {
        return _implementation();
    }

    
    function changeadmin(address newadmin) external ifadmin {
        require(newadmin != address(0), );
        emit adminchanged(_admin(), newadmin);
        _setadmin(newadmin);
    }

    
    function upgradeto(address newimplementation) external ifadmin {
        _upgradeto(newimplementation);
    }

    
    function upgradetoandcall(address newimplementation, bytes data) payable external ifadmin {
        _upgradeto(newimplementation);
        require(address(this).call.value(msg.value)(data));
    }

    
    function _admin() internal view returns (address adm) {
        bytes32 slot = admin_slot;
        assembly {
            adm := sload(slot)
        }
    }

    
    function _setadmin(address newadmin) internal {
        bytes32 slot = admin_slot;

        assembly {
            sstore(slot, newadmin)
        }
    }

    
    function _willfallback() internal {
        require(msg.sender != _admin(), );
        super._willfallback();
    }
}

