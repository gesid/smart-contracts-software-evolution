pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract ilegacyconverter {
    function change(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount, uint256 _minreturn) public returns (uint256);
}


contract bancornetwork is ibancornetwork, tokenholder, contractregistryclient, reentrancyguard {
    using safemath for uint256;

    uint256 private constant conversion_fee_resolution = 1000000;
    uint256 private constant affiliate_fee_resolution = 1000000;
    address private constant eth_reserve_address = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;

    struct conversionstep {
        iconverter converter;
        iconverteranchor anchor;
        ierc20token sourcetoken;
        ierc20token targettoken;
        address beneficiary;
        bool isv28orhigherconverter;
        bool processaffiliatefee;
    }

    uint256 public maxaffiliatefee = 30000;     

    mapping (address => bool) public ethertokens;       

    
    event conversion(
        address indexed _smarttoken,
        address indexed _fromtoken,
        address indexed _totoken,
        uint256 _fromamount,
        uint256 _toamount,
        address _trader
    );

    
    constructor(icontractregistry _registry) contractregistryclient(_registry) public {
        ethertokens[eth_reserve_address] = true;
    }

    
    function setmaxaffiliatefee(uint256 _maxaffiliatefee)
        public
        owneronly
    {
        require(_maxaffiliatefee <= affiliate_fee_resolution, );
        maxaffiliatefee = _maxaffiliatefee;
    }

    
    function registerethertoken(iethertoken _token, bool _register)
        public
        owneronly
        validaddress(_token)
        notthis(_token)
    {
        ethertokens[_token] = _register;
    }

    
    function conversionpath(ierc20token _sourcetoken, ierc20token _targettoken) public view returns (address[]) {
        iconversionpathfinder pathfinder = iconversionpathfinder(addressof(conversion_path_finder));
        return pathfinder.findpath(_sourcetoken, _targettoken);
    }

    
    function ratebypath(ierc20token[] _path, uint256 _amount) public view returns (uint256) {
        uint256 amount;
        uint256 fee;
        uint256 supply;
        uint256 balance;
        uint32 weight;
        iconverter converter;
        ibancorformula formula = ibancorformula(addressof(bancor_formula));

        amount = _amount;

        
        require(_path.length > 2 && _path.length % 2 == 1, );

        
        for (uint256 i = 2; i < _path.length; i += 2) {
            ierc20token sourcetoken = _path[i  2];
            ierc20token anchor = _path[i  1];
            ierc20token targettoken = _path[i];

            converter = iconverter(iconverteranchor(anchor).owner());

            
            sourcetoken = getconvertertokenaddress(converter, sourcetoken);
            targettoken = getconvertertokenaddress(converter, targettoken);

            if (targettoken == anchor) { 
                
                if (i < 3 || anchor != _path[i  3])
                    supply = ismarttoken(anchor).totalsupply();

                
                balance = converter.getconnectorbalance(sourcetoken);
                (, weight, , , ) = converter.connectors(sourcetoken);
                amount = formula.purchasetargetamount(supply, balance, weight, amount);
                fee = amount.mul(converter.conversionfee()).div(conversion_fee_resolution);
                amount = fee;

                
                supply = supply.add(amount);
            }
            else if (sourcetoken == anchor) { 
                
                if (i < 3 || anchor != _path[i  3])
                    supply = ismarttoken(anchor).totalsupply();

                
                balance = converter.getconnectorbalance(targettoken);
                (, weight, , , ) = converter.connectors(targettoken);
                amount = formula.saletargetamount(supply, balance, weight, amount);
                fee = amount.mul(converter.conversionfee()).div(conversion_fee_resolution);
                amount = fee;

                
                supply = supply.sub(amount);
            }
            else { 
                (amount, fee) = getreturn(converter, sourcetoken, targettoken, amount);
            }
        }

        return amount;
    }

    
    function convertbypath(ierc20token[] _path, uint256 _amount, uint256 _minreturn, address _beneficiary, address _affiliateaccount, uint256 _affiliatefee)
        public
        payable
        protected
        greaterthanzero(_minreturn)
        returns (uint256)
    {
        
        require(_path.length > 2 && _path.length % 2 == 1, );

        
        handlesourcetoken(_path[0], iconverteranchor(_path[1]), _amount);

        
        bool affiliatefeeenabled = false;
        if (address(_affiliateaccount) == 0) {
            require(_affiliatefee == 0, );
        }
        else {
            require(0 < _affiliatefee && _affiliatefee <= maxaffiliatefee, );
            affiliatefeeenabled = true;
        }

        
        address beneficiary = msg.sender;
        if (_beneficiary != address(0))
            beneficiary = _beneficiary;

        
        conversionstep[] memory data = createconversiondata(_path, beneficiary, affiliatefeeenabled);
        uint256 amount = doconversion(data, _amount, _minreturn, _affiliateaccount, _affiliatefee);

        
        handletargettoken(data, amount, beneficiary);

        return amount;
    }

    
    function xconvert(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        bytes32 _targetblockchain,
        bytes32 _targetaccount,
        uint256 _conversionid
    )
        public
        payable
        returns (uint256)
    {
        return xconvert2(_path, _amount, _minreturn, _targetblockchain, _targetaccount, _conversionid, address(0), 0);
    }

    
    function xconvert2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        bytes32 _targetblockchain,
        bytes32 _targetaccount,
        uint256 _conversionid,
        address _affiliateaccount,
        uint256 _affiliatefee
    )
        public
        payable
        greaterthanzero(_minreturn)
        returns (uint256)
    {
        ierc20token targettoken = _path[_path.length  1];
        ibancorx bancorx = ibancorx(addressof(bancor_x));

        
        require(targettoken == addressof(bnt_token), );

        
        uint256 amount = convertbypath(_path, _amount, _minreturn, this, _affiliateaccount, _affiliatefee);

        
        ensureallowance(targettoken, bancorx, amount);

        
        bancorx.xtransfer(_targetblockchain, _targetaccount, amount, _conversionid);

        return amount;
    }

    
    function completexconversion(ierc20token[] _path, ibancorx _bancorx, uint256 _conversionid, uint256 _minreturn, address _beneficiary)
        public returns (uint256)
    {
        
        require(_path[0] == _bancorx.token(), );

        
        uint256 amount = _bancorx.getxtransferamount(_conversionid, msg.sender);

        
        return convertbypath(_path, amount, _minreturn, _beneficiary, address(0), 0);
    }

    
    function doconversion(
        conversionstep[] _data,
        uint256 _amount,
        uint256 _minreturn,
        address _affiliateaccount,
        uint256 _affiliatefee
    ) private returns (uint256) {
        uint256 toamount;
        uint256 fromamount = _amount;

        
        for (uint256 i = 0; i < _data.length; i++) {
            conversionstep memory stepdata = _data[i];

            
            if (stepdata.isv28orhigherconverter) {
                
                
                if (i != 0 && _data[i  1].beneficiary == address(this) && !ethertokens[stepdata.sourcetoken])
                    safetransfer(stepdata.sourcetoken, stepdata.converter, fromamount);
            }
            
            
            else if (stepdata.sourcetoken != ismarttoken(stepdata.anchor)) {
                
                ensureallowance(stepdata.sourcetoken, stepdata.converter, fromamount);
            }

            
            if (!stepdata.isv28orhigherconverter)
                toamount = ilegacyconverter(stepdata.converter).change(stepdata.sourcetoken, stepdata.targettoken, fromamount, 1);
            else if (ethertokens[stepdata.sourcetoken])
                toamount = stepdata.converter.convert.value(msg.value)(stepdata.sourcetoken, stepdata.targettoken, fromamount, msg.sender, stepdata.beneficiary);
            else
                toamount = stepdata.converter.convert(stepdata.sourcetoken, stepdata.targettoken, fromamount, msg.sender, stepdata.beneficiary);

            
            if (stepdata.processaffiliatefee) {
                uint256 affiliateamount = toamount.mul(_affiliatefee).div(affiliate_fee_resolution);
                require(stepdata.targettoken.transfer(_affiliateaccount, affiliateamount), );
                toamount = affiliateamount;
            }

            emit conversion(stepdata.anchor, stepdata.sourcetoken, stepdata.targettoken, fromamount, toamount, msg.sender);
            fromamount = toamount;
        }

        
        require(toamount >= _minreturn, );

        return toamount;
    }

    
    function handlesourcetoken(ierc20token _sourcetoken, iconverteranchor _anchor, uint256 _amount) private {
        iconverter firstconverter = iconverter(_anchor.owner());
        bool isnewerconverter = isv28orhigherconverter(firstconverter);

        
        if (msg.value > 0) {
            
            require(msg.value == _amount, );

            
            
            
            if (!isnewerconverter)
                iethertoken(getconverterethertokenaddress(firstconverter)).deposit.value(msg.value)();
        }
        
        else if (ethertokens[_sourcetoken]) {
            
            
            safetransferfrom(_sourcetoken, msg.sender, this, _amount);

            
            if (isnewerconverter)
                iethertoken(_sourcetoken).withdraw(_amount);
        }
        
        else {
            
            
            if (isnewerconverter)
                safetransferfrom(_sourcetoken, msg.sender, firstconverter, _amount);
            else
                safetransferfrom(_sourcetoken, msg.sender, this, _amount);
        }
    }

    
    function handletargettoken(conversionstep[] _data, uint256 _amount, address _beneficiary) private {
        conversionstep memory stepdata = _data[_data.length  1];

        
        if (stepdata.beneficiary != address(this))
            return;

        ierc20token targettoken = stepdata.targettoken;

        
        if (ethertokens[targettoken]) {
            
            assert(!stepdata.isv28orhigherconverter);

            
            iethertoken(targettoken).withdrawto(_beneficiary, _amount);
        }
        
        else {
            safetransfer(targettoken, _beneficiary, _amount);
        }
    }

    
    function createconversiondata(ierc20token[] _conversionpath, address _beneficiary, bool _affiliatefeeenabled) private view returns (conversionstep[]) {
        conversionstep[] memory data = new conversionstep[](_conversionpath.length / 2);

        bool affiliatefeeprocessed = false;
        address bnttoken = addressof(bnt_token);
        
        uint256 i;
        for (i = 0; i < _conversionpath.length  1; i += 2) {
            iconverteranchor anchor = iconverteranchor(_conversionpath[i + 1]);
            iconverter converter = iconverter(anchor.owner());
            ierc20token targettoken = _conversionpath[i + 2];

            
            bool processaffiliatefee = _affiliatefeeenabled && !affiliatefeeprocessed && targettoken == bnttoken;
            if (processaffiliatefee)
                affiliatefeeprocessed = true;

            data[i / 2] = conversionstep({
                
                anchor: anchor,

                
                converter: converter,

                
                sourcetoken: _conversionpath[i],
                targettoken: targettoken,

                
                beneficiary: address(0),

                
                isv28orhigherconverter: isv28orhigherconverter(converter),
                processaffiliatefee: processaffiliatefee
            });
        }

        
        
        conversionstep memory stepdata = data[0];
        if (ethertokens[stepdata.sourcetoken]) {
            
            if (stepdata.isv28orhigherconverter)
                stepdata.sourcetoken = ierc20token(eth_reserve_address);
            
            else
                stepdata.sourcetoken = ierc20token(getconverterethertokenaddress(stepdata.converter));
        }

        
        stepdata = data[data.length  1];
        if (ethertokens[stepdata.targettoken]) {
            
            if (stepdata.isv28orhigherconverter)
                stepdata.targettoken = ierc20token(eth_reserve_address);
            
            else
                stepdata.targettoken = ierc20token(getconverterethertokenaddress(stepdata.converter));
        }

        
        for (i = 0; i < data.length; i++) {
            stepdata = data[i];

            
            if (stepdata.isv28orhigherconverter) {
                
                if (stepdata.processaffiliatefee)
                    stepdata.beneficiary = this;
                
                else if (i == data.length  1)
                    stepdata.beneficiary = _beneficiary;
                
                else if (data[i + 1].isv28orhigherconverter)
                    stepdata.beneficiary = data[i + 1].converter;
                
                else
                    stepdata.beneficiary = this;
            }
            else {
                
                stepdata.beneficiary = this;
            }
        }

        return data;
    }

    
    function ensureallowance(ierc20token _token, address _spender, uint256 _value) private {
        uint256 allowance = _token.allowance(this, _spender);
        if (allowance < _value) {
            if (allowance > 0)
                safeapprove(_token, _spender, 0);
            safeapprove(_token, _spender, _value);
        }
    }

    
    function getconverterethertokenaddress(iconverter _converter) private view returns (address) {
        uint256 reservecount = _converter.connectortokencount();
        for (uint256 i = 0; i < reservecount; i++) {
            address reservetokenaddress = _converter.connectortokens(i);
            if (ethertokens[reservetokenaddress])
                return reservetokenaddress;
        }

        return eth_reserve_address;
    }

    
    
    function getconvertertokenaddress(iconverter _converter, ierc20token _token) private view returns (ierc20token) {
        if (!ethertokens[_token])
            return _token;

        if (isv28orhigherconverter(_converter))
            return ierc20token(eth_reserve_address);

        return ierc20token(getconverterethertokenaddress(_converter));
    }

    bytes4 private constant get_return_func_selector = bytes4(keccak256());

    
    function getreturn(address _dest, address _sourcetoken, address _targettoken, uint256 _amount) internal view returns (uint256, uint256) {
        uint256[2] memory ret;
        bytes memory data = abi.encodewithselector(get_return_func_selector, _sourcetoken, _targettoken, _amount);

        assembly {
            let success := staticcall(
                gas,           
                _dest,         
                add(data, 32), 
                mload(data),   
                ret,           
                64             
            )
            if iszero(success) {
                revert(0, 0)
            }
        }

        return (ret[0], ret[1]);
    }

    bytes4 private constant is_v28_or_higher_func_selector = bytes4(keccak256());

    
    
    function isv28orhigherconverter(iconverter _converter) internal view returns (bool) {
        bool success;
        uint256[1] memory ret;
        bytes memory data = abi.encodewithselector(is_v28_or_higher_func_selector);

        assembly {
            success := staticcall(
                5000,          
                _converter,    
                add(data, 32), 
                mload(data),   
                ret,           
                32             
            )
        }

        return success && ret[0] != 0;
    }

    
    function getreturnbypath(ierc20token[] _path, uint256 _amount) public view returns (uint256, uint256) {
        return (ratebypath(_path, _amount), 0);
    }

    
    function convert(ierc20token[] _path, uint256 _amount, uint256 _minreturn) public payable returns (uint256) {
        return convertbypath(_path, _amount, _minreturn, address(0), address(0), 0);
    }

    
    function convert2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _affiliateaccount,
        uint256 _affiliatefee
    )
        public
        payable
        returns (uint256)
    {
        return convertbypath(_path, _amount, _minreturn, address(0), _affiliateaccount, _affiliatefee);
    }

    
    function convertfor(ierc20token[] _path, uint256 _amount, uint256 _minreturn, address _beneficiary) public payable returns (uint256) {
        return convertbypath(_path, _amount, _minreturn, _beneficiary, address(0), 0);
    }

    
    function convertfor2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _beneficiary,
        address _affiliateaccount,
        uint256 _affiliatefee
    )
        public
        payable
        greaterthanzero(_minreturn)
        returns (uint256)
    {
        return convertbypath(_path, _amount, _minreturn, _beneficiary, _affiliateaccount, _affiliatefee);
    }

    
    function claimandconvert(ierc20token[] _path, uint256 _amount, uint256 _minreturn) public returns (uint256) {
        return convertbypath(_path, _amount, _minreturn, address(0), address(0), 0);
    }

    
    function claimandconvert2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _affiliateaccount,
        uint256 _affiliatefee
    )
        public
        returns (uint256)
    {
        return convertbypath(_path, _amount, _minreturn, address(0), _affiliateaccount, _affiliatefee);
    }

    
    function claimandconvertfor(ierc20token[] _path, uint256 _amount, uint256 _minreturn, address _beneficiary) public returns (uint256) {
        return convertbypath(_path, _amount, _minreturn, _beneficiary, address(0), 0);
    }

    
    function claimandconvertfor2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _beneficiary,
        address _affiliateaccount,
        uint256 _affiliatefee
    )
        public
        returns (uint256)
    {
        return convertbypath(_path, _amount, _minreturn, _beneficiary, _affiliateaccount, _affiliatefee);
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;


contract conversionpathfinder is iconversionpathfinder, contractregistryclient {
    address public anchortoken;

    
    constructor(icontractregistry _registry) contractregistryclient(_registry) public {
    }

    
    function setanchortoken(address _anchortoken) public owneronly {
        anchortoken = _anchortoken;
    }

    
    function findpath(address _sourcetoken, address _targettoken) public view returns (address[] memory) {
        iconverterregistry converterregistry = iconverterregistry(addressof(converter_registry));
        address[] memory sourcepath = getpath(_sourcetoken, converterregistry);
        address[] memory targetpath = getpath(_targettoken, converterregistry);
        return getshortestpath(sourcepath, targetpath);
    }

    
    function getpath(address _token, iconverterregistry _converterregistry) private view returns (address[] memory) {
        if (_token == anchortoken)
            return getinitialarray(_token);

        address[] memory anchors;
        if (_converterregistry.isanchor(_token))
            anchors = getinitialarray(_token);
        else
            anchors = _converterregistry.getconvertibletokenanchors(_token);

        for (uint256 n = 0; n < anchors.length; n++) {
            iconverter converter = iconverter(iconverteranchor(anchors[n]).owner());
            uint256 connectortokencount = converter.connectortokencount();
            for (uint256 i = 0; i < connectortokencount; i++) {
                address connectortoken = converter.connectortokens(i);
                if (connectortoken != _token) {
                    address[] memory path = getpath(connectortoken, _converterregistry);
                    if (path.length > 0)
                        return getextendedarray(_token, anchors[n], path);
                }
            }
        }

        return new address[](0);
    }

    
    function getshortestpath(address[] memory _sourcepath, address[] memory _targetpath) private pure returns (address[] memory) {
        if (_sourcepath.length > 0 && _targetpath.length > 0) {
            uint256 i = _sourcepath.length;
            uint256 j = _targetpath.length;
            while (i > 0 && j > 0 && _sourcepath[i  1] == _targetpath[j  1]) {
                i;
                j;
            }

            address[] memory path = new address[](i + j + 1);
            for (uint256 m = 0; m <= i; m++)
                path[m] = _sourcepath[m];
            for (uint256 n = j; n > 0; n)
                path[path.length  n] = _targetpath[n  1];

            uint256 length = 0;
            for (uint256 p = 0; p < path.length; p += 1) {
                for (uint256 q = p + 2; q < path.length  p % 2; q += 2) {
                    if (path[p] == path[q])
                        p = q;
                }
                path[length++] = path[p];
            }

            return getpartialarray(path, length);
        }

        return new address[](0);
    }

    
    function getinitialarray(address _item) private pure returns (address[] memory) {
        address[] memory array = new address[](1);
        array[0] = _item;
        return array;
    }

    
    function getextendedarray(address _item0, address _item1, address[] memory _array) private pure returns (address[] memory) {
        address[] memory array = new address[](2 + _array.length);
        array[0] = _item0;
        array[1] = _item1;
        for (uint256 i = 0; i < _array.length; i++)
            array[2 + i] = _array[i];
        return array;
    }

    
    function getpartialarray(address[] memory _array, uint256 _length) private pure returns (address[] memory) {
        address[] memory array = new address[](_length);
        for (uint256 i = 0; i < _length; i++)
            array[i] = _array[i];
        return array;
    }
}

pragma solidity 0.4.26;
import ;


contract ibancornetwork {
    function convert2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _affiliateaccount,
        uint256 _affiliatefee
    ) public payable returns (uint256);

    function claimandconvert2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _affiliateaccount,
        uint256 _affiliatefee
    ) public returns (uint256);

    function convertfor2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _for,
        address _affiliateaccount,
        uint256 _affiliatefee
    ) public payable returns (uint256);

    function claimandconvertfor2(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _for,
        address _affiliateaccount,
        uint256 _affiliatefee
    ) public returns (uint256);

    
    function convert(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn
    ) public payable returns (uint256);

    
    function claimandconvert(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn
    ) public returns (uint256);

    
    function convertfor(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _for
    ) public payable returns (uint256);

    
    function claimandconvertfor(
        ierc20token[] _path,
        uint256 _amount,
        uint256 _minreturn,
        address _for
    ) public returns (uint256);
}

pragma solidity 0.4.26;
import ;


contract iconversionpathfinder {
    function findpath(address _sourcetoken, address _targettoken) public view returns (address[] memory);
}

pragma solidity 0.4.26;
import ;
import ;


contract converterregistrydata is iconverterregistrydata, contractregistryclient {
    struct item {
        bool valid;
        uint256 index;
    }

    struct items {
        address[] array;
        mapping(address => item) table;
    }

    struct list {
        uint256 index;
        items items;
    }

    struct lists {
        address[] array;
        mapping(address => list) table;
    }

    items private smarttokens;
    items private liquiditypools;
    lists private convertibletokens;

    
    constructor(icontractregistry _registry) contractregistryclient(_registry) public {
    }

    
    function addsmarttoken(address _smarttoken) external only(converter_registry) {
        additem(smarttokens, _smarttoken);
    }

    
    function removesmarttoken(address _smarttoken) external only(converter_registry) {
        removeitem(smarttokens, _smarttoken);
    }

    
    function addliquiditypool(address _liquiditypool) external only(converter_registry) {
        additem(liquiditypools, _liquiditypool);
    }

    
    function removeliquiditypool(address _liquiditypool) external only(converter_registry) {
        removeitem(liquiditypools, _liquiditypool);
    }

    
    function addconvertibletoken(address _convertibletoken, address _smarttoken) external only(converter_registry) {
        list storage list = convertibletokens.table[_convertibletoken];
        if (list.items.array.length == 0) {
            list.index = convertibletokens.array.push(_convertibletoken)  1;
        }
        additem(list.items, _smarttoken);
    }

    
    function removeconvertibletoken(address _convertibletoken, address _smarttoken) external only(converter_registry) {
        list storage list = convertibletokens.table[_convertibletoken];
        removeitem(list.items, _smarttoken);
        if (list.items.array.length == 0) {
            address lastconvertibletoken = convertibletokens.array[convertibletokens.array.length  1];
            convertibletokens.table[lastconvertibletoken].index = list.index;
            convertibletokens.array[list.index] = lastconvertibletoken;
            convertibletokens.array.length;
            delete convertibletokens.table[_convertibletoken];
        }
    }

    
    function getsmarttokencount() external view returns (uint256) {
        return smarttokens.array.length;
    }

    
    function getsmarttokens() external view returns (address[]) {
        return smarttokens.array;
    }

    
    function getsmarttoken(uint256 _index) external view returns (address) {
        return smarttokens.array[_index];
    }

    
    function issmarttoken(address _value) external view returns (bool) {
        return smarttokens.table[_value].valid;
    }

    
    function getliquiditypoolcount() external view returns (uint256) {
        return liquiditypools.array.length;
    }

    
    function getliquiditypools() external view returns (address[]) {
        return liquiditypools.array;
    }

    
    function getliquiditypool(uint256 _index) external view returns (address) {
        return liquiditypools.array[_index];
    }

    
    function isliquiditypool(address _value) external view returns (bool) {
        return liquiditypools.table[_value].valid;
    }

    
    function getconvertibletokencount() external view returns (uint256) {
        return convertibletokens.array.length;
    }

    
    function getconvertibletokens() external view returns (address[]) {
        return convertibletokens.array;
    }

    
    function getconvertibletoken(uint256 _index) external view returns (address) {
        return convertibletokens.array[_index];
    }

    
    function isconvertibletoken(address _value) external view returns (bool) {
        return convertibletokens.table[_value].items.array.length > 0;
    }

    
    function getconvertibletokensmarttokencount(address _convertibletoken) external view returns (uint256) {
        return convertibletokens.table[_convertibletoken].items.array.length;
    }

    
    function getconvertibletokensmarttokens(address _convertibletoken) external view returns (address[]) {
        return convertibletokens.table[_convertibletoken].items.array;
    }

    
    function getconvertibletokensmarttoken(address _convertibletoken, uint256 _index) external view returns (address) {
        return convertibletokens.table[_convertibletoken].items.array[_index];
    }

    
    function isconvertibletokensmarttoken(address _convertibletoken, address _value) external view returns (bool) {
        return convertibletokens.table[_convertibletoken].items.table[_value].valid;
    }

    
    function additem(items storage _items, address _value) internal validaddress(_value) {
        item storage item = _items.table[_value];
        require(!item.valid, );

        item.index = _items.array.push(_value)  1;
        item.valid = true;
    }

    
    function removeitem(items storage _items, address _value) internal validaddress(_value) {
        item storage item = _items.table[_value];
        require(item.valid, );

        address lastvalue = _items.array[_items.array.length  1];
        _items.table[lastvalue].index = item.index;
        _items.array[item.index] = lastvalue;
        _items.array.length;
        delete _items.table[_value];
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract converterupgrader is iconverterupgrader, contractregistryclient {
    address private constant eth_reserve_address = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;
    iethertoken public ethertoken;

    
    event converterowned(address indexed _converter, address indexed _owner);

    
    event converterupgrade(address indexed _oldconverter, address indexed _newconverter);

    
    constructor(icontractregistry _registry, iethertoken _ethertoken) contractregistryclient(_registry) public {
        ethertoken = _ethertoken;
    }

    
    function upgrade(bytes32 _version) public {
        upgradeold(iconverter(msg.sender), _version);
    }

    
    function upgrade(uint16 _version) public {
        upgradeold(iconverter(msg.sender), bytes32(_version));
    }

    
    function upgradeold(iconverter _converter, bytes32 _version) public {
        _version;
        iconverter converter = iconverter(_converter);
        address prevowner = converter.owner();
        acceptconverterownership(converter);
        iconverter newconverter = createconverter(converter);
        copyreserves(converter, newconverter);
        copyconversionfee(converter, newconverter);
        transferreservebalances(converter, newconverter);
        iconverteranchor anchor = converter.token();

        
        bool activate = isv28orhigherconverter(converter) && converter.isactive();

        if (anchor.owner() == address(converter)) {
            converter.transfertokenownership(newconverter);
            newconverter.acceptanchorownership();
        }

        handletypespecificdata(converter, newconverter, activate);

        converter.transferownership(prevowner);
        newconverter.transferownership(prevowner);

        emit converterupgrade(address(converter), address(newconverter));
    }

    
    function acceptconverterownership(iconverter _oldconverter) private {
        _oldconverter.acceptownership();
        emit converterowned(_oldconverter, this);
    }

    
    function createconverter(iconverter _oldconverter) private returns (iconverter) {
        iconverteranchor anchor = _oldconverter.token();
        uint32 maxconversionfee = _oldconverter.maxconversionfee();
        uint16 reservetokencount = _oldconverter.connectortokencount();

        
        uint16 newtype = 0;
        
        if (isv28orhigherconverter(_oldconverter))
            newtype = _oldconverter.convertertype();
        
        else if (reservetokencount > 1)
            newtype = 1;

        iconverterfactory converterfactory = iconverterfactory(addressof(converter_factory));
        iconverter converter = converterfactory.createconverter(newtype, anchor, registry, maxconversionfee);

        converter.acceptownership();
        return converter;
    }

    
    function copyreserves(iconverter _oldconverter, iconverter _newconverter) private {
        uint16 reservetokencount = _oldconverter.connectortokencount();

        for (uint16 i = 0; i < reservetokencount; i++) {
            address reserveaddress = _oldconverter.connectortokens(i);
            (, uint32 weight, , , ) = _oldconverter.connectors(reserveaddress);

            
            if (reserveaddress == eth_reserve_address) {
                _newconverter.addreserve(ierc20token(eth_reserve_address), weight);
            }
            
            else if (reserveaddress == address(ethertoken)) {
                _newconverter.addreserve(ierc20token(eth_reserve_address), weight);
            }
            
            else {
                _newconverter.addreserve(ierc20token(reserveaddress), weight);
            }
        }
    }

    
    function copyconversionfee(iconverter _oldconverter, iconverter _newconverter) private {
        uint32 conversionfee = _oldconverter.conversionfee();
        _newconverter.setconversionfee(conversionfee);
    }

    
    function transferreservebalances(iconverter _oldconverter, iconverter _newconverter) private {
        uint256 reservebalance;
        uint16 reservetokencount = _oldconverter.connectortokencount();

        for (uint16 i = 0; i < reservetokencount; i++) {
            address reserveaddress = _oldconverter.connectortokens(i);
            
            if (reserveaddress == eth_reserve_address) {
                _oldconverter.withdraweth(address(_newconverter));
            }
            
            else if (reserveaddress == address(ethertoken)) {
                reservebalance = ethertoken.balanceof(_oldconverter);
                _oldconverter.withdrawtokens(ethertoken, address(this), reservebalance);
                ethertoken.withdrawto(address(_newconverter), reservebalance);
            }
            
            else {
                ierc20token connector = ierc20token(reserveaddress);
                reservebalance = connector.balanceof(_oldconverter);
                _oldconverter.withdrawtokens(connector, address(_newconverter), reservebalance);
            }
        }
    }

    
    function handletypespecificdata(iconverter _oldconverter, iconverter _newconverter, bool _activate) private {
        if (!isv28orhigherconverter(_oldconverter))
            return;

        uint16 convertertype = _oldconverter.convertertype();
        if (convertertype == 2) {
            uint16 reservetokencount = _oldconverter.connectortokencount();
            for (uint16 i = 0; i < reservetokencount; i++) {
                
                ierc20token reservetokenaddress = _oldconverter.connectortokens(i);
                uint256 balance = iliquiditypoolv2converter(_oldconverter).reservestakedbalance(reservetokenaddress);
                iliquiditypoolv2converter(_newconverter).setreservestakedbalance(reservetokenaddress, balance);
            }

            if (!_activate) {
                return;
            }

            
            ierc20token primaryreservetoken = iliquiditypoolv2converter(_oldconverter).primaryreservetoken();

            
            ipriceoracle priceoracle = iliquiditypoolv2converter(_oldconverter).priceoracle();
            ichainlinkpriceoracle oraclea = priceoracle.tokenaoracle();
            ichainlinkpriceoracle oracleb = priceoracle.tokenboracle();

            
            iliquiditypoolv2converter(_newconverter).activate(primaryreservetoken, oraclea, oracleb);
        }
    }

    bytes4 private constant is_v28_or_higher_func_selector = bytes4(keccak256());

    
    
    function isv28orhigherconverter(iconverter _converter) internal view returns (bool) {
        bool success;
        uint256[1] memory ret;
        bytes memory data = abi.encodewithselector(is_v28_or_higher_func_selector);

        assembly {
            success := staticcall(
                5000,          
                _converter,    
                add(data, 32), 
                mload(data),   
                ret,           
                32             
            )
        }

        return success && ret[0] != 0;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;
import ;


contract converterregistry is iconverterregistry, contractregistryclient, tokenhandler {
    address private constant eth_reserve_address = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;

    
    event converteranchoradded(address indexed _anchor);

    
    event converteranchorremoved(address indexed _anchor);

    
    event liquiditypooladded(address indexed _liquiditypool);

    
    event liquiditypoolremoved(address indexed _liquiditypool);

    
    event convertibletokenadded(address indexed _convertibletoken, address indexed _smarttoken);

    
    event convertibletokenremoved(address indexed _convertibletoken, address indexed _smarttoken);

    
    event smarttokenadded(address indexed _smarttoken);

    
    event smarttokenremoved(address indexed _smarttoken);

    
    constructor(icontractregistry _registry) contractregistryclient(_registry) public {
    }

    
    function newconverter(
        uint16 _type,
        string _name,
        string _symbol,
        uint8 _decimals,
        uint32 _maxconversionfee,
        ierc20token[] memory _reservetokens,
        uint32[] memory _reserveweights
    )
    public returns (iconverter)
    {
        uint256 length = _reservetokens.length;
        require(length == _reserveweights.length, );
        require(getliquiditypoolbyconfig(_type, _reservetokens, _reserveweights) == iconverteranchor(0), );

        iconverterfactory factory = iconverterfactory(addressof(converter_factory));
        iconverteranchor anchor = iconverteranchor(factory.createanchor(_type, _name, _symbol, _decimals));
        iconverter converter = iconverter(factory.createconverter(_type, anchor, registry, _maxconversionfee));

        anchor.acceptownership();
        converter.acceptownership();

        for (uint256 i = 0; i < length; i++)
            converter.addreserve(_reservetokens[i], _reserveweights[i]);

        anchor.transferownership(converter);
        converter.acceptanchorownership();
        converter.transferownership(msg.sender);

        addconverterinternal(converter);
        return converter;
    }

    
    function addconverter(iconverter _converter) public owneronly {
        require(isconvertervalid(_converter), );
        addconverterinternal(_converter);
    }

    
    function removeconverter(iconverter _converter) public {
        require(msg.sender == owner || !isconvertervalid(_converter), );
        removeconverterinternal(_converter);
    }

    
    function getanchorcount() public view returns (uint256) {
        return iconverterregistrydata(addressof(converter_registry_data)).getsmarttokencount();
    }

    
    function getanchors() public view returns (address[]) {
        return iconverterregistrydata(addressof(converter_registry_data)).getsmarttokens();
    }

    
    function getanchor(uint256 _index) public view returns (address) {
        return iconverterregistrydata(addressof(converter_registry_data)).getsmarttoken(_index);
    }

    
    function isanchor(address _value) public view returns (bool) {
        return iconverterregistrydata(addressof(converter_registry_data)).issmarttoken(_value);
    }

    
    function getliquiditypoolcount() public view returns (uint256) {
        return iconverterregistrydata(addressof(converter_registry_data)).getliquiditypoolcount();
    }

    
    function getliquiditypools() public view returns (address[]) {
        return iconverterregistrydata(addressof(converter_registry_data)).getliquiditypools();
    }

    
    function getliquiditypool(uint256 _index) public view returns (address) {
        return iconverterregistrydata(addressof(converter_registry_data)).getliquiditypool(_index);
    }

    
    function isliquiditypool(address _value) public view returns (bool) {
        return iconverterregistrydata(addressof(converter_registry_data)).isliquiditypool(_value);
    }

    
    function getconvertibletokencount() public view returns (uint256) {
        return iconverterregistrydata(addressof(converter_registry_data)).getconvertibletokencount();
    }

    
    function getconvertibletokens() public view returns (address[]) {
        return iconverterregistrydata(addressof(converter_registry_data)).getconvertibletokens();
    }

    
    function getconvertibletoken(uint256 _index) public view returns (address) {
        return iconverterregistrydata(addressof(converter_registry_data)).getconvertibletoken(_index);
    }

    
    function isconvertibletoken(address _value) public view returns (bool) {
        return iconverterregistrydata(addressof(converter_registry_data)).isconvertibletoken(_value);
    }

    
    function getconvertibletokenanchorcount(address _convertibletoken) public view returns (uint256) {
        return iconverterregistrydata(addressof(converter_registry_data)).getconvertibletokensmarttokencount(_convertibletoken);
    }

    
    function getconvertibletokenanchors(address _convertibletoken) public view returns (address[]) {
        return iconverterregistrydata(addressof(converter_registry_data)).getconvertibletokensmarttokens(_convertibletoken);
    }

    
    function getconvertibletokenanchor(address _convertibletoken, uint256 _index) public view returns (address) {
        return iconverterregistrydata(addressof(converter_registry_data)).getconvertibletokensmarttoken(_convertibletoken, _index);
    }

    
    function isconvertibletokenanchor(address _convertibletoken, address _value) public view returns (bool) {
        return iconverterregistrydata(addressof(converter_registry_data)).isconvertibletokensmarttoken(_convertibletoken, _value);
    }

    
    function getconvertersbyanchors(address[] _anchors) public view returns (address[]) {
        address[] memory converters = new address[](_anchors.length);

        for (uint256 i = 0; i < _anchors.length; i++)
            converters[i] = iconverteranchor(_anchors[i]).owner();

        return converters;
    }

    
    function isconvertervalid(iconverter _converter) public view returns (bool) {
        
        return _converter.token().owner() == address(_converter);
    }

    
    function issimilarliquiditypoolregistered(iconverter _converter) public view returns (bool) {
        uint256 reservetokencount = _converter.connectortokencount();
        ierc20token[] memory reservetokens = new ierc20token[](reservetokencount);
        uint32[] memory reserveweights = new uint32[](reservetokencount);

        
        for (uint256 i = 0; i < reservetokencount; i++) {
            ierc20token reservetoken = _converter.connectortokens(i);
            reservetokens[i] = reservetoken;
            reserveweights[i] = getreserveweight(_converter, reservetoken);
        }

        
        return getliquiditypoolbyconfig(_converter.convertertype(), reservetokens, reserveweights) != iconverteranchor(0);
    }

    
    function getliquiditypoolbyconfig(uint16 _type, ierc20token[] memory _reservetokens, uint32[] memory _reserveweights) public view returns (iconverteranchor) {
        
        if (_reservetokens.length == _reserveweights.length && _reservetokens.length > 1) {
            
            address[] memory convertibletokenanchors = getleastfrequenttokenanchors(_reservetokens);
            
            for (uint256 i = 0; i < convertibletokenanchors.length; i++) {
                iconverteranchor anchor = iconverteranchor(convertibletokenanchors[i]);
                iconverter converter = iconverter(anchor.owner());
                if (isconverterreserveconfigequal(converter, _type, _reservetokens, _reserveweights))
                    return anchor;
            }
        }

        return iconverteranchor(0);
    }

    
    function addanchor(iconverterregistrydata _converterregistrydata, address _anchor) internal {
        _converterregistrydata.addsmarttoken(_anchor);
        emit converteranchoradded(_anchor);
        emit smarttokenadded(_anchor);
    }

    
    function removeanchor(iconverterregistrydata _converterregistrydata, address _anchor) internal {
        _converterregistrydata.removesmarttoken(_anchor);
        emit converteranchorremoved(_anchor);
        emit smarttokenremoved(_anchor);
    }

    
    function addliquiditypool(iconverterregistrydata _converterregistrydata, address _liquiditypool) internal {
        _converterregistrydata.addliquiditypool(_liquiditypool);
        emit liquiditypooladded(_liquiditypool);
    }

    
    function removeliquiditypool(iconverterregistrydata _converterregistrydata, address _liquiditypool) internal {
        _converterregistrydata.removeliquiditypool(_liquiditypool);
        emit liquiditypoolremoved(_liquiditypool);
    }

    
    function addconvertibletoken(iconverterregistrydata _converterregistrydata, address _convertibletoken, address _anchor) internal {
        _converterregistrydata.addconvertibletoken(_convertibletoken, _anchor);
        emit convertibletokenadded(_convertibletoken, _anchor);
    }

    
    function removeconvertibletoken(iconverterregistrydata _converterregistrydata, address _convertibletoken, address _anchor) internal {
        _converterregistrydata.removeconvertibletoken(_convertibletoken, _anchor);
        emit convertibletokenremoved(_convertibletoken, _anchor);
    }

    function addconverterinternal(iconverter _converter) private {
        iconverterregistrydata converterregistrydata = iconverterregistrydata(addressof(converter_registry_data));
        iconverteranchor anchor = iconverter(_converter).token();
        uint256 reservetokencount = _converter.connectortokencount();

        
        addanchor(converterregistrydata, anchor);
        if (reservetokencount > 1)
            addliquiditypool(converterregistrydata, anchor);
        else
            addconvertibletoken(converterregistrydata, anchor, anchor);

        
        for (uint256 i = 0; i < reservetokencount; i++)
            addconvertibletoken(converterregistrydata, _converter.connectortokens(i), anchor);
    }

    function removeconverterinternal(iconverter _converter) private {
        iconverterregistrydata converterregistrydata = iconverterregistrydata(addressof(converter_registry_data));
        iconverteranchor anchor = iconverter(_converter).token();
        uint256 reservetokencount = _converter.connectortokencount();

        
        removeanchor(converterregistrydata, anchor);
        if (reservetokencount > 1)
            removeliquiditypool(converterregistrydata, anchor);
        else
            removeconvertibletoken(converterregistrydata, anchor, anchor);

        
        for (uint256 i = 0; i < reservetokencount; i++)
            removeconvertibletoken(converterregistrydata, _converter.connectortokens(i), anchor);
    }

    function getleastfrequenttokenanchors(ierc20token[] memory _reservetokens) private view returns (address[] memory) {
        iconverterregistrydata converterregistrydata = iconverterregistrydata(addressof(converter_registry_data));
        uint256 minanchorcount = converterregistrydata.getconvertibletokensmarttokencount(_reservetokens[0]);
        uint256 index = 0;

        
        for (uint256 i = 1; i < _reservetokens.length; i++) {
            uint256 convertibletokenanchorcount = converterregistrydata.getconvertibletokensmarttokencount(_reservetokens[i]);
            if (minanchorcount > convertibletokenanchorcount) {
                minanchorcount = convertibletokenanchorcount;
                index = i;
            }
        }

        return converterregistrydata.getconvertibletokensmarttokens(_reservetokens[index]);
    }

    function isconverterreserveconfigequal(iconverter _converter, uint16 _type, ierc20token[] memory _reservetokens, uint32[] memory _reserveweights) private view returns (bool) {
        if (_type != _converter.convertertype())
            return false;

        if (_reservetokens.length != _converter.connectortokencount())
            return false;

        for (uint256 i = 0; i < _reservetokens.length; i++) {
            if (_reserveweights[i] != getreserveweight(_converter, _reservetokens[i]))
                return false;
        }

        return true;
    }

    bytes4 private constant connectors_func_selector = bytes4(keccak256());

    
    
    
    function getreserveweight(address _converter, address _reservetoken) private view returns (uint32) {
        uint256[2] memory ret;
        bytes memory data = abi.encodewithselector(connectors_func_selector, _reservetoken);

        assembly {
            let success := staticcall(
                gas,           
                _converter,    
                add(data, 32), 
                mload(data),   
                ret,           
                64             
            )
            if iszero(success) {
                revert(0, 0)
            }
        }

        return uint32(ret[1]);
    }

    
    function getsmarttokencount() public view returns (uint256) {
        return getanchorcount();
    }

    
    function getsmarttokens() public view returns (address[]) {
        return getanchors();
    }

    
    function getsmarttoken(uint256 _index) public view returns (address) {
        return getanchor(_index);
    }

    
    function issmarttoken(address _value) public view returns (bool) {
        return isanchor(_value);
    }

    
    function getconvertibletokensmarttokencount(address _convertibletoken) public view returns (uint256) {
        return getconvertibletokenanchorcount(_convertibletoken);
    }

    
    function getconvertibletokensmarttokens(address _convertibletoken) public view returns (address[]) {
        return getconvertibletokenanchors(_convertibletoken);
    }

    
    function getconvertibletokensmarttoken(address _convertibletoken, uint256 _index) public view returns (address) {
        return getconvertibletokenanchor(_convertibletoken, _index);
    }

    
    function isconvertibletokensmarttoken(address _convertibletoken, address _value) public view returns (bool) {
        return isconvertibletokenanchor(_convertibletoken, _value);
    }

    
    function getconvertersbysmarttokens(address[] _smarttokens) public view returns (address[]) {
        return getconvertersbyanchors(_smarttokens);
    }

    
    function getliquiditypoolbyreserveconfig(ierc20token[] memory _reservetokens, uint32[] memory _reserveweights) public view returns (iconverteranchor) {
        return getliquiditypoolbyconfig(1, _reservetokens, _reserveweights);
    }
}

pragma solidity 0.4.26;
import ;


contract liquiditypoolconverter is converterbase {
    
    event liquidityadded(
        address indexed _provider,
        address indexed _reservetoken,
        uint256 _amount,
        uint256 _newbalance,
        uint256 _newsupply
    );

    
    event liquidityremoved(
        address indexed _provider,
        address indexed _reservetoken,
        uint256 _amount,
        uint256 _newbalance,
        uint256 _newsupply
    );

    
    constructor(
        iconverteranchor _anchor,
        icontractregistry _registry,
        uint32 _maxconversionfee
    )
        converterbase(_anchor, _registry, _maxconversionfee)
        internal
    {
    }

    
    function accepttokenownership() public {
        
        require(reservetokencount() > 1, );
        super.accepttokenownership();
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract converterfactory is iconverterfactory, owned {
    
    event newconverter(address indexed _converter, address indexed _owner);

    mapping (uint16 => itypedconverterfactory) public converterfactories;
    mapping (uint16 => itypedconverteranchorfactory) public anchorfactories;
    mapping (uint16 => itypedconvertercustomfactory) public customfactories;

    
    function registertypedconverterfactory(itypedconverterfactory _factory) public owneronly {
        converterfactories[_factory.convertertype()] = _factory;
    }

    
    function registertypedconverteranchorfactory(itypedconverteranchorfactory _factory) public owneronly {
        anchorfactories[_factory.convertertype()] = _factory;
    }

    
    function registertypedconvertercustomfactory(itypedconvertercustomfactory _factory) public owneronly {
        customfactories[_factory.convertertype()] = _factory;
    }

    
    function createanchor(uint16 _convertertype, string _name, string _symbol, uint8 _decimals) public returns (iconverteranchor) {
        iconverteranchor anchor;
        itypedconverteranchorfactory factory = anchorfactories[_convertertype];

        if (factory == address(0)) {
            
            anchor = new smarttoken(_name, _symbol, _decimals);
        }
        else {
            
            anchor = factory.createanchor(_name, _symbol, _decimals);
            anchor.acceptownership();
        }

        anchor.transferownership(msg.sender);
        return anchor;
    }

    
    function createconverter(uint16 _type, iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter) {
        iconverter converter = converterfactories[_type].createconverter(_anchor, _registry, _maxconversionfee);
        converter.acceptownership();
        converter.transferownership(msg.sender);

        emit newconverter(converter, msg.sender);
        return converter;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;
import ;


contract converterbase is iconverter, tokenhandler, tokenholder, contractregistryclient, reentrancyguard {
    using safemath for uint256;

    uint32 internal constant weight_resolution = 1000000;
    uint64 internal constant conversion_fee_resolution = 1000000;
    address internal constant eth_reserve_address = 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;

    struct reserve {
        uint256 balance;    
        uint32 weight;      
        bool deprecated1;   
        bool deprecated2;   
        bool isset;         
    }

    
    uint16 public constant version = 30;

    iconverteranchor public anchor;                 
    iwhitelist public conversionwhitelist;          
    ierc20token[] public reservetokens;             
    mapping (address => reserve) public reserves;   
    uint32 public reserveratio = 0;                 
    uint32 public maxconversionfee = 0;             
                                                    
    uint32 public conversionfee = 0;                
    bool public constant conversionsenabled = true; 

    
    event activation(iconverteranchor _anchor, bool _activated);

    
    event conversion(
        address indexed _fromtoken,
        address indexed _totoken,
        address indexed _trader,
        uint256 _amount,
        uint256 _return,
        int256 _conversionfee
    );

    
    event tokenrateupdate(
        address indexed _token1,
        address indexed _token2,
        uint256 _raten,
        uint256 _rated
    );

    
    event conversionfeeupdate(uint32 _prevfee, uint32 _newfee);

    
    constructor(
        iconverteranchor _anchor,
        icontractregistry _registry,
        uint32 _maxconversionfee
    )
        validaddress(_anchor)
        contractregistryclient(_registry)
        internal
        validconversionfee(_maxconversionfee)
    {
        anchor = _anchor;
        maxconversionfee = _maxconversionfee;
    }

    
    modifier active() {
        _active();
        _;
    }

    
    function _active() internal view {
        require(isactive(), );
    }

    
    modifier inactive() {
        _inactive();
        _;
    }

    
    function _inactive() internal view {
        require(!isactive(), );
    }

    
    modifier validreserve(ierc20token _address) {
        _validreserve(_address);
        _;
    }

    
    function _validreserve(ierc20token _address) internal view {
        require(reserves[_address].isset, );
    }

    
    modifier validconversionfee(uint32 _conversionfee) {
        _validconversionfee(_conversionfee);
        _;
    }

    
    function _validconversionfee(uint32 _conversionfee) internal pure {
        require(_conversionfee <= conversion_fee_resolution, );
    }

    
    modifier validreserveweight(uint32 _weight) {
        _validreserveweight(_weight);
        _;
    }

    
    function _validreserveweight(uint32 _weight) internal pure {
        require(_weight > 0 && _weight <= weight_resolution, );
    }

    
    function() external payable {
        require(reserves[eth_reserve_address].isset, ); 
        
        
    }

    
    function withdraweth(address _to)
        public
        protected
        owneronly
        validreserve(ierc20token(eth_reserve_address))
    {
        address converterupgrader = addressof(converter_upgrader);

        
        require(!isactive() || owner == converterupgrader, );
        _to.transfer(address(this).balance);

        
        syncreservebalance(ierc20token(eth_reserve_address));
    }

    
    function isv28orhigher() public pure returns (bool) {
        return true;
    }

    
    function setconversionwhitelist(iwhitelist _whitelist)
        public
        owneronly
        notthis(_whitelist)
    {
        conversionwhitelist = _whitelist;
    }

    
    function isactive() public view returns (bool) {
        return anchor.owner() == address(this);
    }

    
    function transferanchorownership(address _newowner)
        public
        owneronly
        only(converter_upgrader)
    {
        anchor.transferownership(_newowner);
    }

    
    function acceptanchorownership() public owneronly {
        
        require(reservetokencount() > 0, );
        anchor.acceptownership();
        syncreservebalances();
    }

    
    function withdrawfromanchor(ierc20token _token, address _to, uint256 _amount) public owneronly {
        anchor.withdrawtokens(_token, _to, _amount);
    }

    
    function setconversionfee(uint32 _conversionfee) public owneronly {
        require(_conversionfee <= maxconversionfee, );
        emit conversionfeeupdate(conversionfee, _conversionfee);
        conversionfee = _conversionfee;
    }

    
    function withdrawtokens(ierc20token _token, address _to, uint256 _amount) public protected owneronly {
        address converterupgrader = addressof(converter_upgrader);

        
        
        require(!reserves[_token].isset || !isactive() || owner == converterupgrader, );
        super.withdrawtokens(_token, _to, _amount);

        
        if (reserves[_token].isset)
            syncreservebalance(_token);
    }

    
    function upgrade() public owneronly {
        iconverterupgrader converterupgrader = iconverterupgrader(addressof(converter_upgrader));

        
        emit activation(anchor, false);

        transferownership(converterupgrader);
        converterupgrader.upgrade(version);
        acceptownership();
    }

    
    function reservetokencount() public view returns (uint16) {
        return uint16(reservetokens.length);
    }

    
    function addreserve(ierc20token _token, uint32 _weight)
        public
        owneronly
        inactive
        validaddress(_token)
        notthis(_token)
        validreserveweight(_weight)
    {
        
        require(_token != address(anchor) && !reserves[_token].isset, );
        require(_weight <= weight_resolution  reserveratio, );
        require(reservetokencount() < uint16(1), );

        reserve storage newreserve = reserves[_token];
        newreserve.balance = 0;
        newreserve.weight = _weight;
        newreserve.isset = true;
        reservetokens.push(_token);
        reserveratio += _weight;
    }

    
    function reserveweight(ierc20token _reservetoken)
        public
        view
        validreserve(_reservetoken)
        returns (uint32)
    {
        return reserves[_reservetoken].weight;
    }

    
    function reservebalance(ierc20token _reservetoken)
        public
        view
        validreserve(_reservetoken)
        returns (uint256)
    {
        return reserves[_reservetoken].balance;
    }

    
    function hasethreserve() public view returns (bool) {
        return reserves[eth_reserve_address].isset;
    }

    
    function convert(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount, address _trader, address _beneficiary)
        public
        payable
        protected
        only(bancor_network)
        returns (uint256)
    {
        
        require(_sourcetoken != _targettoken, );

        
        require(conversionwhitelist == address(0) ||
                (conversionwhitelist.iswhitelisted(_trader) && conversionwhitelist.iswhitelisted(_beneficiary)),
                );

        return doconvert(_sourcetoken, _targettoken, _amount, _trader, _beneficiary);
    }

    
    function doconvert(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount, address _trader, address _beneficiary) internal returns (uint256);

    
    function calculatefee(uint256 _targetamount) internal view returns (uint256) {
        return _targetamount.mul(conversionfee).div(conversion_fee_resolution);
    }

    
    function syncreservebalance(ierc20token _reservetoken) internal validreserve(_reservetoken) {
        if (_reservetoken == eth_reserve_address)
            reserves[_reservetoken].balance = address(this).balance;
        else
            reserves[_reservetoken].balance = _reservetoken.balanceof(this);
    }

    
    function syncreservebalances() internal {
        uint256 reservecount = reservetokens.length;
        for (uint256 i = 0; i < reservecount; i++)
            syncreservebalance(reservetokens[i]);
    }

    
    function dispatchconversionevent(
        ierc20token _sourcetoken,
        ierc20token _targettoken,
        address _trader,
        uint256 _amount,
        uint256 _returnamount,
        uint256 _feeamount)
        internal
    {
        
        
        
        
        assert(_feeamount < 2 ** 255);
        emit conversion(_sourcetoken, _targettoken, _trader, _amount, _returnamount, int256(_feeamount));
    }

    
    function token() public view returns (iconverteranchor) {
        return anchor;
    }

    
    function transfertokenownership(address _newowner) public owneronly {
        transferanchorownership(_newowner);
    }

    
    function accepttokenownership() public owneronly {
        acceptanchorownership();
    }

    
    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool) {
        reserve memory reserve = reserves[_address];
        return(reserve.balance, reserve.weight, false, false, reserve.isset);
    }

    
    function connectortokens(uint256 _index) public view returns (ierc20token) {
        return converterbase.reservetokens[_index];
    }

    
    function connectortokencount() public view returns (uint16) {
        return reservetokencount();
    }

    
    function getconnectorbalance(ierc20token _connectortoken) public view returns (uint256) {
        return reservebalance(_connectortoken);
    }

    
    function getreturn(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount) public view returns (uint256, uint256) {
        return targetamountandfee(_sourcetoken, _targettoken, _amount);
    }
}

pragma solidity 0.4.26;
import ;
import ;

contract bancorformula is ibancorformula {
    using safemath for uint256;

    uint16 public constant version = 8;

    uint256 private constant one = 1;
    uint32 private constant max_weight = 1000000;
    uint8 private constant min_precision = 32;
    uint8 private constant max_precision = 127;

    
    uint256 private constant fixed_1 = 0x080000000000000000000000000000000;
    uint256 private constant fixed_2 = 0x100000000000000000000000000000000;
    uint256 private constant max_num = 0x200000000000000000000000000000000;

    
    uint256 private constant ln2_numerator   = 0x3f80fe03f80fe03f80fe03f80fe03f8;
    uint256 private constant ln2_denominator = 0x5b9de1d10bf4103d647b0955897ba80;

    
    uint256 private constant opt_log_max_val = 0x15bf0a8b1457695355fb8ac404e7a79e3;
    uint256 private constant opt_exp_max_val = 0x800000000000000000000000000000000;

    
    uint256 private constant lambert_conv_radius = 0x002f16ac6c59de6f8d5d6f63c1482a7c86;
    uint256 private constant lambert_pos2_sample = 0x0003060c183060c183060c183060c18306;
    uint256 private constant lambert_pos2_maxval = 0x01af16ac6c59de6f8d5d6f63c1482a7c80;
    uint256 private constant lambert_pos3_maxval = 0x6b22d43e72c326539cceeef8bb48f255ff;

    
    uint256 private constant max_unf_weight = 0x10c6f7a0b5ed8d36b4c7f34938583621fafc8b0079a2834d26fa3fcc9ea9;

    
    uint256[128] private maxexparray;
    function initmaxexparray() private {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
        maxexparray[ 32] = 0x1c35fedd14ffffffffffffffffffffffff;
        maxexparray[ 33] = 0x1b0ce43b323fffffffffffffffffffffff;
        maxexparray[ 34] = 0x19f0028ec1ffffffffffffffffffffffff;
        maxexparray[ 35] = 0x18ded91f0e7fffffffffffffffffffffff;
        maxexparray[ 36] = 0x17d8ec7f0417ffffffffffffffffffffff;
        maxexparray[ 37] = 0x16ddc6556cdbffffffffffffffffffffff;
        maxexparray[ 38] = 0x15ecf52776a1ffffffffffffffffffffff;
        maxexparray[ 39] = 0x15060c256cb2ffffffffffffffffffffff;
        maxexparray[ 40] = 0x1428a2f98d72ffffffffffffffffffffff;
        maxexparray[ 41] = 0x13545598e5c23fffffffffffffffffffff;
        maxexparray[ 42] = 0x1288c4161ce1dfffffffffffffffffffff;
        maxexparray[ 43] = 0x11c592761c666fffffffffffffffffffff;
        maxexparray[ 44] = 0x110a688680a757ffffffffffffffffffff;
        maxexparray[ 45] = 0x1056f1b5bedf77ffffffffffffffffffff;
        maxexparray[ 46] = 0x0faadceceeff8bffffffffffffffffffff;
        maxexparray[ 47] = 0x0f05dc6b27edadffffffffffffffffffff;
        maxexparray[ 48] = 0x0e67a5a25da4107fffffffffffffffffff;
        maxexparray[ 49] = 0x0dcff115b14eedffffffffffffffffffff;
        maxexparray[ 50] = 0x0d3e7a392431239fffffffffffffffffff;
        maxexparray[ 51] = 0x0cb2ff529eb71e4fffffffffffffffffff;
        maxexparray[ 52] = 0x0c2d415c3db974afffffffffffffffffff;
        maxexparray[ 53] = 0x0bad03e7d883f69bffffffffffffffffff;
        maxexparray[ 54] = 0x0b320d03b2c343d5ffffffffffffffffff;
        maxexparray[ 55] = 0x0abc25204e02828dffffffffffffffffff;
        maxexparray[ 56] = 0x0a4b16f74ee4bb207fffffffffffffffff;
        maxexparray[ 57] = 0x09deaf736ac1f569ffffffffffffffffff;
        maxexparray[ 58] = 0x0976bd9952c7aa957fffffffffffffffff;
        maxexparray[ 59] = 0x09131271922eaa606fffffffffffffffff;
        maxexparray[ 60] = 0x08b380f3558668c46fffffffffffffffff;
        maxexparray[ 61] = 0x0857ddf0117efa215bffffffffffffffff;
        maxexparray[ 62] = 0x07ffffffffffffffffffffffffffffffff;
        maxexparray[ 63] = 0x07abbf6f6abb9d087fffffffffffffffff;
        maxexparray[ 64] = 0x075af62cbac95f7dfa7fffffffffffffff;
        maxexparray[ 65] = 0x070d7fb7452e187ac13fffffffffffffff;
        maxexparray[ 66] = 0x06c3390ecc8af379295fffffffffffffff;
        maxexparray[ 67] = 0x067c00a3b07ffc01fd6fffffffffffffff;
        maxexparray[ 68] = 0x0637b647c39cbb9d3d27ffffffffffffff;
        maxexparray[ 69] = 0x05f63b1fc104dbd39587ffffffffffffff;
        maxexparray[ 70] = 0x05b771955b36e12f7235ffffffffffffff;
        maxexparray[ 71] = 0x057b3d49dda84556d6f6ffffffffffffff;
        maxexparray[ 72] = 0x054183095b2c8ececf30ffffffffffffff;
        maxexparray[ 73] = 0x050a28be635ca2b888f77fffffffffffff;
        maxexparray[ 74] = 0x04d5156639708c9db33c3fffffffffffff;
        maxexparray[ 75] = 0x04a23105873875bd52dfdfffffffffffff;
        maxexparray[ 76] = 0x0471649d87199aa990756fffffffffffff;
        maxexparray[ 77] = 0x04429a21a029d4c1457cfbffffffffffff;
        maxexparray[ 78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;
        maxexparray[ 79] = 0x03eab73b3bbfe282243ce1ffffffffffff;
        maxexparray[ 80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;
        maxexparray[ 81] = 0x0399e96897690418f785257fffffffffff;
        maxexparray[ 82] = 0x0373fc456c53bb779bf0ea9fffffffffff;
        maxexparray[ 83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;
        maxexparray[ 84] = 0x032cbfd4a7adc790560b3337ffffffffff;
        maxexparray[ 85] = 0x030b50570f6e5d2acca94613ffffffffff;
        maxexparray[ 86] = 0x02eb40f9f620fda6b56c2861ffffffffff;
        maxexparray[ 87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;
        maxexparray[ 88] = 0x02af09481380a0a35cf1ba02ffffffffff;
        maxexparray[ 89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;
        maxexparray[ 90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;
        maxexparray[ 91] = 0x025daf6654b1eaa55fd64df5efffffffff;
        maxexparray[ 92] = 0x0244c49c648baa98192dce88b7ffffffff;
        maxexparray[ 93] = 0x022ce03cd5619a311b2471268bffffffff;
        maxexparray[ 94] = 0x0215f77c045fbe885654a44a0fffffffff;
        maxexparray[ 95] = 0x01ffffffffffffffffffffffffffffffff;
        maxexparray[ 96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;
        maxexparray[ 97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;
        maxexparray[ 98] = 0x01c35fedd14b861eb0443f7f133fffffff;
        maxexparray[ 99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;
        maxexparray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;
        maxexparray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;
        maxexparray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;
        maxexparray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;
        maxexparray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;
        maxexparray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;
        maxexparray[106] = 0x01428a2f98d728ae223ddab715be3fffff;
        maxexparray[107] = 0x013545598e5c23276ccf0ede68034fffff;
        maxexparray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;
        maxexparray[109] = 0x011c592761c666aa641d5a01a40f17ffff;
        maxexparray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;
        maxexparray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;
        maxexparray[112] = 0x00faadceceeff8a0890f3875f008277fff;
        maxexparray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;
        maxexparray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;
        maxexparray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;
        maxexparray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;
        maxexparray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;
        maxexparray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;
        maxexparray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;
        maxexparray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;
        maxexparray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;
        maxexparray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;
        maxexparray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;
        maxexparray[124] = 0x00976bd9952c7aa957f5937d790ef65037;
        maxexparray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;
        maxexparray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;
        maxexparray[127] = 0x00857ddf0117efa215952912839f6473e6;
    }

    
    uint256[128] private lambertarray;
    function initlambertarray() private {
        lambertarray[  0] = 0x60e393c68d20b1bd09deaabc0373b9c5;
        lambertarray[  1] = 0x5f8f46e4854120989ed94719fb4c2011;
        lambertarray[  2] = 0x5e479ebb9129fb1b7e72a648f992b606;
        lambertarray[  3] = 0x5d0bd23fe42dfedde2e9586be12b85fe;
        lambertarray[  4] = 0x5bdb29ddee979308ddfca81aeeb8095a;
        lambertarray[  5] = 0x5ab4fd8a260d2c7e2c0d2afcf0009dad;
        lambertarray[  6] = 0x5998b31359a55d48724c65cf09001221;
        lambertarray[  7] = 0x5885bcad2b322dfc43e8860f9c018cf5;
        lambertarray[  8] = 0x577b97aa1fe222bb452fdf111b1f0be2;
        lambertarray[  9] = 0x5679cb5e3575632e5baa27e2b949f704;
        lambertarray[ 10] = 0x557fe8241b3a31c83c732f1cdff4a1c5;
        lambertarray[ 11] = 0x548d868026504875d6e59bbe95fc2a6b;
        lambertarray[ 12] = 0x53a2465ce347cf34d05a867c17dd3088;
        lambertarray[ 13] = 0x52bdce5dcd4faed59c7f5511cf8f8acc;
        lambertarray[ 14] = 0x51dfcb453c07f8da817606e7885f7c3e;
        lambertarray[ 15] = 0x5107ef6b0a5a2be8f8ff15590daa3cce;
        lambertarray[ 16] = 0x5035f241d6eae0cd7bacba119993de7b;
        lambertarray[ 17] = 0x4f698fe90d5b53d532171e1210164c66;
        lambertarray[ 18] = 0x4ea288ca297a0e6a09a0eee240e16c85;
        lambertarray[ 19] = 0x4de0a13fdcf5d4213fc398ba6e3becde;
        lambertarray[ 20] = 0x4d23a145eef91fec06b06140804c4808;
        lambertarray[ 21] = 0x4c6b5430d4c1ee5526473db4ae0f11de;
        lambertarray[ 22] = 0x4bb7886c240562eba11f4963a53b4240;
        lambertarray[ 23] = 0x4b080f3f1cb491d2d521e0ea4583521e;
        lambertarray[ 24] = 0x4a5cbc96a05589cb4d86be1db3168364;
        lambertarray[ 25] = 0x49b566d40243517658d78c33162d6ece;
        lambertarray[ 26] = 0x4911e6a02e5507a30f947383fd9a3276;
        lambertarray[ 27] = 0x487216c2b31be4adc41db8a8d5cc0c88;
        lambertarray[ 28] = 0x47d5d3fc4a7a1b188cd3d788b5c5e9fc;
        lambertarray[ 29] = 0x473cfce4871a2c40bc4f9e1c32b955d0;
        lambertarray[ 30] = 0x46a771ca578ab878485810e285e31c67;
        lambertarray[ 31] = 0x4615149718aed4c258c373dc676aa72d;
        lambertarray[ 32] = 0x4585c8b3f8fe489c6e1833ca47871384;
        lambertarray[ 33] = 0x44f972f174e41e5efb7e9d63c29ce735;
        lambertarray[ 34] = 0x446ff970ba86d8b00beb05ecebf3c4dc;
        lambertarray[ 35] = 0x43e9438ec88971812d6f198b5ccaad96;
        lambertarray[ 36] = 0x436539d11ff7bea657aeddb394e809ef;
        lambertarray[ 37] = 0x42e3c5d3e5a913401d86f66db5d81c2c;
        lambertarray[ 38] = 0x4264d2395303070ea726cbe98df62174;
        lambertarray[ 39] = 0x41e84a9a593bb7194c3a6349ecae4eea;
        lambertarray[ 40] = 0x416e1b785d13eba07a08f3f18876a5ab;
        lambertarray[ 41] = 0x40f6322ff389d423ba9dd7e7e7b7e809;
        lambertarray[ 42] = 0x40807cec8a466880ecf4184545d240a4;
        lambertarray[ 43] = 0x400cea9ce88a8d3ae668e8ea0d9bf07f;
        lambertarray[ 44] = 0x3f9b6ae8772d4c55091e0ed7dfea0ac1;
        lambertarray[ 45] = 0x3f2bee253fd84594f54bcaafac383a13;
        lambertarray[ 46] = 0x3ebe654e95208bb9210c575c081c5958;
        lambertarray[ 47] = 0x3e52c1fc5665635b78ce1f05ad53c086;
        lambertarray[ 48] = 0x3de8f65ac388101ddf718a6f5c1eff65;
        lambertarray[ 49] = 0x3d80f522d59bd0b328ca012df4cd2d49;
        lambertarray[ 50] = 0x3d1ab193129ea72b23648a161163a85a;
        lambertarray[ 51] = 0x3cb61f68d32576c135b95cfb53f76d75;
        lambertarray[ 52] = 0x3c5332d9f1aae851a3619e77e4cc8473;
        lambertarray[ 53] = 0x3bf1e08edbe2aa109e1525f65759ef73;
        lambertarray[ 54] = 0x3b921d9cff13fa2c197746a3dfc4918f;
        lambertarray[ 55] = 0x3b33df818910bfc1a5aefb8f63ae2ac4;
        lambertarray[ 56] = 0x3ad71c1c77e34fa32a9f184967eccbf6;
        lambertarray[ 57] = 0x3a7bc9abf2c5bb53e2f7384a8a16521a;
        lambertarray[ 58] = 0x3a21dec7e76369783a68a0c6385a1c57;
        lambertarray[ 59] = 0x39c9525de6c9cdf7c1c157ca4a7a6ee3;
        lambertarray[ 60] = 0x39721bad3dc85d1240ff0190e0adaac3;
        lambertarray[ 61] = 0x391c324344d3248f0469eb28dd3d77e0;
        lambertarray[ 62] = 0x38c78df7e3c796279fb4ff84394ab3da;
        lambertarray[ 63] = 0x387426ea4638ae9aae08049d3554c20a;
        lambertarray[ 64] = 0x3821f57dbd2763256c1a99bbd2051378;
        lambertarray[ 65] = 0x37d0f256cb46a8c92ff62fbbef289698;
        lambertarray[ 66] = 0x37811658591ffc7abdd1feaf3cef9b73;
        lambertarray[ 67] = 0x37325aa10e9e82f7df0f380f7997154b;
        lambertarray[ 68] = 0x36e4b888cfb408d873b9a80d439311c6;
        lambertarray[ 69] = 0x3698299e59f4bb9de645fc9b08c64cca;
        lambertarray[ 70] = 0x364ca7a5012cb603023b57dd3ebfd50d;
        lambertarray[ 71] = 0x36022c928915b778ab1b06aaee7e61d4;
        lambertarray[ 72] = 0x35b8b28d1a73dc27500ffe35559cc028;
        lambertarray[ 73] = 0x357033e951fe250ec5eb4e60955132d7;
        lambertarray[ 74] = 0x3528ab2867934e3a21b5412e4c4f8881;
        lambertarray[ 75] = 0x34e212f66c55057f9676c80094a61d59;
        lambertarray[ 76] = 0x349c66289e5b3c4b540c24f42fa4b9bb;
        lambertarray[ 77] = 0x34579fbbd0c733a9c8d6af6b0f7d00f7;
        lambertarray[ 78] = 0x3413bad2e712288b924b5882b5b369bf;
        lambertarray[ 79] = 0x33d0b2b56286510ef730e213f71f12e9;
        lambertarray[ 80] = 0x338e82ce00e2496262c64457535ba1a1;
        lambertarray[ 81] = 0x334d26a96b373bb7c2f8ea1827f27a92;
        lambertarray[ 82] = 0x330c99f4f4211469e00b3e18c31475ea;
        lambertarray[ 83] = 0x32ccd87d6486094999c7d5e6f33237d8;
        lambertarray[ 84] = 0x328dde2dd617b6665a2e8556f250c1af;
        lambertarray[ 85] = 0x324fa70e9adc270f8262755af5a99af9;
        lambertarray[ 86] = 0x32122f443110611ca51040f41fa6e1e3;
        lambertarray[ 87] = 0x31d5730e42c0831482f0f1485c4263d8;
        lambertarray[ 88] = 0x31996ec6b07b4a83421b5ebc4ab4e1f1;
        lambertarray[ 89] = 0x315e1ee0a68ff46bb43ec2b85032e876;
        lambertarray[ 90] = 0x31237fe7bc4deacf6775b9efa1a145f8;
        lambertarray[ 91] = 0x30e98e7f1cc5a356e44627a6972ea2ff;
        lambertarray[ 92] = 0x30b04760b8917ec74205a3002650ec05;
        lambertarray[ 93] = 0x3077a75c803468e9132ce0cf3224241d;
        lambertarray[ 94] = 0x303fab57a6a275c36f19cda9bace667a;
        lambertarray[ 95] = 0x3008504beb8dcbd2cf3bc1f6d5a064f0;
        lambertarray[ 96] = 0x2fd19346ed17dac61219ce0c2c5ac4b0;
        lambertarray[ 97] = 0x2f9b7169808c324b5852fd3d54ba9714;
        lambertarray[ 98] = 0x2f65e7e711cf4b064eea9c08cbdad574;
        lambertarray[ 99] = 0x2f30f405093042ddff8a251b6bf6d103;
        lambertarray[100] = 0x2efc931a3750f2e8bfe323edfe037574;
        lambertarray[101] = 0x2ec8c28e46dbe56d98685278339400cb;
        lambertarray[102] = 0x2e957fd933c3926d8a599b602379b851;
        lambertarray[103] = 0x2e62c882c7c9ed4473412702f08ba0e5;
        lambertarray[104] = 0x2e309a221c12ba361e3ed695167feee2;
        lambertarray[105] = 0x2dfef25d1f865ae18dd07cfea4bcea10;
        lambertarray[106] = 0x2dcdcee821cdc80decc02c44344aeb31;
        lambertarray[107] = 0x2d9d2d8562b34944d0b201bb87260c83;
        lambertarray[108] = 0x2d6d0c04a5b62a2c42636308669b729a;
        lambertarray[109] = 0x2d3d6842c9a235517fc5a0332691528f;
        lambertarray[110] = 0x2d0e402963fe1ea2834abc408c437c10;
        lambertarray[111] = 0x2cdf91ae602647908aff975e4d6a2a8c;
        lambertarray[112] = 0x2cb15ad3a1eb65f6d74a75da09a1b6c5;
        lambertarray[113] = 0x2c8399a6ab8e9774d6fcff373d210727;
        lambertarray[114] = 0x2c564c4046f64edba6883ca06bbc4535;
        lambertarray[115] = 0x2c2970c431f952641e05cb493e23eed3;
        lambertarray[116] = 0x2bfd0560cd9eb14563bc7c0732856c18;
        lambertarray[117] = 0x2bd1084ed0332f7ff4150f9d0ef41a2c;
        lambertarray[118] = 0x2ba577d0fa1628b76d040b12a82492fb;
        lambertarray[119] = 0x2b7a5233cd21581e855e89dc2f1e8a92;
        lambertarray[120] = 0x2b4f95cd46904d05d72bdcde337d9cc7;
        lambertarray[121] = 0x2b2540fc9b4d9abba3faca6691914675;
        lambertarray[122] = 0x2afb5229f68d0830d8be8adb0a0db70f;
        lambertarray[123] = 0x2ad1c7c63a9b294c5bc73a3ba3ab7a2b;
        lambertarray[124] = 0x2aa8a04ac3cbe1ee1c9c86361465dbb8;
        lambertarray[125] = 0x2a7fda392d725a44a2c8aeb9ab35430d;
        lambertarray[126] = 0x2a57741b18cde618717792b4faa216db;
        lambertarray[127] = 0x2a2f6c81f5d84dd950a35626d6d5503a;
    }

    
    function init() public {
        initmaxexparray();
        initlambertarray();
    }

    
    function purchasetargetamount(uint256 _supply,
                                  uint256 _reservebalance,
                                  uint32 _reserveweight,
                                  uint256 _amount)
                                  public view returns (uint256)
    {
        
        require(_supply > 0, );
        require(_reservebalance > 0, );
        require(_reserveweight > 0 && _reserveweight <= max_weight, );

        
        if (_amount == 0)
            return 0;

        
        if (_reserveweight == max_weight)
            return _supply.mul(_amount) / _reservebalance;

        uint256 result;
        uint8 precision;
        uint256 basen = _amount.add(_reservebalance);
        (result, precision) = power(basen, _reservebalance, _reserveweight, max_weight);
        uint256 temp = _supply.mul(result) >> precision;
        return temp  _supply;
    }

    
    function saletargetamount(uint256 _supply,
                              uint256 _reservebalance,
                              uint32 _reserveweight,
                              uint256 _amount)
                              public view returns (uint256)
    {
        
        require(_supply > 0, );
        require(_reservebalance > 0, );
        require(_reserveweight > 0 && _reserveweight <= max_weight, );
        require(_amount <= _supply, );

        
        if (_amount == 0)
            return 0;

        
        if (_amount == _supply)
            return _reservebalance;

        
        if (_reserveweight == max_weight)
            return _reservebalance.mul(_amount) / _supply;

        uint256 result;
        uint8 precision;
        uint256 based = _supply  _amount;
        (result, precision) = power(_supply, based, max_weight, _reserveweight);
        uint256 temp1 = _reservebalance.mul(result);
        uint256 temp2 = _reservebalance << precision;
        return (temp1  temp2) / result;
    }

    
    function crossreservetargetamount(uint256 _sourcereservebalance,
                                      uint32 _sourcereserveweight,
                                      uint256 _targetreservebalance,
                                      uint32 _targetreserveweight,
                                      uint256 _amount)
                                      public view returns (uint256)
    {
        
        require(_sourcereservebalance > 0 && _targetreservebalance > 0, );
        require(_sourcereserveweight > 0 && _sourcereserveweight <= max_weight &&
                _targetreserveweight > 0 && _targetreserveweight <= max_weight, );

        
        if (_sourcereserveweight == _targetreserveweight)
            return _targetreservebalance.mul(_amount) / _sourcereservebalance.add(_amount);

        uint256 result;
        uint8 precision;
        uint256 basen = _sourcereservebalance.add(_amount);
        (result, precision) = power(basen, _sourcereservebalance, _sourcereserveweight, _targetreserveweight);
        uint256 temp1 = _targetreservebalance.mul(result);
        uint256 temp2 = _targetreservebalance << precision;
        return (temp1  temp2) / result;
    }

    
    function fundcost(uint256 _supply,
                      uint256 _reservebalance,
                      uint32 _reserveratio,
                      uint256 _amount)
                      public view returns (uint256)
    {
        
        require(_supply > 0, );
        require(_reservebalance > 0, );
        require(_reserveratio > 1 && _reserveratio <= max_weight * 2, );

        
        if (_amount == 0)
            return 0;

        
        if (_reserveratio == max_weight)
            return (_amount.mul(_reservebalance)  1) / _supply + 1;

        uint256 result;
        uint8 precision;
        uint256 basen = _supply.add(_amount);
        (result, precision) = power(basen, _supply, max_weight, _reserveratio);
        uint256 temp = ((_reservebalance.mul(result)  1) >> precision) + 1;
        return temp  _reservebalance;
    }

    
    function fundsupplyamount(uint256 _supply,
                              uint256 _reservebalance,
                              uint32 _reserveratio,
                              uint256 _amount)
                              public view returns (uint256)
    {
        
        require(_supply > 0, );
        require(_reservebalance > 0, );
        require(_reserveratio > 1 && _reserveratio <= max_weight * 2, );

        
        if (_amount == 0)
            return 0;

        
        if (_reserveratio == max_weight)
            return _amount.mul(_supply) / _reservebalance;

        uint256 result;
        uint8 precision;
        uint256 basen = _reservebalance.add(_amount);
        (result, precision) = power(basen, _reservebalance, _reserveratio, max_weight);
        uint256 temp = _supply.mul(result) >> precision;
        return temp  _supply;
    }

    
    function liquidatereserveamount(uint256 _supply,
                                    uint256 _reservebalance,
                                    uint32 _reserveratio,
                                    uint256 _amount)
                                    public view returns (uint256)
    {
        
        require(_supply > 0, );
        require(_reservebalance > 0, );
        require(_reserveratio > 1 && _reserveratio <= max_weight * 2, );
        require(_amount <= _supply, );

        
        if (_amount == 0)
            return 0;

        
        if (_amount == _supply)
            return _reservebalance;

        
        if (_reserveratio == max_weight)
            return _amount.mul(_reservebalance) / _supply;

        uint256 result;
        uint8 precision;
        uint256 based = _supply  _amount;
        (result, precision) = power(_supply, based, max_weight, _reserveratio);
        uint256 temp1 = _reservebalance.mul(result);
        uint256 temp2 = _reservebalance << precision;
        return (temp1  temp2) / result;
    }

    
    function balancedweights(uint256 _primaryreservestakedbalance,
                             uint256 _primaryreservebalance,
                             uint256 _secondaryreservebalance,
                             uint256 _reserveratenumerator,
                             uint256 _reserveratedenominator)
                             public view returns (uint32, uint32)
    {
        if (_primaryreservestakedbalance == _primaryreservebalance)
            require(_primaryreservestakedbalance > 0 || _secondaryreservebalance > 0, );
        else
            require(_primaryreservestakedbalance > 0 && _primaryreservebalance > 0 && _secondaryreservebalance > 0, );
        require(_reserveratenumerator > 0 && _reserveratedenominator > 0, );

        uint256 tp = _primaryreservestakedbalance.mul(_reserveratedenominator);
        uint256 rq = _secondaryreservebalance.mul(_reserveratenumerator);

        if (_primaryreservestakedbalance < _primaryreservebalance)
            return balancedweightsbystake(_primaryreservebalance, _primaryreservestakedbalance, tp, rq, true);

        if (_primaryreservestakedbalance > _primaryreservebalance)
            return balancedweightsbystake(_primaryreservestakedbalance, _primaryreservebalance, tp, rq, false);

        return normalizedweights(tp, rq);
    }

    
    function power(uint256 _basen, uint256 _based, uint32 _expn, uint32 _expd) internal view returns (uint256, uint8) {
        require(_basen < max_num);

        uint256 baselog;
        uint256 base = _basen * fixed_1 / _based;
        if (base < opt_log_max_val) {
            baselog = optimallog(base);
        }
        else {
            baselog = generallog(base);
        }

        uint256 baselogtimesexp = baselog * _expn / _expd;
        if (baselogtimesexp < opt_exp_max_val) {
            return (optimalexp(baselogtimesexp), max_precision);
        }
        else {
            uint8 precision = findpositioninmaxexparray(baselogtimesexp);
            return (generalexp(baselogtimesexp >> (max_precision  precision), precision), precision);
        }
    }

    
    function generallog(uint256 x) internal pure returns (uint256) {
        uint256 res = 0;

        
        if (x >= fixed_2) {
            uint8 count = floorlog2(x / fixed_1);
            x >>= count; 
            res = count * fixed_1;
        }

        
        if (x > fixed_1) {
            for (uint8 i = max_precision; i > 0; i) {
                x = (x * x) / fixed_1; 
                if (x >= fixed_2) {
                    x >>= 1; 
                    res += one << (i  1);
                }
            }
        }

        return res * ln2_numerator / ln2_denominator;
    }

    
    function floorlog2(uint256 _n) internal pure returns (uint8) {
        uint8 res = 0;

        if (_n < 256) {
            
            while (_n > 1) {
                _n >>= 1;
                res += 1;
            }
        }
        else {
            
            for (uint8 s = 128; s > 0; s >>= 1) {
                if (_n >= (one << s)) {
                    _n >>= s;
                    res |= s;
                }
            }
        }

        return res;
    }

    
    function findpositioninmaxexparray(uint256 _x) internal view returns (uint8) {
        uint8 lo = min_precision;
        uint8 hi = max_precision;

        while (lo + 1 < hi) {
            uint8 mid = (lo + hi) / 2;
            if (maxexparray[mid] >= _x)
                lo = mid;
            else
                hi = mid;
        }

        if (maxexparray[hi] >= _x)
            return hi;
        if (maxexparray[lo] >= _x)
            return lo;

        require(false);
    }

    
    function generalexp(uint256 _x, uint8 _precision) internal pure returns (uint256) {
        uint256 xi = _x;
        uint256 res = 0;

        xi = (xi * _x) >> _precision; res += xi * 0x3442c4e6074a82f1797f72ac0000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x116b96f757c380fb287fd0e40000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00defabf91302cd95b9ffda50000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x002529ca9832b22439efff9b8000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00054f1cf12bd04e516b6da88000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000a9e39e257a09ca2d6db51000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x000012e066e7b839fa050c309000000; 
        xi = (xi * _x) >> _precision; res += xi * 0x000001e33d7d926c329a1ad1a800000; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000002bee513bdb4a6b19b5f800000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000003a9316fa79b88eccf2a00000; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000048177ebe1fa812375200000; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000005263fe90242dcbacf00000; 
        xi = (xi * _x) >> _precision; res += xi * 0x000000000057e22099c030d94100000; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000057e22099c030d9410000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000052b6b54569976310000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000004985f67696bf748000; 
        xi = (xi * _x) >> _precision; res += xi * 0x000000000000003dea12ea99e498000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000031880f2214b6e000; 
        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000025bcff56eb36000; 
        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000001b722e10ab1000; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000001317c70077000; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000cba84aafa00; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000082573a0a00; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000005035ad900; 
        xi = (xi * _x) >> _precision; res += xi * 0x000000000000000000000002f881b00; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000001b29340; 
        xi = (xi * _x) >> _precision; res += xi * 0x00000000000000000000000000efc40; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000007fe0; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000420; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000021; 
        xi = (xi * _x) >> _precision; res += xi * 0x0000000000000000000000000000001; 

        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (one << _precision); 
    }

    
    function optimallog(uint256 x) internal pure returns (uint256) {
        uint256 res = 0;

        uint256 y;
        uint256 z;
        uint256 w;

        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {res += 0x40000000000000000000000000000000; x = x * fixed_1 / 0xd3094c70f034de4b96ff7d5b6f99fcd8;} 
        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {res += 0x20000000000000000000000000000000; x = x * fixed_1 / 0xa45af1e1f40c333b3de1db4dd55f29a7;} 
        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {res += 0x10000000000000000000000000000000; x = x * fixed_1 / 0x910b022db7ae67ce76b441c27035c6a1;} 
        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {res += 0x08000000000000000000000000000000; x = x * fixed_1 / 0x88415abbe9a76bead8d00cf112e4d4a8;} 
        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {res += 0x04000000000000000000000000000000; x = x * fixed_1 / 0x84102b00893f64c705e841d5d4064bd3;} 
        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {res += 0x02000000000000000000000000000000; x = x * fixed_1 / 0x8204055aaef1c8bd5c3259f4822735a2;} 
        if (x >= 0x810100ab00222d861931c15e39b44e99) {res += 0x01000000000000000000000000000000; x = x * fixed_1 / 0x810100ab00222d861931c15e39b44e99;} 
        if (x >= 0x808040155aabbbe9451521693554f733) {res += 0x00800000000000000000000000000000; x = x * fixed_1 / 0x808040155aabbbe9451521693554f733;} 

        z = y = x  fixed_1;
        w = y * y / fixed_1;
        res += z * (0x100000000000000000000000000000000  y) / 0x100000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa  y) / 0x200000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x099999999999999999999999999999999  y) / 0x300000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x092492492492492492492492492492492  y) / 0x400000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x08e38e38e38e38e38e38e38e38e38e38e  y) / 0x500000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b  y) / 0x600000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x089d89d89d89d89d89d89d89d89d89d89  y) / 0x700000000000000000000000000000000; z = z * w / fixed_1; 
        res += z * (0x088888888888888888888888888888888  y) / 0x800000000000000000000000000000000;                      

        return res;
    }

    
    function optimalexp(uint256 x) internal pure returns (uint256) {
        uint256 res = 0;

        uint256 y;
        uint256 z;

        z = y = x % 0x10000000000000000000000000000000; 
        z = z * y / fixed_1; res += z * 0x10e1b3be415a0000; 
        z = z * y / fixed_1; res += z * 0x05a0913f6b1e0000; 
        z = z * y / fixed_1; res += z * 0x0168244fdac78000; 
        z = z * y / fixed_1; res += z * 0x004807432bc18000; 
        z = z * y / fixed_1; res += z * 0x000c0135dca04000; 
        z = z * y / fixed_1; res += z * 0x0001b707b1cdc000; 
        z = z * y / fixed_1; res += z * 0x000036e0f639b800; 
        z = z * y / fixed_1; res += z * 0x00000618fee9f800; 
        z = z * y / fixed_1; res += z * 0x0000009c197dcc00; 
        z = z * y / fixed_1; res += z * 0x0000000e30dce400; 
        z = z * y / fixed_1; res += z * 0x000000012ebd1300; 
        z = z * y / fixed_1; res += z * 0x0000000017499f00; 
        z = z * y / fixed_1; res += z * 0x0000000001a9d480; 
        z = z * y / fixed_1; res += z * 0x00000000001c6380; 
        z = z * y / fixed_1; res += z * 0x000000000001c638; 
        z = z * y / fixed_1; res += z * 0x0000000000001ab8; 
        z = z * y / fixed_1; res += z * 0x000000000000017c; 
        z = z * y / fixed_1; res += z * 0x0000000000000014; 
        z = z * y / fixed_1; res += z * 0x0000000000000001; 
        res = res / 0x21c3677c82b40000 + y + fixed_1; 

        if ((x & 0x010000000000000000000000000000000) != 0) res = res * 0x1c3d6a24ed82218787d624d3e5eba95f9 / 0x18ebef9eac820ae8682b9793ac6d1e776; 
        if ((x & 0x020000000000000000000000000000000) != 0) res = res * 0x18ebef9eac820ae8682b9793ac6d1e778 / 0x1368b2fc6f9609fe7aceb46aa619baed4; 
        if ((x & 0x040000000000000000000000000000000) != 0) res = res * 0x1368b2fc6f9609fe7aceb46aa619baed5 / 0x0bc5ab1b16779be3575bd8f0520a9f21f; 
        if ((x & 0x080000000000000000000000000000000) != 0) res = res * 0x0bc5ab1b16779be3575bd8f0520a9f21e / 0x0454aaa8efe072e7f6ddbab84b40a55c9; 
        if ((x & 0x100000000000000000000000000000000) != 0) res = res * 0x0454aaa8efe072e7f6ddbab84b40a55c5 / 0x00960aadc109e7a3bf4578099615711ea; 
        if ((x & 0x200000000000000000000000000000000) != 0) res = res * 0x00960aadc109e7a3bf4578099615711d7 / 0x0002bf84208204f5977f9a8cf01fdce3d; 
        if ((x & 0x400000000000000000000000000000000) != 0) res = res * 0x0002bf84208204f5977f9a8cf01fdc307 / 0x0000003c6ab775dd0b95b4cbee7e65d11; 

        return res;
    }

    
    function lowerstake(uint256 _x) internal view returns (uint256) {
        if (_x <= lambert_conv_radius)
            return lambertpos1(_x);
        if (_x <= lambert_pos2_maxval)
            return lambertpos2(_x);
        if (_x <= lambert_pos3_maxval)
            return lambertpos3(_x);
        require(false);
    }

    
    function higherstake(uint256 _x) internal pure returns (uint256) {
        if (_x <= lambert_conv_radius)
            return lambertneg1(_x);
        return fixed_1 * fixed_1 / _x;
    }

    
    function lambertpos1(uint256 _x) internal pure returns (uint256) {
        uint256 xi = _x;
        uint256 res = (fixed_1  _x) * 0xde1bc4d19efcac82445da75b00000000; 

        xi = (xi * _x) / fixed_1; res += xi * 0x00000000014d29a73a6e7b02c3668c7b0880000000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x0000000002504a0cd9a7f7215b60f9be4800000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000000000484d0a1191c0ead267967c7a4a0000000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x00000000095ec580d7e8427a4baf26a90a00000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000000001440b0be1615a47dba6e5b3b1f10000000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x000000002d207601f46a99b4112418400000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000066ebaac4c37c622dd8288a7eb1b2000000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x00000000ef17240135f7dbd43a1ba10cf200000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000233c33c676a5eb2416094a87b3657000000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x0000000541cde48bc0254bed49a9f8700000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000cae1fad2cdd4d4cb8d73abca0d19a400000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x0000001edb2aa2f760d15c41ceedba956400000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000004ba8d20d2dabd386c9529659841a2e200000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x000000bac08546b867cdaa20000000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000001cfa8e70c03625b9db76c8ebf5bbf24820000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x000004851d99f82060df265f3309b26f8200000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x00000b550d19b129d270c44f6f55f027723cbb0000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x00001c877dadc761dc272deb65d4b0000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000048178ece97479f33a77f2ad22a81b64406c000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x0000b6ca8268b9d810fedf6695ef2f8a6c00000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0001d0e76631a5b05d007b8cb72a7c7f11ec36e000; 
        xi = (xi * _x) / fixed_1; res = xi * 0x0004a1c37bd9f85fd9c6c780000000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000bd8369f1b702bf491e2ebfcee08250313b65400; 
        xi = (xi * _x) / fixed_1; res = xi * 0x001e5c7c32a9f6c70ab2cb59d9225764d400000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x004dff5820e165e910f95120a708e742496221e600; 
        xi = (xi * _x) / fixed_1; res = xi * 0x00c8c8f66db1fced378ee50e536000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0205db8dffff45bfa2938f128f599dbf16eb11d880; 
        xi = (xi * _x) / fixed_1; res = xi * 0x053a044ebd984351493e1786af38d39a0800000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0d86dae2a4cc0f47633a544479735869b487b59c40; 
        xi = (xi * _x) / fixed_1; res = xi * 0x231000000000000000000000000000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x5b0485a76f6646c2039db1507cdd51b08649680822; 
        xi = (xi * _x) / fixed_1; res = xi * 0xec983c46c49545bc17efa6b5b0055e242200000000; 

        return res / 0xde1bc4d19efcac82445da75b00000000; 
    }

    
    function lambertpos2(uint256 _x) internal view returns (uint256) {
        uint256 x = _x  lambert_conv_radius  1;
        uint256 i = x / lambert_pos2_sample;
        uint256 a = lambert_pos2_sample * i;
        uint256 b = lambert_pos2_sample * (i + 1);
        uint256 c = lambertarray[i];
        uint256 d = lambertarray[i + 1];
        return (c * (b  x) + d * (x  a)) / lambert_pos2_sample;
    }

    
    function lambertpos3(uint256 _x) internal pure returns (uint256) {
        uint256 l1 = _x < opt_log_max_val ? optimallog(_x) : generallog(_x);
        uint256 l2 = l1 < opt_log_max_val ? optimallog(l1) : generallog(l1);
        return (l1  l2 + l2 * fixed_1 / l1) * fixed_1 / _x;
    }

    
    function lambertneg1(uint256 _x) internal pure returns (uint256) {
        uint256 xi = _x;
        uint256 res = 0;

        xi = (xi * _x) / fixed_1; res += xi * 0x00000000014d29a73a6e7b02c3668c7b0880000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000002504a0cd9a7f7215b60f9be4800000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000000000484d0a1191c0ead267967c7a4a0000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x00000000095ec580d7e8427a4baf26a90a00000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000000001440b0be1615a47dba6e5b3b1f10000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000000002d207601f46a99b4112418400000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000066ebaac4c37c622dd8288a7eb1b2000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x00000000ef17240135f7dbd43a1ba10cf200000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000233c33c676a5eb2416094a87b3657000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000541cde48bc0254bed49a9f8700000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000000cae1fad2cdd4d4cb8d73abca0d19a400000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000001edb2aa2f760d15c41ceedba956400000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000004ba8d20d2dabd386c9529659841a2e200000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000000bac08546b867cdaa20000000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000001cfa8e70c03625b9db76c8ebf5bbf24820000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000004851d99f82060df265f3309b26f8200000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x00000b550d19b129d270c44f6f55f027723cbb0000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x00001c877dadc761dc272deb65d4b0000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000048178ece97479f33a77f2ad22a81b64406c000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0000b6ca8268b9d810fedf6695ef2f8a6c00000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0001d0e76631a5b05d007b8cb72a7c7f11ec36e000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0004a1c37bd9f85fd9c6c780000000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x000bd8369f1b702bf491e2ebfcee08250313b65400; 
        xi = (xi * _x) / fixed_1; res += xi * 0x001e5c7c32a9f6c70ab2cb59d9225764d400000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x004dff5820e165e910f95120a708e742496221e600; 
        xi = (xi * _x) / fixed_1; res += xi * 0x00c8c8f66db1fced378ee50e536000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0205db8dffff45bfa2938f128f599dbf16eb11d880; 
        xi = (xi * _x) / fixed_1; res += xi * 0x053a044ebd984351493e1786af38d39a0800000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x0d86dae2a4cc0f47633a544479735869b487b59c40; 
        xi = (xi * _x) / fixed_1; res += xi * 0x231000000000000000000000000000000000000000; 
        xi = (xi * _x) / fixed_1; res += xi * 0x5b0485a76f6646c2039db1507cdd51b08649680822; 
        xi = (xi * _x) / fixed_1; res += xi * 0xec983c46c49545bc17efa6b5b0055e242200000000; 

        return res / 0xde1bc4d19efcac82445da75b00000000 + _x + fixed_1; 
    }

    
    function balancedweightsbystake(uint256 _hi, uint256 _lo, uint256 _tp, uint256 _rq, bool _lowerstake) internal view returns (uint32, uint32) {
        (_tp, _rq) = safefactors(_tp, _rq);
        uint256 f = _hi.mul(fixed_1) / _lo;
        uint256 g = f < opt_log_max_val ? optimallog(f) : generallog(f);
        uint256 x = g.mul(_tp) / _rq;
        uint256 y = _lowerstake ? lowerstake(x) : higherstake(x);
        return normalizedweights(y.mul(_tp), _rq.mul(fixed_1));
    }

    
    function safefactors(uint256 _a, uint256 _b) internal pure returns (uint256, uint256) {
        if (_a <= fixed_2 && _b <= fixed_2)
            return (_a, _b);
        if (_a < fixed_2)
            return (_a * fixed_2 / _b, fixed_2);
        if (_b < fixed_2)
            return (fixed_2, _b * fixed_2 / _a);
        uint256 c = _a > _b ? _a : _b;
        uint256 n = floorlog2(c / fixed_1);
        return (_a >> n, _b >> n);
    }

    
    function normalizedweights(uint256 _a, uint256 _b) internal pure returns (uint32, uint32) {
        if (_a <= _b)
            return accurateweights(_a, _b);
        (uint32 y, uint32 x) = accurateweights(_b, _a);
        return (x, y);
    }

    
    function accurateweights(uint256 _a, uint256 _b) internal pure returns (uint32, uint32) {
        if (_a > max_unf_weight) {
            uint256 c = _a / (max_unf_weight + 1) + 1;
            _a /= c;
            _b /= c;
        }
        uint256 x = rounddiv(_a * max_weight, _a.add(_b));
        uint256 y = max_weight  x;
        return (uint32(x), uint32(y));
    }

    
    function rounddiv(uint256 _n, uint256 _d) internal pure returns (uint256) {
        return _n / _d + _n % _d / (_d  _d / 2);
    }

    
    function calculatepurchasereturn(uint256 _supply,
                                     uint256 _reservebalance,
                                     uint32 _reserveweight,
                                     uint256 _amount)
                                     public view returns (uint256)
    {
        return purchasetargetamount(_supply, _reservebalance, _reserveweight, _amount);
    }

    
    function calculatesalereturn(uint256 _supply,
                                 uint256 _reservebalance,
                                 uint32 _reserveweight,
                                 uint256 _amount)
                                 public view returns (uint256)
    {
        return saletargetamount(_supply, _reservebalance, _reserveweight, _amount);
    }

    
    function calculatecrossreservereturn(uint256 _sourcereservebalance,
                                         uint32 _sourcereserveweight,
                                         uint256 _targetreservebalance,
                                         uint32 _targetreserveweight,
                                         uint256 _amount)
                                         public view returns (uint256)
    {
        return crossreservetargetamount(_sourcereservebalance, _sourcereserveweight, _targetreservebalance, _targetreserveweight, _amount);
    }

    
    function calculatecrossconnectorreturn(uint256 _sourcereservebalance,
                                           uint32 _sourcereserveweight,
                                           uint256 _targetreservebalance,
                                           uint32 _targetreserveweight,
                                           uint256 _amount)
                                           public view returns (uint256)
    {
        return crossreservetargetamount(_sourcereservebalance, _sourcereserveweight, _targetreservebalance, _targetreserveweight, _amount);
    }

    
    function calculatefundcost(uint256 _supply,
                               uint256 _reservebalance,
                               uint32 _reserveratio,
                               uint256 _amount)
                               public view returns (uint256)
    {
        return fundcost(_supply, _reservebalance, _reserveratio, _amount);
    }

    
    function calculateliquidatereturn(uint256 _supply,
                                      uint256 _reservebalance,
                                      uint32 _reserveratio,
                                      uint256 _amount)
                                      public view returns (uint256)
    {
        return liquidatereserveamount(_supply, _reservebalance, _reserveratio, _amount);
    }

    
    function purchaserate(uint256 _supply,
                          uint256 _reservebalance,
                          uint32 _reserveweight,
                          uint256 _amount)
                          public view returns (uint256)
    {
        return purchasetargetamount(_supply, _reservebalance, _reserveweight, _amount);
    }

    
    function salerate(uint256 _supply,
                      uint256 _reservebalance,
                      uint32 _reserveweight,
                      uint256 _amount)
                      public view returns (uint256)
    {
        return saletargetamount(_supply, _reservebalance, _reserveweight, _amount);
    }

    
    function crossreserverate(uint256 _sourcereservebalance,
                              uint32 _sourcereserveweight,
                              uint256 _targetreservebalance,
                              uint32 _targetreserveweight,
                              uint256 _amount)
                              public view returns (uint256)
    {
        return crossreservetargetamount(_sourcereservebalance, _sourcereserveweight, _targetreservebalance, _targetreserveweight, _amount);
    }

    
    function liquidaterate(uint256 _supply,
                           uint256 _reservebalance,
                           uint32 _reserveratio,
                           uint256 _amount)
                           public view returns (uint256)
    {
        return liquidatereserveamount(_supply, _reservebalance, _reserveratio, _amount);
    }
}

pragma solidity 0.4.26;

contract iconverterregistry {
    function getanchorcount() public view returns (uint256);
    function getanchors() public view returns (address[]);
    function getanchor(uint256 _index) public view returns (address);
    function isanchor(address _value) public view returns (bool);
    function getliquiditypoolcount() public view returns (uint256);
    function getliquiditypools() public view returns (address[]);
    function getliquiditypool(uint256 _index) public view returns (address);
    function isliquiditypool(address _value) public view returns (bool);
    function getconvertibletokencount() public view returns (uint256);
    function getconvertibletokens() public view returns (address[]);
    function getconvertibletoken(uint256 _index) public view returns (address);
    function isconvertibletoken(address _value) public view returns (bool);
    function getconvertibletokenanchorcount(address _convertibletoken) public view returns (uint256);
    function getconvertibletokenanchors(address _convertibletoken) public view returns (address[]);
    function getconvertibletokenanchor(address _convertibletoken, uint256 _index) public view returns (address);
    function isconvertibletokenanchor(address _convertibletoken, address _value) public view returns (bool);
}

pragma solidity 0.4.26;
import ;
import ;


contract iconverteranchor is iowned, itokenholder {
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract itypedconverterfactory {
    function convertertype() public pure returns (uint16);
    function createconverter(iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter);
}

pragma solidity 0.4.26;


contract iconverterupgrader {
    function upgrade(bytes32 _version) public;
    function upgrade(uint16 _version) public;
}

pragma solidity 0.4.26;

interface iconverterregistrydata {
    function addsmarttoken(address _smarttoken) external;
    function removesmarttoken(address _smarttoken) external;
    function addliquiditypool(address _liquiditypool) external;
    function removeliquiditypool(address _liquiditypool) external;
    function addconvertibletoken(address _convertibletoken, address _smarttoken) external;
    function removeconvertibletoken(address _convertibletoken, address _smarttoken) external;
    function getsmarttokencount() external view returns (uint256);
    function getsmarttokens() external view returns (address[]);
    function getsmarttoken(uint256 _index) external view returns (address);
    function issmarttoken(address _value) external view returns (bool);
    function getliquiditypoolcount() external view returns (uint256);
    function getliquiditypools() external view returns (address[]);
    function getliquiditypool(uint256 _index) external view returns (address);
    function isliquiditypool(address _value) external view returns (bool);
    function getconvertibletokencount() external view returns (uint256);
    function getconvertibletokens() external view returns (address[]);
    function getconvertibletoken(uint256 _index) external view returns (address);
    function isconvertibletoken(address _value) external view returns (bool);
    function getconvertibletokensmarttokencount(address _convertibletoken) external view returns (uint256);
    function getconvertibletokensmarttokens(address _convertibletoken) external view returns (address[]);
    function getconvertibletokensmarttoken(address _convertibletoken, uint256 _index) external view returns (address);
    function isconvertibletokensmarttoken(address _convertibletoken, address _value) external view returns (bool);
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;


contract iconverter is iowned {
    function convertertype() public pure returns (uint16);
    function anchor() public view returns (iconverteranchor) {this;}
    function isactive() public view returns (bool);

    function targetamountandfee(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount) public view returns (uint256, uint256);
    function convert(ierc20token _sourcetoken,
                     ierc20token _targettoken,
                     uint256 _amount,
                     address _trader,
                     address _beneficiary) public payable returns (uint256);

    function conversionwhitelist() public view returns (iwhitelist) {this;}
    function conversionfee() public view returns (uint32) {this;}
    function maxconversionfee() public view returns (uint32) {this;}
    function reservebalance(ierc20token _reservetoken) public view returns (uint256);
    function() external payable;

    function transferanchorownership(address _newowner) public;
    function acceptanchorownership() public;
    function setconversionfee(uint32 _conversionfee) public;
    function setconversionwhitelist(iwhitelist _whitelist) public;
    function withdrawtokens(ierc20token _token, address _to, uint256 _amount) public;
    function withdraweth(address _to) public;
    function addreserve(ierc20token _token, uint32 _ratio) public;

    
    function token() public view returns (iconverteranchor);
    function transfertokenownership(address _newowner) public;
    function accepttokenownership() public;
    function connectors(address _address) public view returns (uint256, uint32, bool, bool, bool);
    function getconnectorbalance(ierc20token _connectortoken) public view returns (uint256);
    function connectortokens(uint256 _index) public view returns (ierc20token);
    function connectortokencount() public view returns (uint16);
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;


contract iconverterfactory {
    function createanchor(uint16 _type, string _name, string _symbol, uint8 _decimals) public returns (iconverteranchor);
    function createconverter(uint16 _type, iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter);

    function customfactories(uint16 _type) public view returns (itypedconvertercustomfactory) { _type; this; }
}

pragma solidity 0.4.26;


contract ibancorformula {
    function purchasetargetamount(uint256 _supply,
                                  uint256 _reservebalance,
                                  uint32 _reserveweight,
                                  uint256 _amount)
                                  public view returns (uint256);

    function saletargetamount(uint256 _supply,
                              uint256 _reservebalance,
                              uint32 _reserveweight,
                              uint256 _amount)
                              public view returns (uint256);

    function crossreservetargetamount(uint256 _sourcereservebalance,
                                      uint32 _sourcereserveweight,
                                      uint256 _targetreservebalance,
                                      uint32 _targetreserveweight,
                                      uint256 _amount)
                                      public view returns (uint256);

    function fundcost(uint256 _supply,
                      uint256 _reservebalance,
                      uint32 _reserveratio,
                      uint256 _amount)
                      public view returns (uint256);

    function fundsupplyamount(uint256 _supply,
                              uint256 _reservebalance,
                              uint32 _reserveratio,
                              uint256 _amount)
                              public view returns (uint256);

    function liquidatereserveamount(uint256 _supply,
                                    uint256 _reservebalance,
                                    uint32 _reserveratio,
                                    uint256 _amount)
                                    public view returns (uint256);

    function balancedweights(uint256 _primaryreservestakedbalance,
                             uint256 _primaryreservebalance,
                             uint256 _secondaryreservebalance,
                             uint256 _reserveratenumerator,
                             uint256 _reserveratedenominator)
                             public view returns (uint32, uint32);
}

pragma solidity 0.4.26;


contract itypedconvertercustomfactory {
    function convertertype() public pure returns (uint16);
}

pragma solidity 0.4.26;
import ;


contract itypedconverteranchorfactory {
    function convertertype() public pure returns (uint16);
    function createanchor(string _name, string _symbol, uint8 _decimals) public returns (iconverteranchor);
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;


contract liquidtokenconverterfactory is itypedconverterfactory {
    
    function convertertype() public pure returns (uint16) {
        return 0;
    }

    
    function createconverter(iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter) {
        iconverter converter = new liquidtokenconverter(ismarttoken(_anchor), _registry, _maxconversionfee);
        converter.transferownership(msg.sender);
        return converter;
    }
}

pragma solidity 0.4.26;
import ;
import ;


contract liquidtokenconverter is converterbase {
    
    constructor(
        ismarttoken _token,
        icontractregistry _registry,
        uint32 _maxconversionfee
    )
        converterbase(_token, _registry, _maxconversionfee)
        public
    {
    }

    
    function convertertype() public pure returns (uint16) {
        return 0;
    }

    
    function acceptanchorownership() public owneronly {
        super.acceptanchorownership();

        emit activation(anchor, true);
    }

    
    function addreserve(ierc20token _token, uint32 _weight) public {
        
        require(reservetokencount() == 0, );
        super.addreserve(_token, _weight);
    }

    
    function targetamountandfee(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount) public view returns (uint256, uint256) {
        if (_targettoken == ismarttoken(anchor) && reserves[_sourcetoken].isset)
            return purchasetargetamount(_amount);
        if (_sourcetoken == ismarttoken(anchor) && reserves[_targettoken].isset)
            return saletargetamount(_amount);

        
        revert();
    }

    
    function doconvert(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount, address _trader, address _beneficiary)
        internal
        returns (uint256)
    {
        uint256 targetamount;
        ierc20token reservetoken;

        if (_targettoken == ismarttoken(anchor) && reserves[_sourcetoken].isset) {
            reservetoken = _sourcetoken;
            targetamount = buy(_amount, _trader, _beneficiary);
        }
        else if (_sourcetoken == ismarttoken(anchor) && reserves[_targettoken].isset) {
            reservetoken = _targettoken;
            targetamount = sell(_amount, _trader, _beneficiary);
        }
        else {
            
            revert();
        }

        
        uint256 totalsupply = ismarttoken(anchor).totalsupply();
        uint32 reserveweight = reserves[reservetoken].weight;
        emit tokenrateupdate(anchor, reservetoken, reservebalance(reservetoken).mul(weight_resolution), totalsupply.mul(reserveweight));

        return targetamount;
    }

    
    function purchasetargetamount(uint256 _amount)
        internal
        view
        active
        returns (uint256, uint256)
    {
        uint256 totalsupply = ismarttoken(anchor).totalsupply();

        
        if (totalsupply == 0)
            return (_amount, 0);

        ierc20token reservetoken = reservetokens[0];
        uint256 amount = ibancorformula(addressof(bancor_formula)).purchasetargetamount(
            totalsupply,
            reservebalance(reservetoken),
            reserves[reservetoken].weight,
            _amount
        );

        
        uint256 fee = calculatefee(amount);
        return (amount  fee, fee);
    }

    
    function saletargetamount(uint256 _amount)
        internal
        view
        active
        returns (uint256, uint256)
    {
        uint256 totalsupply = ismarttoken(anchor).totalsupply();

        ierc20token reservetoken = reservetokens[0];

        
        if (totalsupply == _amount)
            return (reservebalance(reservetoken), 0);

        uint256 amount = ibancorformula(addressof(bancor_formula)).saletargetamount(
            totalsupply,
            reservebalance(reservetoken),
            reserves[reservetoken].weight,
            _amount
        );

        
        uint256 fee = calculatefee(amount);
        return (amount  fee, fee);
    }

    
    function buy(uint256 _amount, address _trader, address _beneficiary) internal returns (uint256) {
        
        (uint256 amount, uint256 fee) = purchasetargetamount(_amount);

        
        require(amount != 0, );

        ierc20token reservetoken = reservetokens[0];

        
        if (reservetoken == eth_reserve_address)
            require(msg.value == _amount, );
        else
            require(msg.value == 0 && reservetoken.balanceof(this).sub(reservebalance(reservetoken)) >= _amount, );

        
        syncreservebalance(reservetoken);

        
        ismarttoken(anchor).issue(_beneficiary, amount);

        
        dispatchconversionevent(reservetoken, ismarttoken(anchor), _trader, _amount, amount, fee);

        return amount;
    }

    
    function sell(uint256 _amount, address _trader, address _beneficiary) internal returns (uint256) {
        
        require(_amount <= ismarttoken(anchor).balanceof(this), );

        
        (uint256 amount, uint256 fee) = saletargetamount(_amount);

        
        require(amount != 0, );

        ierc20token reservetoken = reservetokens[0];

        
        uint256 tokensupply = ismarttoken(anchor).totalsupply();
        uint256 rsvbalance = reservebalance(reservetoken);
        assert(amount < rsvbalance || (amount == rsvbalance && _amount == tokensupply));

        
        ismarttoken(anchor).destroy(this, _amount);

        
        reserves[reservetoken].balance = reserves[reservetoken].balance.sub(amount);

        
        if (reservetoken == eth_reserve_address)
            _beneficiary.transfer(amount);
        else
            safetransfer(reservetoken, _beneficiary, amount);

        
        dispatchconversionevent(ismarttoken(anchor), reservetoken, _trader, _amount, amount, fee);

        return amount;
    }
}

pragma solidity 0.4.26;
import ;
import ;


contract liquiditypoolv2converteranchorfactory is itypedconverteranchorfactory {
    
    function convertertype() public pure returns (uint16) {
        return 2;
    }

    
    function createanchor(string _name, string _symbol, uint8 _decimals) public returns (iconverteranchor) {
        ipooltokenscontainer container = new pooltokenscontainer(_name, _symbol, _decimals);
        container.transferownership(msg.sender);
        return container;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;


contract pooltokenscontainer is ipooltokenscontainer, owned, tokenholder {
    uint8 internal constant max_pool_tokens = 5;    

    string public name;                 
    string public symbol;               
    uint8 public decimals;              
    ismarttoken[] private _pooltokens;  

    
    constructor(string _name, string _symbol, uint8 _decimals) public {
         
        require(bytes(_name).length > 0, );
        require(bytes(_symbol).length > 0, );

        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }

    
    function pooltokens() public view returns (ismarttoken[] memory) {
        return _pooltokens;
    }

    
    function createtoken() public owneronly returns (ismarttoken) {
        
        require(_pooltokens.length < max_pool_tokens, );

        string memory poolname = concatstrdigit(name, uint8(_pooltokens.length + 1));
        string memory poolsymbol = concatstrdigit(symbol, uint8(_pooltokens.length + 1));

        smarttoken token = new smarttoken(poolname, poolsymbol, decimals);
        _pooltokens.push(token);
        return token;
    }

    
    function mint(ismarttoken _token, address _to, uint256 _amount) public owneronly {
        _token.issue(_to, _amount);
    }

    
    function burn(ismarttoken _token, address _from, uint256 _amount) public owneronly {
        _token.destroy(_from, _amount);
    }

    
    function concatstrdigit(string _str, uint8 _digit) private pure returns (string) {
        return string(abi.encodepacked(_str, uint8(bytes1()) + _digit));
    }
}

pragma solidity 0.4.26;
import ;
import ;


contract liquiditypoolv2convertercustomfactory is itypedconvertercustomfactory {
    
    function convertertype() public pure returns (uint16) {
        return 2;
    }

    
    function createpriceoracle(
        ierc20token _primaryreservetoken,
        ierc20token _secondaryreservetoken,
        ichainlinkpriceoracle _primaryreserveoracle,
        ichainlinkpriceoracle _secondaryreserveoracle)
        public
        returns (ipriceoracle)
    {
        return new priceoracle(_primaryreservetoken, _secondaryreservetoken, _primaryreserveoracle, _secondaryreserveoracle);
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract liquiditypoolv2converterfactory is itypedconverterfactory {
    
    function convertertype() public pure returns (uint16) {
        return 2;
    }

    
    function createconverter(iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter) {
        converterbase converter = new liquiditypoolv2converter(ipooltokenscontainer(_anchor), _registry, _maxconversionfee);
        converter.transferownership(msg.sender);
        return converter;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;


contract liquiditypoolv2converter is liquiditypoolconverter {
    uint8 internal constant amplification_factor = 20;  

    struct fraction {
        uint256 n;  
        uint256 d;  
    }

    ipriceoracle public priceoracle;                                
    ierc20token public primaryreservetoken;                         
    ierc20token public secondaryreservetoken;                       
    mapping (address => uint256) private stakedbalances;            
    mapping (address => ismarttoken) private reservestopooltokens;  
    mapping (address => ierc20token) private pooltokenstoreserves;  

    
    uint256 private constant rate_propagation_period = 10 minutes;

    fraction public referencerate;              
    uint256 public referencerateupdatetime;     

    fraction public lastconversionrate;         

    
    mapping (address => uint256) public maxstakedbalances;
    bool public maxstakedbalanceenabled = true;

    
    constructor(ipooltokenscontainer _pooltokenscontainer, icontractregistry _registry, uint32 _maxconversionfee)
        public liquiditypoolconverter(_pooltokenscontainer, _registry, _maxconversionfee)
    {
    }

    
    modifier validpooltoken(ismarttoken _address) {
        _validpooltoken(_address);
        _;
    }

    
    function _validpooltoken(ismarttoken _address) internal view {
        require(pooltokenstoreserves[_address] != address(0), );
    }

    
    function convertertype() public pure returns (uint16) {
        return 2;
    }

    
    function isactive() public view returns (bool) {
        return super.isactive() && priceoracle != address(0);
    }

    
    function activate(ierc20token _primaryreservetoken, ichainlinkpriceoracle _primaryreserveoracle, ichainlinkpriceoracle _secondaryreserveoracle)
        public
        inactive
        owneronly
        validreserve(_primaryreservetoken)
        notthis(_primaryreserveoracle)
        notthis(_secondaryreserveoracle)
        validaddress(_primaryreserveoracle)
        validaddress(_secondaryreserveoracle)
    {
        
        iwhitelist oraclewhitelist = iwhitelist(addressof(chainlink_oracle_whitelist));
        require(oraclewhitelist.iswhitelisted(_primaryreserveoracle), );
        require(oraclewhitelist.iswhitelisted(_secondaryreserveoracle), );

        
        createpooltokens();

        
        primaryreservetoken = _primaryreservetoken;
        if (_primaryreservetoken == reservetokens[0])
            secondaryreservetoken = reservetokens[1];
        else
            secondaryreservetoken = reservetokens[0];

        
        liquiditypoolv2convertercustomfactory customfactory =
            liquiditypoolv2convertercustomfactory(iconverterfactory(addressof(converter_factory)).customfactories(convertertype()));
        priceoracle = customfactory.createpriceoracle(_primaryreservetoken, secondaryreservetoken, _primaryreserveoracle, _secondaryreserveoracle);

        (referencerate.n, referencerate.d)  = priceoracle.latestrate(primaryreservetoken, secondaryreservetoken);
        lastconversionrate = referencerate;

        referencerateupdatetime = time();

        
        uint256 primaryreservestakedbalance = reservestakedbalance(primaryreservetoken);
        uint256 primaryreservebalance = reservebalance(primaryreservetoken);
        uint256 secondaryreservebalance = reservebalance(secondaryreservetoken);

        if (primaryreservestakedbalance == primaryreservebalance) {
            if (primaryreservestakedbalance > 0 || secondaryreservebalance > 0) {
                rebalance();
            }
        }
        else if (primaryreservestakedbalance > 0 && primaryreservebalance > 0 && secondaryreservebalance > 0) {
            rebalance();
        }

        emit activation(anchor, true);
    }

    
    function reservestakedbalance(ierc20token _reservetoken)
        public
        view
        validreserve(_reservetoken)
        returns (uint256)
    {
        return stakedbalances[_reservetoken];
    }

    
    function setreservestakedbalance(ierc20token _reservetoken, uint256 _balance)
        public
        owneronly
        only(converter_upgrader)
        validreserve(_reservetoken)
    {
        stakedbalances[_reservetoken] = _balance;
    }

    
    function setmaxstakedbalances(uint256 _reserve1maxstakedbalance, uint256 _reserve2maxstakedbalance) public owneronly {
        maxstakedbalances[reservetokens[0]] = _reserve1maxstakedbalance;
        maxstakedbalances[reservetokens[1]] = _reserve2maxstakedbalance;
    }

    
    function disablemaxstakedbalances() public owneronly {
        maxstakedbalanceenabled = false;
    }

    
    function pooltoken(ierc20token _reservetoken) public view returns (ismarttoken) {
        return reservestopooltokens[_reservetoken];
    }

    
    function liquidationlimit(ismarttoken _pooltoken) public view returns (uint256) {
        
        uint256 pooltokensupply = _pooltoken.totalsupply();

        
        ierc20token reservetoken = pooltokenstoreserves[_pooltoken];
        uint256 balance = reservebalance(reservetoken);
        uint256 stakedbalance = stakedbalances[reservetoken];

        
        return balance.mul(pooltokensupply).div(stakedbalance);
    }

    
    function addreserve(ierc20token _token, uint32 _weight) public {
        
        require(reservetokencount() < 2, );
        super.addreserve(_token, _weight);
    }

    
    function effectivetokensrate() public view returns (uint256, uint256) {
        fraction memory rate = _effectivetokensrate();
        return (rate.n, rate.d);
    }

    
    function effectivereserveweights() public view returns (uint256, uint256) {
        fraction memory rate = _effectivetokensrate();
        (uint32 primaryreserveweight, uint32 secondaryreserveweight) = effectivereserveweights(rate);

        if (primaryreservetoken == reservetokens[0]) {
            return (primaryreserveweight, secondaryreserveweight);
        }

        return (secondaryreserveweight, primaryreserveweight);
    }

    
    function targetamountandfee(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount)
        public
        view
        active
        returns (uint256, uint256)
    {
        
        
        _validreserve(_sourcetoken);
        _validreserve(_targettoken);
        require(_sourcetoken != _targettoken, );

        
        uint32 sourcetokenweight;
        uint32 targettokenweight;

        
        
        if (referencerateupdatetime == time()) {
            sourcetokenweight = reserves[_sourcetoken].weight;
            targettokenweight = reserves[_targettoken].weight;
        }
        else {
            
            fraction memory rate = _effectivetokensrate();
            (uint32 primaryreserveweight, uint32 secondaryreserveweight) = effectivereserveweights(rate);

            if (_sourcetoken == primaryreservetoken) {
                sourcetokenweight = primaryreserveweight;
                targettokenweight = secondaryreserveweight;
            }
            else {
                sourcetokenweight = secondaryreserveweight;
                targettokenweight = primaryreserveweight;
            }
        }

        
        (uint256 targetamount, , uint256 fee) = targetamountandfees(_sourcetoken, _targettoken, sourcetokenweight, targettokenweight, rate, _amount);
        return (targetamount, fee);
    }

    
    function doconvert(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount, address _trader, address _beneficiary)
        internal
        active
        validreserve(_sourcetoken)
        validreserve(_targettoken)
        returns (uint256)
    {
        
        (uint256 amount, uint256 fee) = doconvert(_sourcetoken, _targettoken, _amount);

        
        if (_targettoken == eth_reserve_address) {
            _beneficiary.transfer(amount);
        }
        else {
            safetransfer(_targettoken, _beneficiary, amount);
        }

        
        dispatchconversionevent(_sourcetoken, _targettoken, _trader, _amount, amount, fee);

        
        dispatchrateevents(_sourcetoken, _targettoken, reserves[_sourcetoken].weight, reserves[_targettoken].weight);

        
        return amount;
    }

    
    function doconvert(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount) private returns (uint256, uint256) {
        
        (bool rateupdated, fraction memory rate) = handleratechange();

        
        (uint256 amount, uint256 normalfee, uint256 adjustedfee) = targetamountandfees(_sourcetoken, _targettoken, 0, 0, rate, _amount);

        
        require(amount != 0, );

        
        uint256 targetreservebalance = reservebalance(_targettoken);
        require(amount < targetreservebalance, );

        
        if (_sourcetoken == eth_reserve_address)
            require(msg.value == _amount, );
        else
            require(msg.value == 0 && _sourcetoken.balanceof(this).sub(reservebalance(_sourcetoken)) >= _amount, );

        
        syncreservebalance(_sourcetoken);
        reserves[_targettoken].balance = targetreservebalance.sub(amount);

        
        stakedbalances[_targettoken] = stakedbalances[_targettoken].add(normalfee);

        
        if (rateupdated) {
            lastconversionrate = tokensrate(primaryreservetoken, secondaryreservetoken, 0, 0);
        }

        return (amount, adjustedfee);
    }

    
    function addliquidity(ierc20token _reservetoken, uint256 _amount, uint256 _minreturn)
        public
        payable
        protected
        active
        validreserve(_reservetoken)
        greaterthanzero(_amount)
        greaterthanzero(_minreturn)
        returns (uint256)
    {
        
        require(_reservetoken == eth_reserve_address ? msg.value == _amount : msg.value == 0, );

        
        syncreservebalances();

        
        if (_reservetoken == eth_reserve_address)
            reserves[eth_reserve_address].balance = reserves[eth_reserve_address].balance.sub(msg.value);

        
        uint256 initialstakedbalance = stakedbalances[_reservetoken];

        
        if (maxstakedbalanceenabled) {
            require(maxstakedbalances[_reservetoken] == 0 || initialstakedbalance.add(_amount) <= maxstakedbalances[_reservetoken], );
        }

        
        ismarttoken reservepooltoken = reservestopooltokens[_reservetoken];
        uint256 pooltokensupply = reservepooltoken.totalsupply();

        
        if (_reservetoken != eth_reserve_address)
            safetransferfrom(_reservetoken, msg.sender, this, _amount);

        
        reserves[_reservetoken].balance = reserves[_reservetoken].balance.add(_amount);
        stakedbalances[_reservetoken] = initialstakedbalance.add(_amount);

        
        
        
        uint256 pooltokenamount = 0;
        if (initialstakedbalance == 0 || pooltokensupply == 0)
            pooltokenamount = _amount;
        else
            pooltokenamount = _amount.mul(pooltokensupply).div(initialstakedbalance);
        require(pooltokenamount >= _minreturn, );

        
        ipooltokenscontainer(anchor).mint(reservepooltoken, msg.sender, pooltokenamount);

        
        rebalance();

        
        emit liquidityadded(msg.sender, _reservetoken, _amount, initialstakedbalance.add(_amount), pooltokensupply.add(pooltokenamount));

        
        dispatchpooltokenrateupdateevent(reservepooltoken, pooltokensupply.add(pooltokenamount), _reservetoken);

        
        dispatchtokenrateupdateevent(reservetokens[0], reservetokens[1], 0, 0);

        
        return pooltokenamount;
    }

    
    function removeliquidity(ismarttoken _pooltoken, uint256 _amount, uint256 _minreturn)
        public
        protected
        active
        validpooltoken(_pooltoken)
        greaterthanzero(_amount)
        greaterthanzero(_minreturn)
        returns (uint256)
    {
        
        syncreservebalances();

        
        uint256 initialpoolsupply = _pooltoken.totalsupply();

        
        uint256 reserveamount = removeliquidityreturn(_pooltoken, _amount);
        require(reserveamount >= _minreturn, );

        
        ierc20token reservetoken = pooltokenstoreserves[_pooltoken];

        
        ipooltokenscontainer(anchor).burn(_pooltoken, msg.sender, _amount);

        
        reserves[reservetoken].balance = reserves[reservetoken].balance.sub(reserveamount);
        uint256 newstakedbalance = stakedbalances[reservetoken].sub(reserveamount);
        stakedbalances[reservetoken] = newstakedbalance;

        
        if (reservetoken == eth_reserve_address)
            msg.sender.transfer(reserveamount);
        else
            safetransfer(reservetoken, msg.sender, reserveamount);

        
        rebalance();

        uint256 newpooltokensupply = initialpoolsupply.sub(_amount);

        
        emit liquidityremoved(msg.sender, reservetoken, reserveamount, newstakedbalance, newpooltokensupply);

        
        dispatchpooltokenrateupdateevent(_pooltoken, newpooltokensupply, reservetoken);

        
        dispatchtokenrateupdateevent(reservetokens[0], reservetokens[1], 0, 0);

        
        return reserveamount;
    }

    
    function removeliquidityreturn(ismarttoken _pooltoken, uint256 _amount)
        public
        view
        returns (uint256)
    {
        uint256 totalsupply = _pooltoken.totalsupply();
        uint256 stakedbalance = stakedbalances[pooltokenstoreserves[_pooltoken]];

        if (_amount < totalsupply) {
            uint256 x = stakedbalances[primaryreservetoken].mul(amplification_factor);
            uint256 y = amplifiedbalance(primaryreservetoken);
            (uint256 min, uint256 max) = x < y ? (x, y) : (y, x);
            return _amount.mul(stakedbalance.mul(min)).div(totalsupply.mul(max));
        }
        return stakedbalance;
    }

    
    function targetamountandfees(
        ierc20token _sourcetoken,
        ierc20token _targettoken,
        uint32 _sourceweight,
        uint32 _targetweight,
        fraction memory _rate,
        uint256 _amount)
        private
        view
        returns (uint256 targetamount, uint256 normalfee, uint256 adjustedfee)
    {
        if (_sourceweight == 0)
            _sourceweight = reserves[_sourcetoken].weight;
        if (_targetweight == 0)
            _targetweight = reserves[_targettoken].weight;

        
        uint256 sourcebalance = amplifiedbalance(_sourcetoken);
        uint256 targetbalance = amplifiedbalance(_targettoken);

        
        targetamount = ibancorformula(addressof(bancor_formula)).crossreservetargetamount(
            sourcebalance,
            _sourceweight,
            targetbalance,
            _targetweight,
            _amount
        );

        
        normalfee = super.calculatefee(targetamount);
        adjustedfee = calculatefee(_targettoken, _sourceweight, _targetweight, _rate, targetamount);
        targetamount = adjustedfee;
    }

    
    function calculatefee(
        ierc20token _targettoken,
        uint32 _sourceweight,
        uint32 _targetweight,
        fraction memory _rate,
        uint256 _targetamount)
        internal view returns (uint256)
    {
        
        if (_targettoken == primaryreservetoken) {
            return super.calculatefee(_targetamount);
        }

        
        uint256 fee = calculateadjustedfee(
            stakedbalances[primaryreservetoken],
            stakedbalances[secondaryreservetoken],
            _sourceweight,
            _targetweight,
            _rate.n,
            _rate.d,
            conversionfee);

        
        return _targetamount.mul(fee).div(conversion_fee_resolution);
    }

    
    function calculateadjustedfee(
        uint256 _primaryreservestaked,
        uint256 _secondaryreservestaked,
        uint256 _primaryreserveweight,
        uint256 _secondaryreserveweight,
        uint256 _primaryreserverate,
        uint256 _secondaryreserverate,
        uint256 _conversionfee)
        internal
        pure
        returns (uint256)
    {
        uint256 x = _primaryreservestaked.mul(_primaryreserverate).mul(_secondaryreserveweight);
        uint256 y = _secondaryreservestaked.mul(_secondaryreserverate).mul(_primaryreserveweight);

        if (x >= y)
            return _conversionfee;

        if (x.mul(amplification_factor * 2) <= y.mul(amplification_factor * 2  1))
            return _conversionfee * 2;

        return _conversionfee.mul(y).div(x.mul(amplification_factor).sub(y.mul(amplification_factor  1)));
    }

    
    function createpooltokens() internal {
        ipooltokenscontainer container = ipooltokenscontainer(anchor);
        if (container.pooltokens().length != 0) {
            return;
        }

        uint256 reservecount = reservetokens.length;
        for (uint256 i = 0; i < reservecount; i++) {
            ismarttoken reservepooltoken = container.createtoken();

            
            reservestopooltokens[reservetokens[i]] = reservepooltoken;
            pooltokenstoreserves[reservepooltoken] = reservetokens[i];
        }
    }

    
    function _effectivetokensrate() private view returns (fraction memory) {
        
        (uint256 externalraten, uint256 externalrated, uint256 updatetime) = priceoracle.latestrateandupdatetime(primaryreservetoken, secondaryreservetoken);

        
        if (updatetime >= referencerateupdatetime) {
            return fraction({ n: externalraten, d: externalrated });
        }

        
        uint256 timeelapsed = time()  referencerateupdatetime;

        
        if (timeelapsed == 0) {
            return referencerate;
        }

        
        

        
        if (timeelapsed >= rate_propagation_period) {
            return lastconversionrate;
        }

        
        fraction memory ref = referencerate;
        fraction memory last = lastconversionrate;

        uint256 x = ref.d.mul(last.n);
        uint256 y = ref.n.mul(last.d);

        
        uint256 newraten = y.mul(rate_propagation_period  timeelapsed).add(x.mul(timeelapsed));
        uint256 newrated = ref.d.mul(last.d).mul(rate_propagation_period);

        return reducerate(newraten, newrated);
    }

    
    function handleratechange() private returns (bool, fraction memory) {
        uint256 currenttime = time();

        
        if (referencerateupdatetime == currenttime) {
            return (false, referencerate);
        }

        
        fraction memory newrate = _effectivetokensrate();

        
        fraction memory ref = referencerate;
        if (newrate.n == ref.n && newrate.d == ref.d) {
            return (false, newrate);
        }

        referencerate = newrate;
        referencerateupdatetime = currenttime;

        rebalance();

        return (true, newrate);
    }

    
    function rebalance() private {
        
        (uint32 primaryreserveweight, uint32 secondaryreserveweight) = effectivereserveweights(referencerate);

        
        reserves[primaryreservetoken].weight = primaryreserveweight;
        reserves[secondaryreservetoken].weight = secondaryreserveweight;
    }

    
    function effectivereserveweights(fraction memory _rate) private view returns (uint32, uint32) {
        
        uint256 primarystakedbalance = stakedbalances[primaryreservetoken];

        
        uint256 primarybalance = amplifiedbalance(primaryreservetoken);
        uint256 secondarybalance = amplifiedbalance(secondaryreservetoken);

        
        
        
        return ibancorformula(addressof(bancor_formula)).balancedweights(
            primarystakedbalance.mul(amplification_factor),
            primarybalance,
            secondarybalance,
            _rate.d,
            _rate.n);
    }

    
    function tokensrate(ierc20token _token1, ierc20token _token2, uint32 _token1weight, uint32 _token2weight) private view returns (fraction memory) {
        
        uint256 token1balance = amplifiedbalance(_token1);
        uint256 token2balance = amplifiedbalance(_token2);

        
        if (_token1weight == 0) {
            _token1weight = reserves[_token1].weight;
        }

        if (_token2weight == 0) {
            _token2weight = reserves[_token2].weight;
        }

        return fraction({ n: token2balance.mul(_token1weight), d: token1balance.mul(_token2weight) });
    }

    
    function amplifiedbalance(ierc20token _reservetoken) private view returns (uint256) {
        return stakedbalances[_reservetoken].mul(amplification_factor  1).add(reservebalance(_reservetoken));
    }

    
    function dispatchrateevents(ierc20token _sourcetoken, ierc20token _targettoken, uint32 _sourceweight, uint32 _targetweight) private {
        dispatchtokenrateupdateevent(_sourcetoken, _targettoken, _sourceweight, _targetweight);

        
        
        
        ismarttoken targetpooltoken = pooltoken(_targettoken);
        uint256 targetpooltokensupply = targetpooltoken.totalsupply();
        dispatchpooltokenrateupdateevent(targetpooltoken, targetpooltokensupply, _targettoken);
    }

    
    function dispatchtokenrateupdateevent(ierc20token _token1, ierc20token _token2, uint32 _token1weight, uint32 _token2weight) private {
        
        fraction memory rate = tokensrate(_token1, _token2, _token1weight, _token2weight);

        emit tokenrateupdate(_token1, _token2, rate.n, rate.d);
    }

    
    function dispatchpooltokenrateupdateevent(ismarttoken _pooltoken, uint256 _pooltokensupply, ierc20token _reservetoken) private {
        emit tokenrateupdate(_pooltoken, _reservetoken, stakedbalances[_reservetoken], _pooltokensupply);
    }

    
    function time() internal view returns (uint256) {
        return now;
    }

    uint256 private constant max_rate_factor_lower_bound = 1000000000000000000000000000000;
    uint256 private constant max_rate_factor_upper_bound = 115792089237316195423570985008687907853269984665; 

    
    function reducerate(uint256 _n, uint256 _d) internal pure returns (fraction memory) {
        if (_n >= _d) {
            return reducefactors(_n, _d);
        }

        fraction memory rate = reducefactors(_d, _n);
        return fraction({ n: rate.d, d: rate.n });
    }

    
    function reducefactors(uint256 _max, uint256 _min) internal pure returns (fraction memory) {
        if (_min > max_rate_factor_upper_bound) {
            uint256 c = _min / (max_rate_factor_upper_bound + 1) + 1;
            return fraction({ n: _max / c, d: _min / c });
        }

        if (_max > max_rate_factor_lower_bound) {
            return fraction({
                n: max_rate_factor_lower_bound,
                d: _min * max_rate_factor_lower_bound / _max
            });
        }

        return fraction({ n: _max, d: _min });
    }
}

pragma solidity 0.4.26;
import ;
import ;


contract ipooltokenscontainer is iconverteranchor {
    function pooltokens() public view returns (ismarttoken[]);
    function createtoken() public returns (ismarttoken);
    function mint(ismarttoken _token, address _to, uint256 _amount) public;
    function burn(ismarttoken _token, address _from, uint256 _amount) public;
}

pragma solidity 0.4.26;
import ;
import ;


contract iliquiditypoolv2converter {
    function reservestakedbalance(ierc20token _reservetoken) public view returns (uint256);
    function setreservestakedbalance(ierc20token _reservetoken, uint256 _balance) public;

    function primaryreservetoken() public view returns (ierc20token);

    function priceoracle() public view returns (ipriceoracle);

    function activate(ierc20token _primaryreservetoken, ichainlinkpriceoracle _primaryreserveoracle, ichainlinkpriceoracle _secondaryreserveoracle) public;
}

pragma solidity 0.4.26;
import ;
import ;


contract liquiditypoolv1converter is liquiditypoolconverter {
    iethertoken internal ethertoken = iethertoken(0xc0829421c1d260bd3cb3e0f06cfe2d52db2ce315);

    
    event pricedataupdate(
        address indexed _connectortoken,
        uint256 _tokensupply,
        uint256 _connectorbalance,
        uint32 _connectorweight
    );

    
    constructor(
        ismarttoken _token,
        icontractregistry _registry,
        uint32 _maxconversionfee
    )
        liquiditypoolconverter(_token, _registry, _maxconversionfee)
        public
    {
    }

    
    function convertertype() public pure returns (uint16) {
        return 1;
    }

    
    function acceptanchorownership() public owneronly {
        super.acceptanchorownership();

        emit activation(anchor, true);
    }

    
    function targetamountandfee(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount)
        public
        view
        active
        validreserve(_sourcetoken)
        validreserve(_targettoken)
        returns (uint256, uint256)
    {
        
        require(_sourcetoken != _targettoken, );

        uint256 amount = ibancorformula(addressof(bancor_formula)).crossreservetargetamount(
            reservebalance(_sourcetoken),
            reserves[_sourcetoken].weight,
            reservebalance(_targettoken),
            reserves[_targettoken].weight,
            _amount
        );

        
        uint256 fee = calculatefee(amount);
        return (amount  fee, fee);
    }

    
    function doconvert(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount, address _trader, address _beneficiary)
        internal
        returns (uint256)
    {
        
        (uint256 amount, uint256 fee) = targetamountandfee(_sourcetoken, _targettoken, _amount);

        
        require(amount != 0, );

        
        uint256 targetreservebalance = reservebalance(_targettoken);
        assert(amount < targetreservebalance);

        
        if (_sourcetoken == eth_reserve_address)
            require(msg.value == _amount, );
        else
            require(msg.value == 0 && _sourcetoken.balanceof(this).sub(reservebalance(_sourcetoken)) >= _amount, );

        
        syncreservebalance(_sourcetoken);
        reserves[_targettoken].balance = reserves[_targettoken].balance.sub(amount);

        
        if (_targettoken == eth_reserve_address)
            _beneficiary.transfer(amount);
        else
            safetransfer(_targettoken, _beneficiary, amount);

        
        dispatchconversionevent(_sourcetoken, _targettoken, _trader, _amount, amount, fee);

        
        dispatchrateevents(_sourcetoken, _targettoken);

        return amount;
    }

    
    function addliquidity(ierc20token[] memory _reservetokens, uint256[] memory _reserveamounts, uint256 _minreturn)
        public
        payable
        protected
        active
    {
        
        verifyliquidityinput(_reservetokens, _reserveamounts, _minreturn);

        
        for (uint256 i = 0; i < _reservetokens.length; i++)
            if (_reservetokens[i] == eth_reserve_address)
                require(_reserveamounts[i] == msg.value, );

        
        if (msg.value > 0)
            require(reserves[eth_reserve_address].isset, );

        
        uint256 totalsupply = ismarttoken(anchor).totalsupply();

        
        uint256 amount = addliquiditytopool(_reservetokens, _reserveamounts, totalsupply);

        
        require(amount >= _minreturn, );

        
        ismarttoken(anchor).issue(msg.sender, amount);
    }

    
    function removeliquidity(uint256 _amount, ierc20token[] memory _reservetokens, uint256[] memory _reserveminreturnamounts)
        public
        protected
        active
    {
        
        verifyliquidityinput(_reservetokens, _reserveminreturnamounts, _amount);

        
        uint256 totalsupply = ismarttoken(anchor).totalsupply();

        
        ismarttoken(anchor).destroy(msg.sender, _amount);

        
        removeliquidityfrompool(_reservetokens, _reserveminreturnamounts, totalsupply, _amount);
    }

    
    function fund(uint256 _amount) public payable protected {
        syncreservebalances();
        reserves[eth_reserve_address].balance = reserves[eth_reserve_address].balance.sub(msg.value);

        uint256 supply = ismarttoken(anchor).totalsupply();
        ibancorformula formula = ibancorformula(addressof(bancor_formula));

        
        
        uint256 reservecount = reservetokens.length;
        for (uint256 i = 0; i < reservecount; i++) {
            ierc20token reservetoken = reservetokens[i];
            uint256 rsvbalance = reserves[reservetoken].balance;
            uint256 reserveamount = formula.fundcost(supply, rsvbalance, reserveratio, _amount);

            
            if (reservetoken == eth_reserve_address) {
                if (msg.value > reserveamount) {
                    msg.sender.transfer(msg.value  reserveamount);
                }
                else if (msg.value < reserveamount) {
                    require(msg.value == 0, );
                    safetransferfrom(ethertoken, msg.sender, this, reserveamount);
                    ethertoken.withdraw(reserveamount);
                }
            }
            else {
                safetransferfrom(reservetoken, msg.sender, this, reserveamount);
            }

            
            uint256 newreservebalance = rsvbalance.add(reserveamount);
            reserves[reservetoken].balance = newreservebalance;

            uint256 newpooltokensupply = supply.add(_amount);

            
            emit liquidityadded(msg.sender, reservetoken, reserveamount, newreservebalance, newpooltokensupply);

            
            uint32 reserveweight = reserves[reservetoken].weight;
            dispatchpooltokenrateevent(newpooltokensupply, reservetoken, newreservebalance, reserveweight);
        }

        
        ismarttoken(anchor).issue(msg.sender, _amount);
    }

    
    function liquidate(uint256 _amount) public protected {
        require(_amount > 0, );

        uint256 totalsupply = ismarttoken(anchor).totalsupply();
        ismarttoken(anchor).destroy(msg.sender, _amount);

        uint256[] memory reserveminreturnamounts = new uint256[](reservetokens.length);
        for (uint256 i = 0; i < reserveminreturnamounts.length; i++)
            reserveminreturnamounts[i] = 1;

        removeliquidityfrompool(reservetokens, reserveminreturnamounts, totalsupply, _amount);
    }

    
    function verifyliquidityinput(ierc20token[] memory _reservetokens, uint256[] memory _reserveamounts, uint256 _amount) private view {
        uint256 i;
        uint256 j;

        uint256 length = reservetokens.length;
        require(length == _reservetokens.length, );
        require(length == _reserveamounts.length, );

        for (i = 0; i < length; i++) {
            
            require(reserves[_reservetokens[i]].isset, );
            for (j = 0; j < length; j++) {
                if (reservetokens[i] == _reservetokens[j])
                    break;
            }
            
            require(j < length, );
            
            require(_reserveamounts[i] > 0, );
        }

        
        require(_amount > 0, );
    }

    
    function addliquiditytopool(ierc20token[] memory _reservetokens, uint256[] memory _reserveamounts, uint256 _totalsupply)
        private
        returns (uint256)
    {
        if (_totalsupply == 0)
            return addliquiditytoemptypool(_reservetokens, _reserveamounts);
        return addliquiditytononemptypool(_reservetokens, _reserveamounts, _totalsupply);
    }

    
    function addliquiditytoemptypool(ierc20token[] memory _reservetokens, uint256[] memory _reserveamounts)
        private
        returns (uint256)
    {
        
        uint256 amount = geometricmean(_reserveamounts);

        
        for (uint256 i = 0; i < _reservetokens.length; i++) {
            if (_reservetokens[i] != eth_reserve_address) 
                safetransferfrom(_reservetokens[i], msg.sender, this, _reserveamounts[i]);

            reserves[_reservetokens[i]].balance = _reserveamounts[i];

            emit liquidityadded(msg.sender, _reservetokens[i], _reserveamounts[i], _reserveamounts[i], amount);

            
            uint32 reserveweight = reserves[_reservetokens[i]].weight;
            dispatchpooltokenrateevent(amount, _reservetokens[i], _reserveamounts[i], reserveweight);
        }

        return amount;
    }

    
    function addliquiditytononemptypool(ierc20token[] memory _reservetokens, uint256[] memory _reserveamounts, uint256 _totalsupply)
        private
        returns (uint256)
    {
        syncreservebalances();
        reserves[eth_reserve_address].balance = reserves[eth_reserve_address].balance.sub(msg.value);

        ibancorformula formula = ibancorformula(addressof(bancor_formula));
        uint256 amount = getminshare(formula, _totalsupply, _reservetokens, _reserveamounts);
        uint256 newpooltokensupply = _totalsupply.add(amount);

        for (uint256 i = 0; i < _reservetokens.length; i++) {
            ierc20token reservetoken = _reservetokens[i];
            uint256 rsvbalance = reserves[reservetoken].balance;
            uint256 reserveamount = formula.fundcost(_totalsupply, rsvbalance, reserveratio, amount);
            require(reserveamount > 0, );
            assert(reserveamount <= _reserveamounts[i]);

            
            if (reservetoken != eth_reserve_address) 
                safetransferfrom(reservetoken, msg.sender, this, reserveamount);
            else if (_reserveamounts[i] > reserveamount) 
                msg.sender.transfer(_reserveamounts[i]  reserveamount);

            uint256 newreservebalance = rsvbalance.add(reserveamount);
            reserves[reservetoken].balance = newreservebalance;

            emit liquidityadded(msg.sender, reservetoken, reserveamount, newreservebalance, newpooltokensupply);

            
            uint32 reserveweight = reserves[_reservetokens[i]].weight;
            dispatchpooltokenrateevent(newpooltokensupply, _reservetokens[i], newreservebalance, reserveweight);
        }

        return amount;
    }

    
    function removeliquidityfrompool(ierc20token[] memory _reservetokens, uint256[] memory _reserveminreturnamounts, uint256 _totalsupply, uint256 _amount)
        private
    {
        syncreservebalances();

        ibancorformula formula = ibancorformula(addressof(bancor_formula));
        uint256 newpooltokensupply = _totalsupply.sub(_amount);

        for (uint256 i = 0; i < _reservetokens.length; i++) {
            ierc20token reservetoken = _reservetokens[i];
            uint256 rsvbalance = reserves[reservetoken].balance;
            uint256 reserveamount = formula.liquidatereserveamount(_totalsupply, rsvbalance, reserveratio, _amount);
            require(reserveamount >= _reserveminreturnamounts[i], );

            uint256 newreservebalance = rsvbalance.sub(reserveamount);
            reserves[reservetoken].balance = newreservebalance;

            
            if (reservetoken == eth_reserve_address)
                msg.sender.transfer(reserveamount);
            else
                safetransfer(reservetoken, msg.sender, reserveamount);

            emit liquidityremoved(msg.sender, reservetoken, reserveamount, newreservebalance, newpooltokensupply);

            
            uint32 reserveweight = reserves[reservetoken].weight;
            dispatchpooltokenrateevent(newpooltokensupply, reservetoken, newreservebalance, reserveweight);
        }
    }

    function getminshare(ibancorformula formula, uint256 _totalsupply, ierc20token[] memory _reservetokens, uint256[] memory _reserveamounts) private view returns (uint256) {
        uint256 minindex = 0;
        for (uint256 i = 1; i < _reservetokens.length; i++) {
            if (_reserveamounts[i].mul(reserves[_reservetokens[minindex]].balance) < _reserveamounts[minindex].mul(reserves[_reservetokens[i]].balance))
                minindex = i;
        }
        return formula.fundsupplyamount(_totalsupply, reserves[_reservetokens[minindex]].balance, reserveratio, _reserveamounts[minindex]);
    }

    
    function decimallength(uint256 _x) public pure returns (uint256) {
        uint256 y = 0;
        for (uint256 x = _x; x > 0; x /= 10)
            y++;
        return y;
    }

    
    function rounddiv(uint256 _n, uint256 _d) public pure returns (uint256) {
        return (_n + _d / 2) / _d;
    }

    
    function geometricmean(uint256[] memory _values) public pure returns (uint256) {
        uint256 numofdigits = 0;
        uint256 length = _values.length;
        for (uint256 i = 0; i < length; i++)
            numofdigits += decimallength(_values[i]);
        return uint256(10) ** (rounddiv(numofdigits, length)  1);
    }

     
    function dispatchrateevents(ierc20token _sourcetoken, ierc20token _targettoken) private {
        uint256 pooltokensupply = ismarttoken(anchor).totalsupply();
        uint256 sourcereservebalance = reservebalance(_sourcetoken);
        uint256 targetreservebalance = reservebalance(_targettoken);
        uint32 sourcereserveweight = reserves[_sourcetoken].weight;
        uint32 targetreserveweight = reserves[_targettoken].weight;

        
        uint256 raten = targetreservebalance.mul(sourcereserveweight);
        uint256 rated = sourcereservebalance.mul(targetreserveweight);
        emit tokenrateupdate(_sourcetoken, _targettoken, raten, rated);

        
        dispatchpooltokenrateevent(pooltokensupply, _sourcetoken, sourcereservebalance, sourcereserveweight);
        dispatchpooltokenrateevent(pooltokensupply, _targettoken, targetreservebalance, targetreserveweight);

        
        emit pricedataupdate(_sourcetoken, pooltokensupply, sourcereservebalance, sourcereserveweight);
        emit pricedataupdate(_targettoken, pooltokensupply, targetreservebalance, targetreserveweight);
    }

    
    function dispatchpooltokenrateevent(uint256 _pooltokensupply, ierc20token _reservetoken, uint256 _reservebalance, uint32 _reserveweight) private {
        emit tokenrateupdate(anchor, _reservetoken, _reservebalance.mul(weight_resolution), _pooltokensupply.mul(_reserveweight));
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;


contract liquiditypoolv1converterfactory is itypedconverterfactory {
    
    function convertertype() public pure returns (uint16) {
        return 1;
    }

    
    function createconverter(iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter) {
        iconverter converter = new liquiditypoolv1converter(ismarttoken(_anchor), _registry, _maxconversionfee);
        converter.transferownership(msg.sender);
        return converter;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract contractregistryclient is owned, utils {
    bytes32 internal constant contract_registry = ;
    bytes32 internal constant bancor_network = ;
    bytes32 internal constant bancor_formula = ;
    bytes32 internal constant converter_factory = ;
    bytes32 internal constant conversion_path_finder = ;
    bytes32 internal constant converter_upgrader = ;
    bytes32 internal constant converter_registry = ;
    bytes32 internal constant converter_registry_data = ;
    bytes32 internal constant bnt_token = ;
    bytes32 internal constant bancor_x = ;
    bytes32 internal constant bancor_x_upgrader = ;
    bytes32 internal constant chainlink_oracle_whitelist = ;

    icontractregistry public registry;      
    icontractregistry public prevregistry;  
    bool public onlyownercanupdateregistry; 

    
    modifier only(bytes32 _contractname) {
        _only(_contractname);
        _;
    }

    
    function _only(bytes32 _contractname) internal view {
        require(msg.sender == addressof(_contractname), );
    }

    
    constructor(icontractregistry _registry) internal validaddress(_registry) {
        registry = icontractregistry(_registry);
        prevregistry = icontractregistry(_registry);
    }

    
    function updateregistry() public {
        
        require(msg.sender == owner || !onlyownercanupdateregistry, );

        
        icontractregistry newregistry = icontractregistry(addressof(contract_registry));

        
        require(newregistry != address(registry) && newregistry != address(0), );

        
        require(newregistry.addressof(contract_registry) != address(0), );

        
        prevregistry = registry;

        
        registry = newregistry;
    }

    
    function restoreregistry() public owneronly {
        
        registry = prevregistry;
    }

    
    function restrictregistryupdate(bool _onlyownercanupdateregistry) public owneronly {
        
        onlyownercanupdateregistry = _onlyownercanupdateregistry;
    }

    
    function addressof(bytes32 _contractname) internal view returns (address) {
        return registry.addressof(_contractname);
    }
}

pragma solidity 0.4.26;
import ;


contract owned is iowned {
    address public owner;
    address public newowner;

    
    event ownerupdate(address indexed _prevowner, address indexed _newowner);

    
    constructor() public {
        owner = msg.sender;
    }

    
    modifier owneronly {
        _owneronly();
        _;
    }

    
    function _owneronly() internal view {
        require(msg.sender == owner, );
    }

    
    function transferownership(address _newowner) public owneronly {
        require(_newowner != owner, );
        newowner = _newowner;
    }

    
    function acceptownership() public {
        require(msg.sender == newowner, );
        emit ownerupdate(owner, newowner);
        owner = newowner;
        newowner = address(0);
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract contractregistry is icontractregistry, owned, utils {
    struct registryitem {
        address contractaddress;    
        uint256 nameindex;          
    }

    mapping (bytes32 => registryitem) private items;    
    string[] public contractnames;                      

    
    event addressupdate(bytes32 indexed _contractname, address _contractaddress);

    
    function itemcount() public view returns (uint256) {
        return contractnames.length;
    }

    
    function addressof(bytes32 _contractname) public view returns (address) {
        return items[_contractname].contractaddress;
    }

    
    function registeraddress(bytes32 _contractname, address _contractaddress)
        public
        owneronly
        validaddress(_contractaddress)
    {
        
        require(_contractname.length > 0, );

        
        address currentaddress = items[_contractname].contractaddress;
        if (_contractaddress == currentaddress)
            return;

        if (currentaddress == address(0)) {
            
            uint256 i = contractnames.push(bytes32tostring(_contractname));
            
            items[_contractname].nameindex = i  1;
        }

        
        items[_contractname].contractaddress = _contractaddress;

        
        emit addressupdate(_contractname, _contractaddress);
    }

    
    function unregisteraddress(bytes32 _contractname) public owneronly {
        
        require(_contractname.length > 0, );
        require(items[_contractname].contractaddress != address(0), );

        
        items[_contractname].contractaddress = address(0);

        
        
        if (contractnames.length > 1) {
            string memory lastcontractnamestring = contractnames[contractnames.length  1];
            uint256 unregisterindex = items[_contractname].nameindex;

            contractnames[unregisterindex] = lastcontractnamestring;
            bytes32 lastcontractname = stringtobytes32(lastcontractnamestring);
            registryitem storage registryitem = items[lastcontractname];
            registryitem.nameindex = unregisterindex;
        }

        
        contractnames.length;
        
        items[_contractname].nameindex = 0;

        
        emit addressupdate(_contractname, address(0));
    }

    
    function bytes32tostring(bytes32 _bytes) private pure returns (string) {
        bytes memory bytearray = new bytes(32);
        for (uint256 i = 0; i < 32; i++) {
            bytearray[i] = _bytes[i];
        }

        return string(bytearray);
    }

    
    function stringtobytes32(string memory _string) private pure returns (bytes32) {
        bytes32 result;
        assembly {
            result := mload(add(_string,32))
        }
        return result;
    }

    
    function getaddress(bytes32 _contractname) public view returns (address) {
        return addressof(_contractname);
    }
}

pragma solidity 0.4.26;


contract utils {
    
    modifier greaterthanzero(uint256 _value) {
        _greaterthanzero(_value);
        _;
    }

    
    function _greaterthanzero(uint256 _value) internal pure {
        require(_value > 0, );
    }

    
    modifier validaddress(address _address) {
        _validaddress(_address);
        _;
    }

    
    function _validaddress(address _address) internal pure {
        require(_address != address(0), );
    }

    
    modifier notthis(address _address) {
        _notthis(_address);
        _;
    }

    
    function _notthis(address _address) internal view {
        require(_address != address(this), );
    }
}

pragma solidity 0.4.26;
import ;

contract tokenhandler {
    bytes4 private constant approve_func_selector = bytes4(keccak256());
    bytes4 private constant transfer_func_selector = bytes4(keccak256());
    bytes4 private constant transfer_from_func_selector = bytes4(keccak256());

    
    function safeapprove(ierc20token _token, address _spender, uint256 _value) internal {
       execute(_token, abi.encodewithselector(approve_func_selector, _spender, _value));
    }

    
    function safetransfer(ierc20token _token, address _to, uint256 _value) internal {
       execute(_token, abi.encodewithselector(transfer_func_selector, _to, _value));
    }

    
    function safetransferfrom(ierc20token _token, address _from, address _to, uint256 _value) internal {
       execute(_token, abi.encodewithselector(transfer_from_func_selector, _from, _to, _value));
    }

    
    function execute(ierc20token _token, bytes memory _data) private {
        uint256[1] memory ret = [uint256(1)];

        assembly {
            let success := call(
                gas,            
                _token,         
                0,              
                add(_data, 32), 
                mload(_data),   
                ret,            
                32              
            )
            if iszero(success) {
                revert(0, 0)
            }
        }

        require(ret[0] != 0, );
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract priceoracle is ipriceoracle, utils {
    ierc20token public tokena;                  
    ierc20token public tokenb;                  
    ichainlinkpriceoracle public tokenaoracle;  
    ichainlinkpriceoracle public tokenboracle;  
    mapping (address => ichainlinkpriceoracle) public tokenstooracles;  

    
    constructor(ierc20token _tokena, ierc20token _tokenb, ichainlinkpriceoracle _tokenaoracle, ichainlinkpriceoracle _tokenboracle)
        public
        validaddress(_tokena)
        validaddress(_tokenb)
        validaddress(_tokenaoracle)
        validaddress(_tokenboracle)
    {
        
        _tokenaoracle.latestanswer();
        _tokenboracle.latestanswer();
        _tokenaoracle.latesttimestamp();
        _tokenboracle.latesttimestamp();

        tokena = _tokena;
        tokenb = _tokenb;
        tokenaoracle = _tokenaoracle;
        tokenboracle = _tokenboracle;
        tokenstooracles[_tokena] = _tokenaoracle;
        tokenstooracles[_tokenb] = _tokenboracle;
    }

    
    modifier supportedtoken(ierc20token _token) {
        _supportedtoken(_token);
        _;
    }

    
    function _supportedtoken(ierc20token _token) internal view {
        require(tokenstooracles[_token] != address(0), );
    }

    
    function latestrate(ierc20token _tokena, ierc20token _tokenb)
        public
        view
        supportedtoken(_tokena)
        supportedtoken(_tokenb)
        returns (uint256, uint256)
    {
        return (uint256(tokenstooracles[_tokena].latestanswer()), uint256(tokenstooracles[_tokenb].latestanswer()));
    }

    
    function lastupdatetime() public view returns (uint256) {
        
        uint256 timestampa = tokenaoracle.latesttimestamp();
        uint256 timestampb = tokenboracle.latesttimestamp();

        return  timestampa < timestampb ? timestampa : timestampb;
    }

    
    function latestrateandupdatetime(ierc20token _tokena, ierc20token _tokenb) public view returns (uint256, uint256, uint256) {
        (uint256 numerator, uint256 denominator) = latestrate(_tokena, _tokenb);

        return (numerator, denominator, lastupdatetime());
    }
}

pragma solidity 0.4.26;


contract reentrancyguard {
    
    bool private locked = false;

    
    constructor() internal {}

    
    modifier protected() {
        _protected();
        locked = true;
        _;
        locked = false;
    }

    
    function _protected() internal view {
        require(!locked, );
    }
}

pragma solidity 0.4.26;


library safemath {
    
    function add(uint256 _x, uint256 _y) internal pure returns (uint256) {
        uint256 z = _x + _y;
        require(z >= _x, );
        return z;
    }

    
    function sub(uint256 _x, uint256 _y) internal pure returns (uint256) {
        require(_x >= _y, );
        return _x  _y;
    }

    
    function mul(uint256 _x, uint256 _y) internal pure returns (uint256) {
        
        if (_x == 0)
            return 0;

        uint256 z = _x * _y;
        require(z / _x == _y, );
        return z;
    }

    
    function div(uint256 _x, uint256 _y) internal pure returns (uint256) {
        require(_y > 0, );
        uint256 c = _x / _y;
        return c;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract whitelist is iwhitelist, owned, utils {
    mapping (address => bool) private whitelist;

    
    event addressaddition(address indexed _address);

    
    event addressremoval(address indexed _address);

    
    function iswhitelisted(address _address) public view returns (bool) {
        return whitelist[_address];
    }

    
    function addaddress(address _address)
        owneronly
        validaddress(_address)
        public
    {
        if (whitelist[_address]) 
            return;

        whitelist[_address] = true;
        emit addressaddition(_address);
    }

    
    function addaddresses(address[] _addresses) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            addaddress(_addresses[i]);
        }
    }

    
    function removeaddress(address _address) owneronly public {
        if (!whitelist[_address]) 
            return;

        whitelist[_address] = false;
        emit addressremoval(_address);
    }

    
    function removeaddresses(address[] _addresses) public {
        for (uint256 i = 0; i < _addresses.length; i++) {
            removeaddress(_addresses[i]);
        }
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;


contract tokenholder is itokenholder, tokenhandler, owned, utils {
    
    function withdrawtokens(ierc20token _token, address _to, uint256 _amount)
        public
        owneronly
        validaddress(_token)
        validaddress(_to)
        notthis(_to)
    {
        safetransfer(_token, _to, _amount);
    }
}

pragma solidity 0.4.26;


contract icontractregistry {
    function addressof(bytes32 _contractname) public view returns (address);

    
    function getaddress(bytes32 _contractname) public view returns (address);
}

pragma solidity 0.4.26;
import ;
import ;


contract itokenholder is iowned {
    function withdrawtokens(ierc20token _token, address _to, uint256 _amount) public;
}

pragma solidity 0.4.26;


contract iowned {
    
    function owner() public view returns (address) {this;}

    function transferownership(address _newowner) public;
    function acceptownership() public;
}

pragma solidity 0.4.26;


contract iwhitelist {
    function iswhitelisted(address _address) public view returns (bool);
}

pragma solidity 0.4.26;
import ;
import ;


contract ipriceoracle {
    function latestrate(ierc20token _tokena, ierc20token _tokenb) public view returns (uint256, uint256);
    function lastupdatetime() public view returns (uint256);
    function latestrateandupdatetime(ierc20token _tokena, ierc20token _tokenb) public view returns (uint256, uint256, uint256);

    function tokenaoracle() public view returns (ichainlinkpriceoracle) {this;}
    function tokenboracle() public view returns (ichainlinkpriceoracle) {this;}
}

pragma solidity 0.4.26;


interface ichainlinkpriceoracle {
    function latestanswer() external view returns (int256);
    function latesttimestamp() external view returns (uint256);
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;


contract smarttoken is ismarttoken, owned, erc20token, tokenholder {
    using safemath for uint256;

    uint16 public constant version = 4;

    bool public transfersenabled = true;    

    
    event issuance(uint256 _amount);

    
    event destruction(uint256 _amount);

    
    constructor(string _name, string _symbol, uint8 _decimals)
        public
        erc20token(_name, _symbol, _decimals, 0)
    {
    }

    
    modifier transfersallowed {
        _transfersallowed();
        _;
    }

    
    function _transfersallowed() internal view {
        require(transfersenabled, );
    }

    
    function disabletransfers(bool _disable) public owneronly {
        transfersenabled = !_disable;
    }

    
    function issue(address _to, uint256 _amount)
        public
        owneronly
        validaddress(_to)
        notthis(_to)
    {
        totalsupply = totalsupply.add(_amount);
        balanceof[_to] = balanceof[_to].add(_amount);

        emit issuance(_amount);
        emit transfer(address(0), _to, _amount);
    }

    
    function destroy(address _from, uint256 _amount) public owneronly {
        balanceof[_from] = balanceof[_from].sub(_amount);
        totalsupply = totalsupply.sub(_amount);

        emit transfer(_from, address(0), _amount);
        emit destruction(_amount);
    }

    

    
    function transfer(address _to, uint256 _value) public transfersallowed returns (bool success) {
        assert(super.transfer(_to, _value));
        return true;
    }

    
    function transferfrom(address _from, address _to, uint256 _value) public transfersallowed returns (bool success) {
        assert(super.transferfrom(_from, _to, _value));
        return true;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract erc20token is ierc20token, utils {
    using safemath for uint256;


    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalsupply;
    mapping (address => uint256) public balanceof;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event transfer(address indexed _from, address indexed _to, uint256 _value);

    
    event approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalsupply) public {
        
        require(bytes(_name).length > 0, );
        require(bytes(_symbol).length > 0, );

        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalsupply = _totalsupply;
        balanceof[msg.sender] = _totalsupply;
    }

    
    function transfer(address _to, uint256 _value)
        public
        validaddress(_to)
        returns (bool success)
    {
        balanceof[msg.sender] = balanceof[msg.sender].sub(_value);
        balanceof[_to] = balanceof[_to].add(_value);
        emit transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferfrom(address _from, address _to, uint256 _value)
        public
        validaddress(_from)
        validaddress(_to)
        returns (bool success)
    {
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        balanceof[_from] = balanceof[_from].sub(_value);
        balanceof[_to] = balanceof[_to].add(_value);
        emit transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value)
        public
        validaddress(_spender)
        returns (bool success)
    {
        
        require(_value == 0 || allowance[msg.sender][_spender] == 0, );

        allowance[msg.sender][_spender] = _value;
        emit approval(msg.sender, _spender, _value);
        return true;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract ethertoken is iethertoken, erc20token {
    using safemath for uint256;

    
    event issuance(uint256 _amount);

    
    event destruction(uint256 _amount);

    
    constructor(string _name, string _symbol)
        public
        erc20token(_name, _symbol, 18, 0) {
    }

    
    function deposit() public payable {
        depositto(msg.sender);
    }

    
    function withdraw(uint256 _amount) public {
        withdrawto(msg.sender, _amount);
    }

    
    function depositto(address _to)
        public
        payable
        notthis(_to)
    {
        balanceof[_to] = balanceof[_to].add(msg.value); 
        totalsupply = totalsupply.add(msg.value); 

        emit issuance(msg.value);
        emit transfer(this, _to, msg.value);
    }

    
    function withdrawto(address _to, uint256 _amount)
        public
        notthis(_to)
    {
        balanceof[msg.sender] = balanceof[msg.sender].sub(_amount); 
        totalsupply = totalsupply.sub(_amount); 
        _to.transfer(_amount); 

        emit transfer(msg.sender, this, _amount);
        emit destruction(_amount);
    }

    

    
    function transfer(address _to, uint256 _value)
        public
        notthis(_to)
        returns (bool success)
    {
        assert(super.transfer(_to, _value));
        return true;
    }

    
    function transferfrom(address _from, address _to, uint256 _value)
        public
        notthis(_to)
        returns (bool success)
    {
        assert(super.transferfrom(_from, _to, _value));
        return true;
    }

    
    function() external payable {
        deposit();
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;


contract ismarttoken is iconverteranchor, ierc20token {
    function disabletransfers(bool _disable) public;
    function issue(address _to, uint256 _amount) public;
    function destroy(address _from, uint256 _amount) public;
}

pragma solidity 0.4.26;


contract ierc20token {
    
    function name() public view returns (string) {this;}
    function symbol() public view returns (string) {this;}
    function decimals() public view returns (uint8) {this;}
    function totalsupply() public view returns (uint256) {this;}
    function balanceof(address _owner) public view returns (uint256) {_owner; this;}
    function allowance(address _owner, address _spender) public view returns (uint256) {_owner; _spender; this;}

    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferfrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
}

pragma solidity 0.4.26;
import ;


contract iethertoken is ierc20token {
    function deposit() public payable;
    function withdraw(uint256 _amount) public;
    function depositto(address _to) public payable;
    function withdrawto(address _to, uint256 _amount) public;
}

pragma solidity 0.4.26;
import ;

contract xtransferrerouter is owned {
    bool public reroutingenabled;

    
    event txreroute(
        uint256 indexed _txid,
        bytes32 _toblockchain,
        bytes32 _to
    );

    
    constructor(bool _reroutingenabled) public {
        reroutingenabled = _reroutingenabled;
    }
    
    function enablererouting(bool _enable) public owneronly {
        reroutingenabled = _enable;
    }

    
    modifier reroutingallowed {
        _reroutingallowed();
        _;
    }

    
    function _reroutingallowed() internal view {
        require(reroutingenabled, );
    }

    
    function reroutetx(uint256 _txid, bytes32 _blockchain, bytes32 _to) public reroutingallowed {
        emit txreroute(_txid, _blockchain, _to);
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;
import ;
import ;
import ;


contract bancorx is ibancorx, tokenhandler, tokenholder, contractregistryclient {
    using safemath for uint256;

    
    struct transaction {
        uint256 amount;
        bytes32 fromblockchain;
        address to;
        uint8 numofreports;
        bool completed;
    }

    uint16 public constant version = 4;

    uint256 public maxlocklimit;            
    uint256 public maxreleaselimit;         
    uint256 public minlimit;                
    uint256 public prevlocklimit;           
    uint256 public prevreleaselimit;        
    uint256 public limitincperblock;        
    uint256 public prevlockblocknumber;     
    uint256 public prevreleaseblocknumber;  
    uint8 public minrequiredreports;        

    ierc20token public token;               

    bool public xtransfersenabled = true;   
    bool public reportingenabled = true;    

    
    mapping (uint256 => transaction) public transactions;

    
    mapping (uint256 => uint256) public transactionids;

    
    mapping (uint256 => mapping (address => bool)) public reportedtxs;

    
    mapping (address => bool) public reporters;

    
    event tokenslock(
        address indexed _from,
        uint256 _amount
    );

    
    event tokensrelease(
        address indexed _to,
        uint256 _amount
    );

    
    event xtransfer(
        address indexed _from,
        bytes32 _toblockchain,
        bytes32 indexed _to,
        uint256 _amount,
        uint256 _id
    );

    
    event txreport(
        address indexed _reporter,
        bytes32 _fromblockchain,
        uint256 _txid,
        address _to,
        uint256 _amount,
        uint256 _xtransferid
    );

    
    event xtransfercomplete(
        address _to,
        uint256 _id
    );

    
    constructor(
        uint256 _maxlocklimit,
        uint256 _maxreleaselimit,
        uint256 _minlimit,
        uint256 _limitincperblock,
        uint8 _minrequiredreports,
        icontractregistry _registry,
        ierc20token _token
    )   contractregistryclient(_registry)
        public
        greaterthanzero(_maxlocklimit)
        greaterthanzero(_maxreleaselimit)
        greaterthanzero(_minlimit)
        greaterthanzero(_limitincperblock)
        greaterthanzero(_minrequiredreports)
        validaddress(_token)
        notthis(_token)
    {
        
        require(_minlimit <= _maxlocklimit && _minlimit <= _maxreleaselimit, );

        
        maxlocklimit = _maxlocklimit;
        maxreleaselimit = _maxreleaselimit;
        minlimit = _minlimit;
        limitincperblock = _limitincperblock;
        minrequiredreports = _minrequiredreports;

        
        prevlocklimit = _maxlocklimit;
        prevreleaselimit = _maxreleaselimit;
        prevlockblocknumber = block.number;
        prevreleaseblocknumber = block.number;

        token = _token;
    }

    
    modifier reporteronly {
        _reporteronly();
        _;
    }

    
    function _reporteronly() internal view {
        require(reporters[msg.sender], );
    }

    
    modifier xtransfersallowed {
        _xtransfersallowed();
        _;
    }

    
    function _xtransfersallowed() internal view {
        require(xtransfersenabled, );
    }

    
    modifier reportingallowed {
        _reportingallowed();
        _;
    }

    
    function _reportingallowed() internal view {
        require(reportingenabled, );
    }

    
    function setmaxlocklimit(uint256 _maxlocklimit) public owneronly greaterthanzero(_maxlocklimit) {
        maxlocklimit = _maxlocklimit;
    }

    
    function setmaxreleaselimit(uint256 _maxreleaselimit) public owneronly greaterthanzero(_maxreleaselimit) {
        maxreleaselimit = _maxreleaselimit;
    }

    
    function setminlimit(uint256 _minlimit) public owneronly greaterthanzero(_minlimit) {
        
        require(_minlimit <= maxlocklimit && _minlimit <= maxreleaselimit, );

        minlimit = _minlimit;
    }

    
    function setlimitincperblock(uint256 _limitincperblock) public owneronly greaterthanzero(_limitincperblock) {
        limitincperblock = _limitincperblock;
    }

    
    function setminrequiredreports(uint8 _minrequiredreports) public owneronly greaterthanzero(_minrequiredreports) {
        minrequiredreports = _minrequiredreports;
    }

    
    function setreporter(address _reporter, bool _active) public owneronly {
        reporters[_reporter] = _active;
    }

    
    function enablextransfers(bool _enable) public owneronly {
        xtransfersenabled = _enable;
    }

    
    function enablereporting(bool _enable) public owneronly {
        reportingenabled = _enable;
    }

    
    function upgrade(address[] _reporters) public owneronly {
        ibancorxupgrader bancorxupgrader = ibancorxupgrader(addressof(bancor_x_upgrader));

        transferownership(bancorxupgrader);
        bancorxupgrader.upgrade(version, _reporters);
        acceptownership();
    }

    
    function xtransfer(bytes32 _toblockchain, bytes32 _to, uint256 _amount) public xtransfersallowed {
        
        uint256 currentlocklimit = getcurrentlocklimit();

        
        require(_amount >= minlimit && _amount <= currentlocklimit, );

        locktokens(_amount);

        
        prevlocklimit = currentlocklimit.sub(_amount);
        prevlockblocknumber = block.number;

        
        emit xtransfer(msg.sender, _toblockchain, _to, _amount, 0);
    }

    
    function xtransfer(bytes32 _toblockchain, bytes32 _to, uint256 _amount, uint256 _id) public xtransfersallowed {
        
        uint256 currentlocklimit = getcurrentlocklimit();

        
        require(_amount >= minlimit && _amount <= currentlocklimit, );

        locktokens(_amount);

        
        prevlocklimit = currentlocklimit.sub(_amount);
        prevlockblocknumber = block.number;

        
        emit xtransfer(msg.sender, _toblockchain, _to, _amount, _id);
    }

    
    function reporttx(
        bytes32 _fromblockchain,
        uint256 _txid,
        address _to,
        uint256 _amount,
        uint256 _xtransferid
    )
        public
        reporteronly
        reportingallowed
        validaddress(_to)
        greaterthanzero(_amount)
    {
        
        require(!reportedtxs[_txid][msg.sender], );

        
        reportedtxs[_txid][msg.sender] = true;

        transaction storage txn = transactions[_txid];

        
        if (txn.numofreports == 0) {
            txn.to = _to;
            txn.amount = _amount;
            txn.fromblockchain = _fromblockchain;

            if (_xtransferid != 0) {
                
                require(transactionids[_xtransferid] == 0, );
                transactionids[_xtransferid] = _txid;
            }
        } else {
            
            require(txn.to == _to && txn.amount == _amount && txn.fromblockchain == _fromblockchain, );

            if (_xtransferid != 0)
                require(transactionids[_xtransferid] == _txid, );
        }

        
        txn.numofreports++;

        emit txreport(msg.sender, _fromblockchain, _txid, _to, _amount, _xtransferid);

        
        if (txn.numofreports >= minrequiredreports) {
            require(!transactions[_txid].completed, );

            
            transactions[_txid].completed = true;

            emit xtransfercomplete(_to, _xtransferid);

            releasetokens(_to, _amount);
        }
    }

    
    function getxtransferamount(uint256 _xtransferid, address _for) public view returns (uint256) {
        
        transaction memory transaction = transactions[transactionids[_xtransferid]];

        
        require(transaction.to == _for, );

        return transaction.amount;
    }

    
    function getcurrentlocklimit() public view returns (uint256) {
        
        uint256 currentlocklimit = prevlocklimit.add(((block.number).sub(prevlockblocknumber)).mul(limitincperblock));
        if (currentlocklimit > maxlocklimit)
            return maxlocklimit;
        return currentlocklimit;
    }

    
    function getcurrentreleaselimit() public view returns (uint256) {
        
        uint256 currentreleaselimit = prevreleaselimit.add(((block.number).sub(prevreleaseblocknumber)).mul(limitincperblock));
        if (currentreleaselimit > maxreleaselimit)
            return maxreleaselimit;
        return currentreleaselimit;
    }

    
    function locktokens(uint256 _amount) private {
        safetransferfrom(token, msg.sender, address(this), _amount);
        emit tokenslock(msg.sender, _amount);
    }

    
    function releasetokens(address _to, uint256 _amount) private {
        
        uint256 currentreleaselimit = getcurrentreleaselimit();

        require(_amount >= minlimit && _amount <= currentreleaselimit, );

        
        prevreleaselimit = currentreleaselimit.sub(_amount);
        prevreleaseblocknumber = block.number;

        
        safetransfer(token, _to, _amount);

        emit tokensrelease(_to, _amount);
    }
}

pragma solidity 0.4.26;
import ;

contract ibancorx {
    function token() public view returns (ierc20token) {this;}
    function xtransfer(bytes32 _toblockchain, bytes32 _to, uint256 _amount, uint256 _id) public;
    function getxtransferamount(uint256 _xtransferid, address _for) public view returns (uint256);
}

pragma solidity 0.4.26;


contract ibancorxupgrader {
    function upgrade(uint16 _version, address[] _reporters) public;
}

pragma solidity 0.4.26;
import ;

contract testliquiditypoolconverter is liquiditypoolv1converter {
    constructor(
        ismarttoken _token,
        icontractregistry _registry,
        uint32 _maxconversionfee
    )
        liquiditypoolv1converter(_token, _registry, _maxconversionfee)
        public
    {
    }

    function setethertoken(iethertoken _ethertoken) public {
        ethertoken = _ethertoken;
    }
}

pragma solidity 0.4.26;
import ;


contract testsafemath {
    using safemath for uint256;

    function testsafeadd(uint256 _x, uint256 _y) public pure returns (uint256) {
        return _x.add(_y);
    }

    function testsafesub(uint256 _x, uint256 _y) public pure returns (uint256) {
        return _x.sub(_y);
    }

    function testsafemul(uint256 _x, uint256 _y) public pure returns (uint256) {
        return _x.mul(_y);
    }

    function testsafediv(uint256 _x, uint256 _y) public pure returns (uint256) {
        return _x.div(_y);
    }
}

pragma solidity 0.4.26;
import ;


contract testchainlinkpriceoracle is ichainlinkpriceoracle {
    int256 private answer;
    uint256 private timestamp;

    function setanswer(int256 _answer) public {
        answer = _answer;
        settimestamp(now);
    }

    function settimestamp(uint256 _timestamp) public {
        timestamp = _timestamp;
    }

    function latestanswer() external view returns (int256) {
        return answer;
    }

    function latesttimestamp() external view returns (uint256) {
        return timestamp;
    }
}

pragma solidity 0.4.26;
import ;


contract testcontractregistryclient is contractregistryclient {

    constructor(icontractregistry _registry) public contractregistryclient(_registry) {
    }
}

pragma solidity 0.4.26;
import ;


contract testbancorformula is bancorformula {
    function powertest(uint256 _basen, uint256 _based, uint32 _expn, uint32 _expd) external view returns (uint256, uint8) {
        return super.power(_basen, _based, _expn, _expd);
    }

    function generallogtest(uint256 x) external pure returns (uint256) {
        return super.generallog(x);
    }

    function floorlog2test(uint256 _n) external pure returns (uint8) {
        return super.floorlog2(_n);
    }

    function findpositioninmaxexparraytest(uint256 _x) external view returns (uint8) {
        return super.findpositioninmaxexparray(_x);
    }

    function generalexptest(uint256 _x, uint8 _precision) external pure returns (uint256) {
        return super.generalexp(_x, _precision);
    }

    function optimallogtest(uint256 x) external pure returns (uint256) {
        return super.optimallog(x);
    }

    function optimalexptest(uint256 x) external pure returns (uint256) {
        return super.optimalexp(x);
    }

    function normalizedweightstest(uint256 _a, uint256 _b) external pure returns (uint32, uint32) {
        return super.normalizedweights(_a, _b);
    }

    function accurateweightstest(uint256 _a, uint256 _b) external pure returns (uint32, uint32) {
        return super.accurateweights(_a, _b);
    }

    function rounddivtest(uint256 _n, uint256 _d) external pure returns (uint256) {
        return super.rounddiv(_n, _d);
    }
}

pragma solidity 0.4.26;
import ;


contract testconverterregistry is converterregistry {
    iconverter public createdconverter;

    constructor(icontractregistry _registry) public converterregistry(_registry) {
    }

    function newconverter(
        uint16 _type,
        string _name,
        string _symbol,
        uint8 _decimals,
        uint32 _maxconversionfee,
        ierc20token[] memory _reservetokens,
        uint32[] memory _reserveweights
    )
    public returns (iconverter) {
        createdconverter = super.newconverter(_type, _name, _symbol, _decimals, _maxconversionfee, _reservetokens,
            _reserveweights);

        return createdconverter;
    }
}

pragma solidity 0.4.26;
import ;
import ;
import ;

contract testtypedconverteranchorfactory is itypedconverteranchorfactory {
    string public name;

    constructor(string _name) public {
        name = _name;
    }

    function convertertype() public pure returns (uint16) {
        return 8;
    }

    function createanchor(string , string _symbol, uint8 _decimals) public returns (iconverteranchor) {
        iconverteranchor anchor = new smarttoken(name, _symbol, _decimals);

        anchor.transferownership(msg.sender);

        return anchor;
    }
}

pragma solidity 0.4.26;
import ;


contract testtokenhandler is tokenhandler {
    function testsafeapprove(ierc20token _token, address _spender, uint256 _value) public {
        safeapprove(_token, _spender, _value);
    }

    function testsafetransfer(ierc20token _token, address _to, uint256 _value) public {
        safetransfer(_token, _to, _value);
    }

    function testsafetransferfrom(ierc20token _token, address _from, address _to, uint256 _value) public {
        safetransferfrom(_token, _from, _to, _value);
    }
}

pragma solidity 0.4.26;
import ;


contract testreentrancyguardattacker {
    testreentrancyguard public target;
    bool public reentrancy;
    bool public callprotectedmethod;
    bool public attacking;

    constructor(testreentrancyguard _target) public {
        target = _target;
    }

    function setreentrancy(bool _reentrancy) external {
        reentrancy = _reentrancy;
    }

    function setcallprotectedmethod(bool _callprotectedmethod) external {
        callprotectedmethod = _callprotectedmethod;
    }

    function run() public {
        callprotectedmethod ? target.protectedmethod() : target.unprotectedmethod();
    }

    function callback() external {
        if (!reentrancy) {
            return;
        }

        if (!attacking) {
            attacking = true;

            run();
        }

        attacking = false;
    }
}

contract testreentrancyguard is reentrancyguard {
    uint256 public calls;

    function protectedmethod() external protected {
        run();
    }

    function unprotectedmethod() external {
        run();
    }

    function run() private {
        calls++;

        testreentrancyguardattacker(msg.sender).callback();
    }
}

pragma solidity 0.4.26;
import ;

contract testliquiditypoolv2converter is liquiditypoolv2converter {
    uint256 private currenttime;

    constructor(ipooltokenscontainer _token, icontractregistry _registry, uint32 _maxconversionfee)
        public liquiditypoolv2converter(_token, _registry, _maxconversionfee) {
    }

    function setreferencerateupdatetime(uint256 _referencerateupdatetime) public {
        referencerateupdatetime = _referencerateupdatetime;
    }

    function time() internal view returns (uint256) {
        return currenttime != 0 ? currenttime : now;
    }

    function settime(uint256 _currenttime) public {
        currenttime = _currenttime;
    }

    function calculateadjustedfeetest(
        uint256 _primaryreservestaked,
        uint256 _secondaryreservestaked,
        uint256 _primaryreserveweight,
        uint256 _secondaryreserveweight,
        uint256 _primaryreserverate,
        uint256 _secondaryreserverate,
        uint256 _conversionfee)
        external
        pure
        returns (uint256)
    {
        return calculateadjustedfee(
            _primaryreservestaked,
            _secondaryreservestaked,
            _primaryreserveweight,
            _secondaryreserveweight,
            _primaryreserverate,
            _secondaryreserverate,
            _conversionfee);
    }
}

pragma solidity 0.4.26;
import ;
import ;


contract nonstandardtoken is utils {
    using safemath for uint256;

    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalsupply;
    mapping (address => uint256) public balanceof;
    mapping (address => mapping (address => uint256)) public allowance;

    event transfer(address indexed _from, address indexed _to, uint256 _value);
    event approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    constructor(string _name, string _symbol, uint8 _decimals, uint256 _supply)
        internal
    {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
        totalsupply = _supply;
        balanceof[msg.sender] = _supply;
    }

    
    function _transfer(address _to, uint256 _value)
        internal
        validaddress(_to)
    {
        balanceof[msg.sender] = balanceof[msg.sender].sub(_value);
        balanceof[_to] = balanceof[_to].add(_value);
        emit transfer(msg.sender, _to, _value);
    }

    
    function _transferfrom(address _from, address _to, uint256 _value)
        internal
        validaddress(_from)
        validaddress(_to)
    {
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        balanceof[_from] = balanceof[_from].sub(_value);
        balanceof[_to] = balanceof[_to].add(_value);
        emit transfer(_from, _to, _value);
    }

    
    function _approve(address _spender, uint256 _value)
        internal
        validaddress(_spender)
    {
        
        require(_value == 0 || allowance[msg.sender][_spender] == 0);

        allowance[msg.sender][_spender] = _value;
        emit approval(msg.sender, _spender, _value);
    }
}

contract testnonstandardtoken is nonstandardtoken {
    bool public ok;

    constructor(string _name, string _symbol, uint8 _decimals, uint256 _supply) public
        nonstandardtoken(_name, _symbol, _decimals, _supply) {
        set(true);
    }

    function set(bool _ok) public {
        ok = _ok;
    }

    function approve(address _spender, uint256 _value) public {
        _approve(_spender, _value);
        require(ok);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(_to, _value);
        require(ok);
    }

    function transferfrom(address _from, address _to, uint256 _value) public {
        _transferfrom(_from, _to, _value);
        require(ok);
    }
}

contract teststandardtoken is nonstandardtoken {
    bool public ok;
    bool public ret;

    constructor(string _name, string _symbol, uint8 _decimals, uint256 _supply) public
        nonstandardtoken(_name, _symbol, _decimals, _supply) {
        set(true, true);
    }

    function set(bool _ok, bool _ret) public {
        ok = _ok;
        ret = _ret;
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        _approve(_spender, _value);
        require(ok);
        return ret;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        _transfer(_to, _value);
        require(ok);
        return ret;
    }

    function transferfrom(address _from, address _to, uint256 _value) public returns (bool) {
        _transferfrom(_from, _to, _value);
        require(ok);
        return ret;
    }
}

pragma solidity 0.4.26;
import ;


contract testconverterfactory is converterfactory {
    iconverter public createdconverter;
    iconverteranchor public createdanchor;

    function createanchor(uint16 _convertertype, string _name, string _symbol, uint8 _decimals) public returns (iconverteranchor) {
        createdanchor = super.createanchor(_convertertype, _name, _symbol, _decimals);

        return createdanchor;
    }

    function createconverter(uint16 _type, iconverteranchor _anchor, icontractregistry _registry, uint32 _maxconversionfee) public returns (iconverter) {
        createdconverter = super.createconverter(_type, _anchor, _registry, _maxconversionfee);

        return createdconverter;
    }
}

pragma solidity 0.4.26;
import ;

contract oldconverter {
    uint256 private amount;

    constructor(uint256 _amount) public {
        amount = _amount;
    }

    function getreturn(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount) external view returns (uint256) {
        _sourcetoken;
        _targettoken;
        _amount;
        return (amount);
    }
}

contract newconverter {
    uint256 private amount;
    uint256 private fee;

    constructor(uint256 _amount, uint256 _fee) public {
        amount = _amount;
        fee = _fee;
    }

    function getreturn(ierc20token _sourcetoken, ierc20token _targettoken, uint256 _amount) external view returns (uint256, uint256) {
        _sourcetoken;
        _targettoken;
        _amount;
        return (amount, fee);
    }
}

contract converterv27orlowerwithoutfallback {
}

contract converterv27orlowerwithfallback {
    function() external payable {
    }
}

contract converterv28orhigherwithoutfallback {
    function isv28orhigher() public pure returns (bool) {
        return true;
    }
}

contract converterv28orhigherwithfallback {
    function isv28orhigher() public pure returns (bool) {
        return true;
    }

    function() external payable {
        revert();
    }
}

contract testbancornetwork is bancornetwork {
    oldconverter private oldconverter;
    newconverter private newconverter;

    constructor(uint256 _amount, uint256 _fee) public bancornetwork(icontractregistry(address(1))) {
        oldconverter = new oldconverter(_amount);
        newconverter = new newconverter(_amount, _fee);
    }

    function isv28orhigherconverterexternal(iconverter _converter) external view returns (bool) {
        return super.isv28orhigherconverter(_converter);
    }

    function getreturnold() external view returns (uint256, uint256) {
        return getreturn(address(oldconverter), ierc20token(0), ierc20token(0), uint256(0));
    }

    function getreturnnew() external view returns (uint256, uint256) {
        return getreturn(address(newconverter), ierc20token(0), ierc20token(0), uint256(0));
    }
}

