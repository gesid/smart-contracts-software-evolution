pragma solidity ^0.4.23;

import ;
import ;
import ;
import ;
import ;
import ;

library builtin {
    function getauthority() internal pure returns(authority) {
        return authority(uint160(bytes9()));
    }

    function getenergy() internal pure returns(energy) {
        return energy(uint160(bytes6()));
    }

    function getextension() internal pure returns(extension) {
        return extension(uint160(bytes9()));
    }

    function getparams() internal pure returns(params) {
        return params(uint160(bytes6()));
    }

    function getexecutor() internal pure returns(executor) {
        return executor(uint160(bytes6()));
    }


    
    
    
    function $energy(address self) internal view returns(uint256 amount){
        return energy.balanceof(self);
    }

    function $transferenergy(address self, uint256 amount) internal{
        energy.transfer(self, amount);
    }

    function $moveenergyto(address self, address to, uint256 amount) internal{
        energy.move(self, to, amount);
    }

    
    
    function $master(address self) internal view returns(address){
        return prototype.master(self);
    }
    function $setmaster(address self, address newmaster) internal {
        prototype.setmaster(self, newmaster);
    }
    function $balance(address self, uint blocknumber) internal view returns(uint256){
        return prototype.balance(self, blocknumber);
    }
    function $energy(address self, uint blocknumber) internal view returns(uint256){
        return prototype.energy(self, blocknumber);
    }
    function $hascode(address self) internal view returns(bool){
        return prototype.hascode(self);
    }
    function $storagefor(address self, bytes32 key) internal view returns(bytes32){
        return prototype.storagefor(self, key);
    }
    function $creditplan(address self) internal view returns(uint256 credit, uint256 recoveryrate){
        return prototype.creditplan(self);
    }
    function $setcreditplan(address self, uint256 credit, uint256 recoveryrate) internal{
        prototype.setcreditplan(self, credit, recoveryrate);
    }
    function $isuser(address self, address user) internal view returns(bool){
        return prototype.isuser(self, user);
    }
    function $usercredit(address self, address user) internal view returns(uint256){
        return prototype.usercredit(self, user);
    }
    function $adduser(address self, address user) internal{
        prototype.adduser(self, user);
    }
    function $removeuser(address self, address user) internal{
        prototype.removeuser(self, user);
    }
    function $sponsor(address self) internal{
        prototype.sponsor(self);
    }
    function $unsponsor(address self) internal {
        prototype.unsponsor(self);
    }
    function $issponsor(address self, address sponsor) internal view returns(bool){
        return prototype.issponsor(self, sponsor);
    }
    function $selectsponsor(address self, address sponsor) internal{
        prototype.selectsponsor(self, sponsor);
    }
    function $currentsponsor(address self) internal view returns(address){
        return prototype.currentsponsor(self);
    }
}

pragma solidity ^0.4.23;







interface params {
    function executor() external view returns(address);
    function set(bytes32 _key, uint256 _value) external;
    function get(bytes32 _key) external view returns(uint256);
}
pragma solidity ^0.4.23;







interface authority {

    
    function executor() external view returns(address);

    
    function add(address _signer, address _endorsor, bytes32 _identity) external;

    
    function revoke(address _signer) external;

    
    function get(address _signer) external view returns(bool listed, address endorsor, bytes32 identity, bool active);
    
    
    function first() external view returns(address);

    
    function next(address _signer) external view returns(address);
}
pragma solidity ^0.4.23;






interface extension {
    
    function blake2b256(bytes _value) external view returns(bytes32);

    
    function blockid(uint num) external view returns(bytes32);
    function blocktotalscore(uint num) external view returns(uint64);
    function blocktime(uint num) external view returns(uint);
    function blocksigner(uint num) external view returns(address);

    
    function totalsupply() external view returns(uint256);

    
    function txprovedwork() external view returns(uint256);
    function txid() external view returns(bytes32);
    function txblockref() external view returns(bytes8);
    function txexpiration() external view returns(uint);
}
pragma solidity ^0.4.23;







interface energy {
    
    function name() external pure returns (string);

    
    
    function decimals() external pure returns (uint8);

    
    function symbol() external pure returns (string);

    
    function totalsupply() external view returns (uint256);

    
    function totalburned() external view returns(uint256);

    
    function balanceof(address _owner) external view returns (uint256 balance);

    
    function transfer(address _to, uint256 _amount) external returns (bool success);

    
    
    
    
    function move(address _from, address _to, uint256 _amount) external returns (bool success);

    
    function transferfrom(address _from, address _to, uint256 _amount) external returns(bool success);

    
    
    function allowance(address _owner, address _spender)  external view returns (uint256 remaining);

    
    function approve(address _spender, uint256 _value) external returns (bool success);
}

pragma solidity ^0.4.23;















interface prototype {
    
    
    function master(address self) external view returns(address);

    
    
    
    function setmaster(address self, address newmaster) external;

    
    
    
    function balance(address self, uint blocknumber) external view returns(uint256);

    
    
    
    function energy(address self, uint blocknumber) external view returns(uint256);

    
    function hascode(address self) external view returns(bool);

    
    
    function storagefor(address self, bytes32 key) external view returns(bytes32);

    
    
    function creditplan(address self) external view returns(uint256 credit, uint256 recoveryrate);

    
    
    
    function setcreditplan(address self, uint256 credit, uint256 recoveryrate) external;

    
    function isuser(address self, address user) external view returns(bool);

    
    function usercredit(address self, address user) external view returns(uint256);

    
    function adduser(address self, address user) external;

    
    function removeuser(address self, address user) external;

    
    function sponsor(address self) external;
 
    
    function unsponsor(address self) external;

    
    function issponsor(address self, address sponsoraddress) external view returns(bool);

    
    function selectsponsor(address self, address sponsoraddress) external;  

    
    function currentsponsor(address self) external view returns(address);
}
pragma solidity ^0.4.23;


interface executor {    
    function propose(address _target, bytes _data) external returns(bytes32);
    function approve(bytes32 _proposalid) external;
    function execute(bytes32 _proposalid) external;
    function addapprover(address _approver, bytes32 _identity) external;
    function revokeapprover(address _approver) external;
    function attachvotingcontract(address _contract) external;
    function detachvotingcontract(address _contract) external;
}
pragma solidity ^0.4.23;

contract migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setcompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    migrations upgraded = migrations(new_address);
    upgraded.setcompleted(last_completed_migration);
  }
}

